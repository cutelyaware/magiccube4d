// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// 102 # 1 "com/donhatchsw/util/VecMath.prejava"
// 103 # 1 "<built-in>"
// 104 # 1 "<command-line>"
// 105 # 1 "com/donhatchsw/util/VecMath.prejava"
/* vim: set filetype=java: */
/*
* Copyright (c) 2005 Don Hatch Software
*/
//
// VecMath.prejava
//
// Author: Don Hatch (hatch@plunk.org)
// This code may be used for any purpose as long as it is good and not evil.
//

package com.donhatchsw.util;

// 119 # 1 "com/donhatchsw/util/macros.h" 1
//
// macros.h
//
// 123 # 14 "com/donhatchsw/util/macros.h"
// NOTE: this causes a,b to be evaluated twice on failure, so is not ideal. might be better to do a block... ?
// 125 # 30 "com/donhatchsw/util/macros.h"
// Note: the additional "(a)==(b)||" is to make it work correctly for infinities...
// and causes the args to be evaluated twice.
// 128 # 67 "com/donhatchsw/util/macros.h"
// XXX ... what a mess
// 130 # 15 "com/donhatchsw/util/VecMath.prejava" 2



/**
 * Some common operations on vectors and matrices,
 * using an array representation.
 * <p>
 * Most of the vector and matrix arithmetic operations
 * have two forms: a fast version in which the caller supplies
 * the result vector or matrix, and a more convenient but slower version
 * which returns a newly allocated result.
 */

/* not in javadoc, for now */
/*
 * XXX JAVADOC there are some parameter comments that should be converted to javadoc
 */
public final class VecMath
{
    private VecMath() {} // uninstantiatable


    /** vector plus vector */
    public static void vpv(int n, double result[], double v0[], double v1[])
    {
        for (int i = 0; (i) < (n); ++i)
            result[i] = v0[i] + v1[i];
    }
    /** vector plus vector */
    public static void vpv(int n, float result[], float v0[], float v1[])
    {
        for (int i = 0; (i) < (n); ++i)
            result[i] = v0[i] + v1[i];
    }
    /** vector plus vector */
    public static void vpv(double result[], double v0[], double v1[])
    {
        vpv(((result.length)<=(v0.length)?((result.length)<=(v1.length)?(result.length):(v1.length)):((v0.length)<=(v1.length)?(v0.length):(v1.length))), result, v0, v1);
    }
    /** vector plus vector */
    public static void vpv(float result[], float v0[], float v1[])
    {
        vpv(((result.length)<=(v0.length)?((result.length)<=(v1.length)?(result.length):(v1.length)):((v0.length)<=(v1.length)?(v0.length):(v1.length))), result, v0, v1);
    }
    /** vector plus vector */
    public static void vpv(int result[], int v0[], int v1[])
    {
        for (int i = (v0.length)-1; (i) >= 0; --i)
            result[i] = v0[i] + v1[i];
    }
    /** vector minus vector */
    public static void vmv(int n, double result[], double v0[], double v1[])
    {
        for (int i = 0; (i) < (n); ++i)
            result[i] = v0[i] - v1[i];
    }
    /** vector minus vector */
    public static void vmv(int n, float result[], float v0[], float v1[])
    {
        for (int i = 0; (i) < (n); ++i)
            result[i] = v0[i] - v1[i];
    }
    /** vector minus vector */
    public static void vmv(int n, int result[], int v0[], int v1[])
    {
        for (int i = 0; (i) < (n); ++i)
            result[i] = v0[i] - v1[i];
    }
    /** vector minus vector */
    public static void vmv(double result[], double v0[], double v1[])
    {
        vmv(((result.length)<=(v0.length)?((result.length)<=(v1.length)?(result.length):(v1.length)):((v0.length)<=(v1.length)?(v0.length):(v1.length))), result, v0, v1);
    }
    /** vector minus vector */
    public static void vmv(float result[], float v0[], float v1[])
    {
        vmv(((result.length)<=(v0.length)?((result.length)<=(v1.length)?(result.length):(v1.length)):((v0.length)<=(v1.length)?(v0.length):(v1.length))), result, v0, v1);
    }
    /** vector minus vector */
    public static void vmv(int result[], int v0[], int v1[])
    {
        vmv(((result.length)<=(v0.length)?((result.length)<=(v1.length)?(result.length):(v1.length)):((v0.length)<=(v1.length)?(v0.length):(v1.length))), result, v0, v1);
    }

    /** vector times scalar */
    public static void vxs(int n, double result[], double v[], double s)
    {
        for (int i = (n)-1; (i) >= 0; --i)
            result[i] = v[i] * s;
    }
    /** vector times scalar */
    public static void vxs(double result[], double v[], double s)
    {
        vxs(((result.length)<=(v.length)?(result.length):(v.length)), result, v, s);
    }
    /** vector times scalar */
    public static void vxs(int n, float result[], float v[], float s)
    {
        for (int i = (n)-1; (i) >= 0; --i)
            result[i] = v[i] * s;
    }
    /** vector times scalar */
    public static void vxs(float result[], float v[], float s)
    {
        vxs(((result.length)<=(v.length)?(result.length):(v.length)), result, v, s);
    }

    /** matrix times scalar */
    public static void mxs(double result[][], double M[][], double s)
    {
        for (int i = (M.length)-1; (i) >= 0; --i)
            if (result[i] != null)
                vxs(result[i], M[i], s);
    }
    /** matrix times scalar */
    public static void mxs(float result[][], float M[][], float s)
    {
        for (int i = (M.length)-1; (i) >= 0; --i)
            if (result[i] != null)
                vxs(result[i], M[i], s);
    }
    /** matrix times scalar */
    public static void mxs(double result[][][], double M[][][], double s)
    {
        for (int i = (M.length)-1; (i) >= 0; --i)
            mxs(result[i], M[i], s);
    }
    /** matrix times scalar */
    public static void mxs(double result[][][][], double M[][][][], double s)
    {
        for (int i = (M.length)-1; (i) >= 0; --i)
            mxs(result[i], M[i], s);
    }
    /** scalar times matrix */
    public static void sxm(double result[][], double s, double M[][])
    {
        for (int i = (M.length)-1; (i) >= 0; --i)
            if (result[i] != null)
                sxv(result[i], s, M[i]);
    }
    /** scalar times matrix */
    public static void sxm(double result[][][], double s, double M[][][])
    {
        for (int i = (M.length)-1; (i) >= 0; --i)
            sxm(result[i], s, M[i]);
    }
    /** scalar times matrix */
    public static void sxm(double result[][][][], double s, double M[][][][])
    {
        for (int i = (M.length)-1; (i) >= 0; --i)
            sxm(result[i], s, M[i]);
    }

    /** scalar times vector */
    public static void sxv(int n, double result[], double s, double v[])
    {
        for (int i = (n)-1; (i) >= 0; --i)
            result[i] = s * v[i];
    }
    /** scalar times vector */
    public static void sxv(double result[], double s, double v[])
    {
        sxv(((result.length)<=(v.length)?(result.length):(v.length)), result, s, v);
    }
    /** scalar times vector */
    public static void sxv(int n, float result[], float s, float v[])
    {
        for (int i = (n)-1; (i) >= 0; --i)
            result[i] = s * v[i];
    }
    /** scalar times vector */
    public static void sxv(float result[], float s, float v[])
    {
        sxv(((result.length)<=(v.length)?(result.length):(v.length)), result, s, v);
    }
    /** scalar times vector */
    public static void sxv(int n, int result[], int s, int v[])
    {
        for (int i = (n)-1; (i) >= 0; --i)
            result[i] = s * v[i];
    }
    /** scalar times vector */
    public static void sxv(int result[], int s, int v[])
    {
        sxv(((result.length)<=(v.length)?(result.length):(v.length)), result, s, v);
    }

    /** v0 as a single-column matrix times v1 as a single-row matrix */
    public static void outerProduct(double result[][], double v0[], double v1[])
    {
        for (int i = (result.length)-1; (i) >= 0; --i)
            sxv(result[i], v0[i], v1);
    }

    /** m + outerProduct(v0, v1) */
    public static void mpouterProduct(double result[][], double m[][], double v0[], double v1[])
    {
        for (int i = (result.length)-1; (i) >= 0; --i)
            vpsxv(result[i], m[i], v0[i], v1);
    }


    /** perp dot */
    public static void xv2(double result[/*2*/], double v[/*2*/])
    {
        result[0] = -v[1];
        result[1] = v[0];
    }
    /** determinant of matrix having the two vectors as rows */
    public static double vxv2(double v[/*2*/], double w[/*2*/])
    {
        return v[0]*w[1] - v[1]*w[0];
    }
    /** determinant of matrix having the two vectors as rows */
    public static float vxv2(float v[/*2*/], float w[/*2*/])
    {
        return v[0]*w[1] - v[1]*w[0];
    }


    /** 3-dimensional vector plus cross product */
    public static void vpvxv3(double result[/*3*/], double v0[/*3*/], final double v1[/*3*/], final double v2[/*3*/])
    {
        result[0] = v0[0] + v1[1]*v2[2] - v1[2]*v2[1];
        result[1] = v0[1] + v1[2]*v2[0] - v1[0]*v2[2];
        result[2] = v0[2] + v1[0]*v2[1] - v1[1]*v2[0];
    }
    /** 3-dimensional vector plus cross product */
    public static void vpvxv3(float result[/*3*/], float v0[/*3*/], final float v1[/*3*/], final float v2[/*3*/])
    {
        result[0] = v0[0] + v1[1]*v2[2] - v1[2]*v2[1];
        result[1] = v0[1] + v1[2]*v2[0] - v1[0]*v2[2];
        result[2] = v0[2] + v1[0]*v2[1] - v1[1]*v2[0];
    }

    /** 3-dimensional cross product */
    public static void vxv3(double v0[/*3*/], final double v1[/*3*/], final double v2[/*3*/])
    {
        v0[0] = v1[1]*v2[2] - v1[2]*v2[1];
        v0[1] = v1[2]*v2[0] - v1[0]*v2[2];
        v0[2] = v1[0]*v2[1] - v1[1]*v2[0];
    }
    /** 3-dimensional cross product */
    public static void vxv3(float v0[/*3*/], final float v1[/*3*/], final float v2[/*3*/])
    {
        v0[0] = v1[1]*v2[2] - v1[2]*v2[1];
        v0[1] = v1[2]*v2[0] - v1[0]*v2[2];
        v0[2] = v1[0]*v2[1] - v1[1]*v2[0];
    }
    /** determinant of matrix having the three vectors as rows */
    public static double vxvxv3(double v0[/*3*/], double v1[/*3*/], double v2[/*3*/])
    {
        return v0[0] * (v1[1]*v2[2] - v1[2]*v2[1])
             + v0[1] * (v1[2]*v2[0] - v1[0]*v2[2])
             + v0[2] * (v1[0]*v2[1] - v1[1]*v2[0]);
    }
    /** determinant of matrix having the three vectors as rows */
    public static float vxvxv3(float v0[/*3*/], float v1[/*3*/], float v2[/*3*/])
    {
        return v0[0] * (v1[1]*v2[2] - v1[2]*v2[1])
             + v0[1] * (v1[2]*v2[0] - v1[0]*v2[2])
             + v0[2] * (v1[0]*v2[1] - v1[1]*v2[0]);
    }
    /** n-dimensional cross product of the first n-1 n-dimensional vectors in the matrix */
    public static void crossprod(double result[/*dim*/], double vectors[/*dim-1*/][/*dim*/])
    {
        int dim = result.length;
        if (dim == 0)
            return; // not a lot of options here, don't think too hard about it
        do { if (!(vectors.length >= dim-1)) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+284 +"): " + "vectors.length >= dim-1" + ""); } while (false);

        if (true)
        {
            // optimize for small cases...
            switch(dim)
            {
                case 1:
                    result[0] = 1.;
                    return;
                case 2:
                    xv2(result, vectors[0]);
                    return;
                case 3:
                    // 3d cross product
                    vxv3(result, vectors[0], vectors[1]);
                    return;
            }
        }
        else
        {
            if (dim == 1 || dim == 2 || dim == 3)
                System.err.println("WARNING: doing slow crossprod for testing, dim = "+dim+"");
        }

        {
            double cofactorMatrix[][] = new double[dim-1][dim-1];
            int sign = ((dim-1) % 2 == 0 ? 1 : -1);
            for (int i = 0; (i) < (dim); ++i)
            {
                // cofactor matrix is vectors matrix with column i deleted...
                {
                    for (int j = 0; (j) < (dim-1); ++j)
                    for (int k = 0; (k) < (dim-1); ++k)
                        cofactorMatrix[j][k] = vectors[j][k>=i?k+1:k];
                }
                result[i] = detDestructive(cofactorMatrix) * sign;
                sign = -sign;
            }
        }
    } // crossprod


    /** vector plus (scalar times vector) */
    public static void vpsxv(int n, double result[], double v0[],
                                              double s1, double v1[])
    {
        for (int i = 0; (i) < (n); ++i)
            result[i] = v0[i] + s1*v1[i];
    }

    /** vector plus (scalar times vector) */
    public static void vpsxv(int n, float result[], float v0[],
                                             float s1, float v1[])
    {
        for (int i = 0; (i) < (n); ++i)
            result[i] = v0[i] + s1*v1[i];
    }

    /** vector plus (scalar times vector) */
    public static void vpsxv(int n, int result[], int v0[],
                                           int s1, int v1[])
    {
        for (int i = 0; (i) < (n); ++i)
            result[i] = v0[i] + s1*v1[i];
    }

    /** vector plus (scalar times vector) */
    public static void vpsxv(double result[], double v0[],
                                              double s1, double v1[])
    {
        vpsxv(v0.length, result, v0, s1, v1);
    }

    /** vector plus (scalar times vector) */
    public static void vpsxv(float result[], float v0[],
                                             float s1, float v1[])
    {
        vpsxv(v0.length, result, v0, s1, v1);
    }

    /** vector plus (scalar times vector) */
    public static void vpsxv(int result[], int v0[],
                                           int s1, int v1[])
    {
        vpsxv(v0.length, result, v0, s1, v1);
    }

    /** vector plus vector minus vector */
    public static void vpvmv(double result[], double v0[], double v1[], double v2[])
    {
        for (int i = (v0.length)-1; (i) >= 0; --i)
            result[i] = v0[i] + (v1[i] - v2[i]);
    }

    /** (scalar times vector) plus (scalar times vector) */
    public static void sxvpsxv(int n, double result[], double s0, double v0[],
                                                       double s1, double v1[])
    {
        for (int i = (n)-1; (i) >= 0; --i)
            result[i] = s0*v0[i] + s1*v1[i];
    }

    /** (scalar times vector) plus (scalar times vector) */
    public static void sxvpsxv(double result[], double s0, double v0[],
                                                double s1, double v1[])
    {
        sxvpsxv(v0.length, result, s0, v0, s1, v1);
    }

    /** vector plus (scalar times vector) plus (scalar times vector) */
    public static void vpsxvpsxv(int n, double result[], double v0[],
                                                  double s1, double v1[],
                                                  double s2, double v2[])
    {
        for (int i = 0; (i) < (n); ++i)
            result[i] = v0[i] + s1*v1[i] + s2*v2[i];
    }

    /** vector plus (scalar times vector) plus (scalar times vector) */
    public static void vpsxvpsxv(double result[], double v0[],
                                                  double s1, double v1[],
                                                  double s2, double v2[])
    {
        vpsxvpsxv(v0.length, result, v0, s1, v1, s2, v2);
    }

    /** (scalar times vector) plus (scalar times vector) plus (scalar times vector) */
    public static void sxvpsxvpsxv(int n, double result[], double s0, double v0[],
                                                    double s1, double v1[],
                                                    double s2, double v2[])
    {
        for (int i = 0; (i) < (n); ++i)
            result[i] = s0*v0[i] + s1*v1[i] + s2*v2[i];
    }

    /** (scalar times vector) plus (scalar times vector) plus (scalar times vector) */
    public static void sxvpsxvpsxv(double result[], double s0, double v0[],
                                                    double s1, double v1[],
                                                    double s2, double v2[])
    {
        sxvpsxvpsxv(v0.length, result, s0, v0, s1, v1, s2, v2);
    }

    /** matrix plus matrix */
    public static void mpm(Object result, Object M0, Object M1)
    {
        if (result instanceof int[])
            vpv((int[])result, (int[])M0, (int[])M1);
        else if (result instanceof double[])
            vpv((double[])result, (double[])M0, (double[])M1);
        else
        {
            Object resultArray[] = (Object[])result;
            Object M0Array[] = (Object[])M0;
            Object M1Array[] = (Object[])M1;
            for (int i = (resultArray.length)-1; (i) >= 0; --i)
                mpm(resultArray[i], M0Array[i], M1Array[i]);
        }
    } // mpm

    /** matrix minus matrix */
    public static void mmm(Object result, Object M0, Object M1)
    {
        if (result instanceof int[])
            vmv((int[])result, (int[])M0, (int[])M1);
        else if (result instanceof double[])
            vmv((double[])result, (double[])M0, (double[])M1);
        else
        {
            Object resultArray[] = (Object[])result;
            Object M0Array[] = (Object[])M0;
            Object M1Array[] = (Object[])M1;
            for (int i = (resultArray.length)-1; (i) >= 0; --i)
                mmm(resultArray[i], M0Array[i], M1Array[i]);
        }
    } // mmm

    /** matrix minus matrix, returning newly allocated result */
    public static double[][] mmm(double M0[][], double M1[][])
    {
        double result[][] = new double[M0.length][M0[0].length];
        mmm(result, M0, M1);
        return result;
    }

    /** add v to every row of M. */
    public static void vpm(double result[][], double v[], double M[][])
    {
        for (int i = (M.length)-1; (i) >= 0; --i)
            if (M[i] != null)
                vpv(result[i], M[i], v);
    }
    /** add v to every row of M. */
    public static void vpm(int result[][], int v[], int M[][])
    {
        for (int i = (M.length)-1; (i) >= 0; --i)
            if (M[i] != null)
                vpv(result[i], M[i], v);
    }
    /** add v to every row of M. */
    public static void mpv(double result[][], double M[][], double v[])
    {
        for (int i = (M.length)-1; (i) >= 0; --i)
            if (M[i] != null)
                vpv(result[i], M[i], v);
    }
    /** add v to every row of M. */
    public static void mpv(int result[][], int M[][], int v[])
    {
        for (int i = (M.length)-1; (i) >= 0; --i)
            if (M[i] != null)
                vpv(result[i], M[i], v);
    }

    // XXX this hasn't been tested
    /** add v to every row of M. M can be double[][], or double[][][], ... */
    public static void vpm(Object result, double v[], Object m)
    {
        Object resultFlat = Arrays.flatten(result, 0, Arrays.getDim(result)-1);
        Object mFlat = Arrays.flatten(result, 0, Arrays.getDim(result)-1);
        if (resultFlat instanceof double[][])
            vpm((double[][])resultFlat, v, (double[][])mFlat);
        else if (resultFlat instanceof int[][])
            vpm((int[][])resultFlat, v, (int[][])mFlat);
        else
            do { if (!(false)) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+510 +"): " + "false" + ""); } while (false);
    }

    /** subtract v from every row of M */
    public static void mmv(int result[][], int M[][], int v[])
    {
        for (int i = (M.length)-1; (i) >= 0; --i)
            if (M[i] != null)
                vmv(result[i], M[i], v);
    }
    /** subtract v from every row of M */
    public static void mmv(double result[][], double M[][], double v[])
    {
        for (int i = (M.length)-1; (i) >= 0; --i)
            if (M[i] != null)
                vmv(result[i], M[i], v);
    }
    /** subtract v from every row of M. M can be double[][], or double[][][], ... */
    public static void mmv(Object result, Object m, double v[])
    {
        double resultFlat[][] = (double[][])Arrays.flatten(result, 0, Arrays.getDim(result)-1);
        double mFlat[][] = (double[][])Arrays.flatten(m, 0, Arrays.getDim(m)-1);
        mmv(resultFlat, mFlat, v);
    }

    /** ||B||^2 ||C||^2 - (B dot C )^2   where B=b-a, C=c-a
    * But that's prone to catastrophic cancellation,
    * so use this instead:
    *     ||B - (B dot C)/(||C||^2) C ||^2  ||C||^2
    */
    public static double sqrdTwiceTriangleArea(double a[],
                                               double b[],
                                               double c[])
    {
        if (false) // catastrophic cancellation way
        {
            double ab_dot_ab = 0.;
            double ab_dot_ac = 0.;
            double ac_dot_ac = 0.;
            for (int i = (a.length)-1; (i) >= 0; --i)
            {
                double ai = a[i];
                double ab = b[i] - ai;
                double ac = c[i] - ai;
                ab_dot_ab += ab*ab;
                ab_dot_ac += ab*ac;
                ac_dot_ac += ac*ac;
            }
            return ab_dot_ab*ac_dot_ac - ((ab_dot_ac)*(ab_dot_ac));
        }
        else if (false)
        {
            // simple robust way, allocates temporaries
            double B[] = vmv(b,a);
            double C[] = vmv(c,a);
            // orthonormalize B against C...
            double normsqrdC = normsqrd(C);
            if (normsqrdC == 0.)
                return 0.;
            vpsxv(B, B, -dot(B,C)/normsqrdC, C); // B -= (B dot C)/normsqrd(C) * C
            return normsqrd(B)*normsqrdC;
        }
        else
        {
            // previous robust method, but without temporaries...
            // two passes instead
            double BdotC = 0.;
            double CdotC = 0.;
            for (int i = (a.length)-1; (i) >= 0; --i)
            {
                double ai = a[i];
                double Ci = b[i] - ai;
                double Bi = c[i] - ai;
                BdotC += Bi*Ci;
                CdotC += Ci*Ci;
            }
            if (CdotC == 0.)
                return 0.;
            double scale = BdotC/CdotC; // XXX maybe should swap B,C if necessary so that C is the larger of the two? not sure
            double BdotB = 0.; // actually not B, but B orthogonalized against C
            for (int i = (a.length)-1; (i) >= 0; --i)
            {
                double ai = a[i];
                double Ci = b[i] - ai;
                double Bi = c[i] - ai;
                Bi -= scale * Ci;
                BdotB += Bi*Bi;
            }
            return BdotB * CdotC;
        }

    } // sqrdTwiceTriangleArea



    /** linear interpolation between vectors */
    public static void lerp(int n, double result[], double p0[], double p1[], double t)
    {
        for (int i = (n)-1; (i) >= 0; --i)
            result[i] = (1.-t)*p0[i] + t*p1[i];
    }
    /** linear interpolation between vectors */
    public static void lerp(double result[], double p0[], double p1[], double t)
    {
        lerp(p0.length, result, p0, p1, t);
    }
    /** linear interpolation between vectors */
    public static void lerp(int n, float result[], float p0[], float p1[], float t)
    {
        for (int i = (n)-1; (i) >= 0; --i)
            result[i] = (1.f-t)*p0[i] + t*p1[i];
    }
    /** linear interpolation between vectors */
    public static void lerp(float result[], float p0[], float p1[], float t)
    {
        lerp(p0.length, result, p0, p1, t);
    }

    /** barycentric interpolation between vectors */
    public static void bary(double result[],
                            double p0[],
                            double p1[], double t1,
                            double p2[], double t2)
    {
        for (int i = (p0.length)-1; (i) >= 0; --i)
            result[i] = (1.-t1-t2)*p0[i] + t1*p1[i] + t2*p2[i];
    }
    /** cubic interpolation, given boundary positions and velocities */
    public static void cerp(double result[],
                            double p0[], double p1[],
                            double v0[], double v1[],
                            double t)
    {
        /*
           We want a matrix M defining:
                p(t) = [1 t t^2 t^3] * M * [   p0   ]
                                           [   p1   ]
                                           [   v0   ]
                                           [   v1   ]
          
                v(t) = [0 1 2t 3t^2] * M * [   p0   ]
                                           [   p1   ]
                                           [   v0   ]
                                           [   v1   ]
           Satisfying boundary conditions:
                p(t0) = p0
                p(t1) = p1
                v(t0) = v0
                v(t1) = v1
           In other words,
                    [   p0   ] = [1 t0    t0^2    t0^3] * M * [   p0   ]
                    [   p1   ]   [1 t1    t1^2    t1^3]       [   p1   ]
                    [   v0   ]   [0 1   2 t0    3 t0^2]       [   v0   ]
                    [   v1   ]   [0 1   2 t1    3 t1^2]       [   v1   ]
           So M is the inverse of that matrix of T's.
           In particular, we have t0=0 and t1=1,
           so M is simply the inverse of:
                    [1 0 0 0]
                    [1 1 1 1]
                    [0 1 0 0]
                    [0 1 2 3]
           which is, according to octave,
               octave:1> inv([1 0 0 0 ; 1 1 1 1 ; 0 1 0 0 ; 0 1 2 3])
                  M = [  1   0   0   0 ]
                      [  0   0   1   0 ]
                      [ -3   3  -2  -1 ]
                      [  2  -2   1   1 ]
           So, given t,
           the the coefficient matrix for p0,p1,v0,v1
           is then [1 t t^2 t^3] * M.
        */

        double t2 = t*t;
        double coeff_p0 = (2*t - 3)*t2 + 1;
        double coeff_p1 = (-2*t + 3)*t2;
        double coeff_v0 = ((t - 2)*t + 1)*t;
        double coeff_v1 = (t - 1)*t2;

        if (false) // linear
        {
            coeff_p0 = (1-t);
            coeff_p1 = t;
            coeff_v0 = 0;
            coeff_v1 = 0;
        }

        sxv(result, coeff_p0, p0);
        vpsxv(result, result, coeff_p1, p1);
        vpsxv(result, result, coeff_v0, v0);
        vpsxv(result, result, coeff_v1, v1);
    } // cerp

    /**
     * quintic interpolation, given boundary positions, velocities, and
     * accelerations.
     */
    public static void interp5(double result[],
                               double p0[], double p1[],
                               double v0[], double v1[],
                               double a0[], double a1[],
                               double t)
    {
        /*
           Same logic as for cerp.
           M is the inverse of:
                [1  0  0  0  0  0]
                [1  1  1  1  1  1]
                [0  1  0  0  0  0]
                [0  1  2  3  4  5]
                [0  0  2  0  0  0]
                [0  0  2  6 12 20]
           So M is:
                [  1   0  0  0  0    0]
                [  0   0  1  0  0    0]
                [  0   0  0  0  .5    0]
                [-10  10 -6 -4 -1.5 .5]
                [ 15 -15  8  7  1.5 -1]
                [ -6   6 -3 -3  -.5 .5]
        */
        // XXX inefficient
        double t2 = t*t, t3 = t2*t, t4 = t3*t, t5 = t4*t;
        double tVec[] = {1,t,t2,t3,t4,t5};
        final double M[][] = {
                { 1, 0, 0, 0, 0 , 0},
                { 0, 0, 1, 0, 0 , 0},
                { 0, 0, 0, 0, .5 , 0},
                {-10, 10, -6, -4, -1.5, .5},
                { 15, -15, 8, 7, 1.5, -1},
                { -6, 6, -3, -3, -.5 , .5},
        };
        double pva[][] = {p0,p1,v0,v1,a0,a1};
        // result = tVec * M * pva
        // do it from left to right, to avoid full matrix multiply
        double coeffs[] = vxm(tVec, M); // XXX more allocation-- argh!
        vxm(result, coeffs, pva);
/*
PRINTMAT(M);
// make sure t=0 gives out p0 and t=1 give out p1...
PRINTVEC(p0);
PRINTVEC(vxmxm(new double[]{1,0,0,0,0,0},M,pva));
PRINTVEC(p1);
PRINTVEC(vxmxm(new double[]{1,1,1,1,1,1},M,pva));
*/
/*
PRINTMAT(M);
PRINTVEC(v0);
PRINTVEC(vxmxm(new double[]{0,1,0,0,0,0},M,pva));
PRINTVEC(v1);
PRINTVEC(vxmxm(new double[]{0,1,2,3,4,5},M,pva));
*/

        // XXX also, for fixed t, tVec*M is same for all pva; could precompute
        // XXX note, M*pva is same for all t on path; could precompute.
    } // interp5

    /** Helper function.  Orthonormalizes b against a.  CBB: surely there's something more basic to base this on? */
    public static void orthogonalize1(double answer[],
                                      double a[],
                                      double b[])
    {
        copyvec(answer, b);
        double scratch[][] = {copyvec(a), answer};
        extendAndOrthogonalize(2, 2, scratch, scratch);
    }

    /** Minimize the weighted sum of squares of geodesic distances to given points on sphere.,
    * as described in http://math.ucsd.edu/~sbuss/ResearchWeb/spheremean/paper.pdf p.23.
    * Weights are required to sum to nonzero; they get effectively normalized to sum to 1.
    * NOTE: not stable unless points are all well within some hemisphere.
    * NOTE: seems to be unstable if any weights are allowed to be negative.
    */
    public static void sphericalAverage(double answer[],
                                        double points[][],
                                        double weights[])
    {
        int verboseLevel = 0;
        if (verboseLevel >= 1) System.out.println("                in sphericalAverage");
        // Algorithm A1 from the paper; the linearly converging one.
        int d = answer.length;
        do { if (!(d >= 2)) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+789 +"): " + "d >= 2" + ""); } while (false); // doesn't make sense otherwise
        int n = points.length;
        do { if (!((n)==(weights.length))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+791 +"): (" + "n" + ")" + "==" + "(" + "weights.length" + ") ("+(n)+" vs. "+(weights.length)+")"); } while (false);

        double weightsSum = sum(weights);
        do { if (!(weightsSum > 0.)) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+794 +"): " + "weightsSum > 0." + ""); } while (false);

        double q[] = answer; // work in answer, but call it q
        vxm(q, weights, points);
        normalize(q, q); // TODO: this will fail miserably if all points are coplanar!! shouldn't we take some kind of cross products instead? or sum of cross products?  not sure.
        double projectedPoints[][] = new double[n][d]; // scratch for loop
        double u[] = new double[d]; // scratch for loop
        double prevULength = Double.POSITIVE_INFINITY;
        while (true)
        {
            if (verboseLevel >= 2) System.out.println("                  top of loop");
            if (verboseLevel >= 2) System.out.println("                      q = "+toString(q));
            for (int i = 0; (i) < (n); ++i)
            {
                double ang = angleBetweenUnitVectors(q, points[i]);
                orthogonalize1(projectedPoints[i], q, points[i]);
                vxs(projectedPoints[i], projectedPoints[i], ang);
            }
            vxm(u, weights, projectedPoints);
            double uLength = norm(u);
            if (verboseLevel >= 2) System.out.println("                      uLength = "+uLength);
            if (uLength == 0.)
                break; // can't make any more progress

            if (uLength >= prevULength)
                break; // didn't improve

            double c = Math.cos(uLength);
            double s = Math.sin(uLength);
            // q = c*q + s*u/||u||
            sxvpsxv(q, c, q, s/uLength, u);
            // q should be unit length, but renormalize to be sure
            normalize(q, q);
            prevULength = uLength;
        }
        // q is answer
        if (verboseLevel >= 1) System.out.println("                out sphericalAverage");
    } // sphericalAverage

    public static void getSphericalAverageWeights(double answer[],
                                                  double points[][],
                                                  double q[])
    {
        int verboseLevel = 0;
        if (verboseLevel >= 1) System.out.println("                in sphericalAverageWeights");
        // Project the points onto tangent plane at q,
        // and then find the barycentric coordinates.
        int d = answer.length;
        do { if (!(d >= 2)) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+842 +"): " + "d >= 2" + ""); } while (false); // doesn't make sense otherwise
        int n = points.length;
        double projectedPoints[][] = new double[n][d];
        for (int i = 0; (i) < (n); ++i)
        {
            if (verboseLevel >= 2) System.out.println("                  i = "+i);
            double ang = angleBetweenUnitVectors(q, points[i]);
            if (verboseLevel >= 2) System.out.println("                      ang = "+ang);
            orthogonalize1(projectedPoints[i], q, points[i]);
            vxs(projectedPoints[i], projectedPoints[i], ang);
            if (verboseLevel >= 2) System.out.println("                      points[i] = "+toString(points[i]));
            if (verboseLevel >= 2) System.out.println("                      projectedPoints[i] = "+toString(projectedPoints[i]));
        }
        if (verboseLevel >= 2) System.out.println("                      projectedPoints = "+toString(projectedPoints));
        // It seems we should be able to compute in the plane through the origin,
        // but it turns out we can't, since if we do it that way, we can't get the sign right.
        // So make it actually be the tangent plane.
        for (int i = 0; (i) < (n); ++i)
            vpv(projectedPoints[i], projectedPoints[i], q);
        double fullArea = orthotopeContent(projectedPoints.length, d, projectedPoints, false);

        for (int i = 0; (i) < (n); ++i)
        {
            double temp[] = projectedPoints[i];
            //projectedPoints[i] = zero;
            projectedPoints[i] = q;
            double partialArea = orthotopeContent(projectedPoints.length, d, projectedPoints, false);
            projectedPoints[i] = temp;
            answer[i] = partialArea / fullArea;
        }
        // weights should sum to 1 at this point, but make sure
        vxs(answer, answer, 1./sum(answer));
        if (verboseLevel >= 1) System.out.println("                out sphericalAverageWeights");
    } // getSphericalAverageWeights


    /** copy vector */ public static void copyvec( double result[], double v[]) { copyvec(((result.length)<=(v.length)?(result.length):(v.length)), result, v); }
    /** copy vector */ public static void copyvec( float result[], float v[]) { copyvec(((result.length)<=(v.length)?(result.length):(v.length)), result, v); }
    /** copy vector */ public static void copyvec( int result[], int v[]) { copyvec(((result.length)<=(v.length)?(result.length):(v.length)), result, v); }
    /** copy vector */ public static void copyvec(boolean result[], boolean v[]) { copyvec(((result.length)<=(v.length)?(result.length):(v.length)), result, v); }

    /** copy vector */ public static void copyvec(int n, double result[], double v[]) { for (int i = 0; (i) < (n); ++i) result[i] = v[i]; }
    /** copy vector */ public static void copyvec(int n, float result[], float v[]) { for (int i = 0; (i) < (n); ++i) result[i] = v[i]; }
    /** copy vector */ public static void copyvec(int n, int result[], int v[]) { for (int i = 0; (i) < (n); ++i) result[i] = v[i]; }
    /** copy vector */ public static void copyvec(int n, boolean result[], boolean v[]) { for (int i = 0; (i) < (n); ++i) result[i] = v[i]; }

    /** convert double vector to float vector */ public static void doubleToFloat(float result[], double v[]) { doubleToFloat(((result.length)<=(v.length)?(result.length):(v.length)), result, v); }
    /** convert float vector to double vector */ public static void floatToDouble(double result[], float v[]) { floatToDouble(((result.length)<=(v.length)?(result.length):(v.length)), result, v); }
    /** convert double vector to float vector */ public static void doubleToFloat(int n, float result[], double v[]) { for (int i = 0; (i) < (n); ++i) result[i] = (float)v[i]; }
    /** convert float vector to double vector */ public static void floatToDouble(int n, double result[], float v[]) { for (int i = 0; (i) < (n); ++i) result[i] = (double)v[i]; }

    /** convert int vector to double vector */ public static double[] intToDouble(int v[]) { double[] result = new double[v.length]; intToDouble(v.length, result, v); return result;}
    /** convert int vector to double vector */ public static void intToDouble(double result[], int v[]) { intToDouble(((result.length)<=(v.length)?(result.length):(v.length)), result, v); }
    /** convert int vector to double vector */ public static void intToDouble(int n, double result[], int v[]) { for (int i = 0; (i) < (n); ++i) result[i] = (double)v[i]; }

    /** set column of a matrix */
    public static void setcolumn(double M[][], int iCol, double v[])
    {
        for (int iRow = (((M.length)<=(v.length)?(M.length):(v.length)))-1; (iRow) >= 0; --iRow)
            M[iRow][iCol] = v[iRow];
    }

    /** get column of a matrix */
    public static void getcolumn(double v[], double M[][], int iCol)
    {
        for (int iRow = (((v.length)<=(M.length)?(v.length):(M.length)))-1; (iRow) >= 0; --iRow)
            v[iRow] = M[iRow][iCol];
    }

    /** fill vector with a constant scalar */
    public static void fillvec(double result[], double s)
    {
        for (int i = (result.length)-1; (i) >= 0; --i)
            result[i] = s;
    }

    /** fill vector with a constant scalar */
    public static void fillvec(int result[], int s)
    {
        for (int i = (result.length)-1; (i) >= 0; --i)
            result[i] = s;
    }

    /** fill vector with a constant scalar */
    public static void fillvec(boolean result[], boolean s)
    {
        for (int i = (result.length)-1; (i) >= 0; --i)
            result[i] = s;
    }

    /** fill matrix with a constant scalar */
    public static void fillmat(double result[][], double s)
    {
        for (int i = (result.length)-1; (i) >= 0; --i)
            fillvec(result[i], s);
    }

    /** fill matrix with a constant scalar */
    public static void fillmat(int result[][], int s)
    {
        for (int i = (result.length)-1; (i) >= 0; --i)
            fillvec(result[i], s);
    }

    /** fill matrix with a constant scalar */
    public static void fillmat(boolean result[][], boolean s)
    {
        for (int i = (result.length)-1; (i) >= 0; --i)
            fillvec(result[i], s);
    }

    /** copy first nCols entries of first nRows rows of m into result*/
    public static void copymat(int nRows, int nCols, double result[][], double m[][])
    {
        for (int i = (nRows)-1; (i) >= 0; --i)
            for (int j = (nCols)-1; (j) >= 0; --j)
                result[i][j] = m[i][j];
    }
    /** copy first nCols entries of first nRows rows of m into result*/
    public static void copymat(int nRows, int nCols, float result[][], float m[][])
    {
        for (int i = (nRows)-1; (i) >= 0; --i)
            for (int j = (nCols)-1; (j) >= 0; --j)
                result[i][j] = m[i][j];
    }
    /** copy first nCols entries of first nRows rows of m into result*/
    public static void copymat(int nRows, int nCols, int result[][], int m[][])
    {
        for (int i = (nRows)-1; (i) >= 0; --i)
            for (int j = (nCols)-1; (j) >= 0; --j)
                result[i][j] = m[i][j];
    }
    /** copy first k rows of m into result */
    public static void copymat(int k, double result[][], double m[][])
    {
        for (int i = (k)-1; (i) >= 0; --i)
            for (int j = (((result[i].length)<=(m[i].length)?(result[i].length):(m[i].length)))-1; (j) >= 0; --j)
                result[i][j] = m[i][j];
    }
    /** copy first k rows of m into result */
    public static void copymat(int k, float result[][], float m[][])
    {
        for (int i = (k)-1; (i) >= 0; --i)
            for (int j = (((result[i].length)<=(m[i].length)?(result[i].length):(m[i].length)))-1; (j) >= 0; --j)
                result[i][j] = m[i][j];
    }

    /** copy m into result, up to smaller of thw two numbers of rows*/
    public static void copymat(double result[][], double m[][])
    {
        copymat(((result.length)<=(m.length)?(result.length):(m.length)), result, m);
    }
    /** copy m into result, up to smaller of thw two numbers of rows*/
    public static void copymat(float result[][], float m[][])
    {
        copymat(((result.length)<=(m.length)?(result.length):(m.length)), result, m);
    }

    /** zero a vector */
    public static void zerovec(int n, double result[])
    {
        for (int i = 0; (i) < (n); ++i)
            result[i] = (double)0;
    }
    /** zero a vector */
    public static void zerovec(int n, float result[])
    {
        for (int i = 0; (i) < (n); ++i)
            result[i] = (float)0;
    }
    /** zero a vector */
    public static void zerovec(int n, int result[])
    {
        for (int i = 0; (i) < (n); ++i)
            result[i] = 0;
    }

    /** zero a vector */
    public static void zerovec(double result[])
    {
        for (int i = (result.length)-1; (i) >= 0; --i)
            result[i] = (double)0;
    }
    /** zero a vector */
    public static void zerovec(float result[])
    {
        for (int i = (result.length)-1; (i) >= 0; --i)
            result[i] = (float)0;
    }
    /** zero a vector */
    public static void zerovec(int result[])
    {
        for (int i = (result.length)-1; (i) >= 0; --i)
            result[i] = 0;
    }
    /** zero a matrix */
    public static void zeromat(double result[][])
    {
        for (int i = (result.length)-1; (i) >= 0; --i)
            zerovec(result[i]);
    }

    /** vector dot product */
    public static double dot(int n, double v0[], double v1[])
    {
        double result = (double)0;
        for (int i = (n)-1; (i) >= 0; --i)
            result += v0[i]*v1[i];
        return result;
    }
    /** vector dot product */
    public static double dot(double v0[], double v1[])
    {
        return dot(v0.length, v0, v1);
    }

    /** dot product of vector with matrix column */
    public static double dotcol(int n, double v[], double M[][], int iCol)
    {
        double result = (double)0;
        for (int i = (n)-1; (i) >= 0; --i)
            result += v[i]*M[i][iCol];
        return result;
    }
    /** dot product of vector with matrix column */
    public static double dotcol(double v[], double M[][], int iCol)
    {
        return dotcol(v.length, v, M, iCol);
    }


    /** vector dot product */
    public static float dot(int n, float v0[], float v1[])
    {
        float result = (float)0;
        for (int i = (n)-1; (i) >= 0; --i)
            result += v0[i]*v1[i];
        return result;
    }
    /** vector dot product */
    public static float dot(float v0[], float v1[])
    {
        return dot(v0.length, v0, v1);
    }

    /** dot product of vector with matrix column */
    public static float dotcol(int n, float v[], float M[][], int iCol)
    {
        float result = (float)0;
        for (int i = (n)-1; (i) >= 0; --i)
            result += v[i]*M[i][iCol];
        return result;
    }
    /** dot product of vector with matrix column */
    public static float dotcol(float v[], float M[][], int iCol)
    {
        return dotcol(v.length, v, M, iCol);
    }

    /** vector times transpose of matrix */
    public static void vxtransposem(double result[], double v[], double m[][])
    {
        do { if (!((result.length)==(m.length))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+1104 +"): (" + "result.length" + ")" + "==" + "(" + "m.length" + ") ("+(result.length)+" vs. "+(m.length)+")"); } while (false);
        for (int iCol = (result.length)-1; (iCol) >= 0; --iCol)
        {
            do { if (!((v.length)==(m[iCol].length))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+1107 +"): (" + "v.length" + ")" + "==" + "(" + "m[iCol].length" + ") ("+(v.length)+" vs. "+(m[iCol].length)+")"); } while (false);
            result[iCol] = dot(v, m[iCol]);
        }
    }

    /** matrix times transpose of matrix */
    public static void mxtransposem(double result[][], double m0[][], double m1[][])
    {
        do { if (!(result != m0 && result != m1)) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+1115 +"): " + "result != m0 && result != m1" + ""); } while (false);
        do { if (!((result.length)==(m0.length))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+1116 +"): (" + "result.length" + ")" + "==" + "(" + "m0.length" + ") ("+(result.length)+" vs. "+(m0.length)+")"); } while (false);
        for (int iRow = (result.length)-1; (iRow) >= 0; --iRow)
            vxtransposem(result[iRow], m0[iRow], m1);
    }

    /** matrix times transpose of matrix */
    public static double[][] mxtransposem(double m0[][], double m1[][])
    {
        double result[][] = new double[m0.length][m1.length];
        mxtransposem(result, m0, m1);
        return result;
    }

    // XXX duplicate code below
    /** row vector times matrix */
    public static void vxm(double result[], double v[], double m[][])
    {
        do { if (!(result != v)) throw new Error("Assumption failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+1133 +"): " + "result != v" + ""); } while (false);
        zerovec(result);
        int i, vLen = v.length;
        for (i = 0; (i) < (vLen); ++i)
            vpsxv(result, result, v[i], m[i]);
        // if v is short, pretend it's padded with 1's
        for (; i < m.length; ++i)
            vpv(result, result, m[i]);
    } // vxm double

    // XXX duplicate code above and below
    /** row vector times matrix */
    public static void vxm(float result[], float v[], float m[][])
    {
        do { if (!(result != v)) throw new Error("Assumption failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+1147 +"): " + "result != v" + ""); } while (false);
        int vLen = v.length;
        zerovec(result);
        int i, j;
        for (i = 0; (i) < (vLen); ++i)
            vpsxv(result, result, v[i], m[i]);
        // if v is short, pretend it's padded with 1's
        for (; i < m.length; ++i)
            vpv(result, result, m[i]);
    } // vxm float

    // XXX duplicate code above
    /** row vector times matrix */
    public static void vxm(int result[], int v[], int m[][])
    {
        do { if (!(result != v)) throw new Error("Assumption failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+1162 +"): " + "result != v" + ""); } while (false);
        int vLen = v.length;
        zerovec(result);
        int i, j;
        for (i = 0; (i) < (vLen); ++i)
            vpsxv(result, result, v[i], m[i]);
        // if v is short, pretend it's padded with 1's
        for (; i < m.length; ++i)
            vpv(result, result, m[i]);
    } // vxm int

    // XXX BLEAH! I have a fundamental contradiction here...
    // XXX I'm trying to overload mxm so that it can mean
    // XXX vectors-times-xform
    // XXX or xform-times-xform!
    // XXX Say we are multiplying 4x3 times 4x3;
    // XXX in the former case we pad the left one with 1 1 1 1;
    // XXX in the latter case we pad the left one with 0 0 0 1 !!!
    // XXX Need two separate functions!
    /** matrix times matrix */
    public static void mxm(double result[/*n*/][/*m*/],
                           double m0[/*n*/][/*dotLength*/],
                           double m1[/*dotLength*/][/*m*/])
    {


        if (m0.length == 0 || ((m0).length==0 ? 0 : (m0)[0].length) == m1.length)
        {
            do { if (!(result != m0 && result != m1)) throw new Error("Assumption failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+1190 +"): " + "result != m0 && result != m1" + ""); } while (false);
            for (int i = (result.length)-1; (i) >= 0; --i) // == m0.length
                vxm(result[i], m0[i], m1);
        }
        else
        {
            // XXX hack-- fix it up reasonably when I'm awake

            if ((m0.length == m0[0].length || m0.length == m0[0].length+1)
             && m1.length == m0[0].length+1
             && m1[0].length == m0[0].length
             && result.length == m0[0].length+1
             && result[0].length == m0[0].length)
            {
                // pad it out with 0's on the sides and 1 in the corner
                double M0[][] = identitymat(m1.length);
                for (int i = (m0.length)-1; (i) >= 0; --i)
                for (int j = (m0[i].length)-1; (j) >= 0; --j)
                    M0[i][j] = m0[i][j];
                mxm(result, M0, m1);
            }
            else
            {
             {System.out.print("        "); System.out.println("m0.length" + " = " + (m0.length));};
             {System.out.print("        "); System.out.println("((m0).length==0 ? 0 : (m0)[0].length)" + " = " + (((m0).length==0 ? 0 : (m0)[0].length)));};
             {System.out.print("        "); System.out.println("m1.length" + " = " + (m1.length));};
             {System.out.print("        "); System.out.println("((m1).length==0 ? 0 : (m1)[0].length)" + " = " + (((m1).length==0 ? 0 : (m1)[0].length)));};
             {System.out.print("        "); System.out.println("(m0.length == m0[0].length || m0.length == m0[0].length+1)" + " = " + ((m0.length == m0[0].length || m0.length == m0[0].length+1)));};
             {System.out.print("        "); System.out.println("m1.length == m0[0].length+1" + " = " + (m1.length == m0[0].length+1));};
             {System.out.print("        "); System.out.println("m1[0].length == m0[0].length" + " = " + (m1[0].length == m0[0].length));};
             {System.out.print("        "); System.out.println("result.length == m0[0].length+1" + " = " + (result.length == m0[0].length+1));};
             {System.out.print("        "); System.out.println("result[0].length == m0[0].length" + " = " + (result[0].length == m0[0].length));};
                do { if (!(false)) throw new Error("Assumption failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+1222 +"): " + "false" + ""); } while (false);
            }
        }
// 1341 # 1235 "com/donhatchsw/util/VecMath.prejava"
    } // mxm

    // XXX duplicate code above
    /** matrix times matrix */
    public static void mxm(float result[/*n*/][/*m*/],
                           float m0[/*n*/][/*dotLength*/],
                           float m1[/*dotLength*/][/*m*/])
    {
        do { if (!(result != m0 && result != m1)) throw new Error("Assumption failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+1243 +"): " + "result != m0 && result != m1" + ""); } while (false);
        for (int i = (result.length)-1; (i) >= 0; --i) // == m0.length
            vxm(result[i], m0[i], m1);
    } // mxm

    // XXX duplicate code above
    /** matrix times matrix */
    public static void mxm(int result[/*n*/][/*m*/],
                           int m0[/*n*/][/*dotLength*/],
                           int m1[/*dotLength*/][/*m*/])
    {
        do { if (!(result != m0 && result != m1)) throw new Error("Assumption failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+1254 +"): " + "result != m0 && result != m1" + ""); } while (false);
        for (int i = (result.length)-1; (i) >= 0; --i) // == m0.length
            vxm(result[i], m0[i], m1);
    } // mxm

    // XXX duplicate code below
    /** matrix times column vector */
    public static void mxv(double result[], double m[][], double v[])
    {
        do { if (!(result != v)) throw new Error("Assumption failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+1263 +"): " + "result != v" + ""); } while (false);
        int nRows = m.length;
        if (nRows == 0)
            return;
        int nCols = m[0].length;
        do { if (!(v.length <= nCols)) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+1268 +"): " + "v.length <= nCols" + ""); } while (false);
        int i, j;
        for (i = 0; (i) < (result.length); ++i)
        {
            double m_i[] = m[i];
            double sum = (double)0;
            for (j = 0; (j) < (v.length); ++j)
            {
                sum += m_i[j] * v[j];
            }
            // if v is short, pretend it's padded with 1's
            for (; j < nCols; ++j)
            {
                sum += m_i[j];
            }
            result[i] = sum;
        }
    }
    // XXX duplicate code below and above
    /** matrix times column vector */
    public static void mxv(float result[], float m[][], float v[])
    {
        do { if (!(result != v)) throw new Error("Assumption failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+1290 +"): " + "result != v" + ""); } while (false);
        int nRows = m.length;
        if (nRows == 0)
            return;
        int nCols = m[0].length;
        do { if (!(v.length <= nCols)) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+1295 +"): " + "v.length <= nCols" + ""); } while (false);
        int i, j;
        for (i = 0; (i) < (nRows); ++i)
        {
            float m_i[] = m[i];
            float sum = (float)0;
            for (j = 0; (j) < (v.length); ++j)
            {
                sum += m_i[j] * v[j];
            }
            // if v is short, pretend it's padded with 1's
            for (; j < nCols; ++j)
            {
                sum += m_i[j];
            }
            result[i] = sum;
        }
    }
    // XXX duplicate code above
    /** matrix times column vector */
    public static void mxv(int result[], int m[][], int v[])
    {
        do { if (!(result != v)) throw new Error("Assumption failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+1317 +"): " + "result != v" + ""); } while (false);
        int nRows = m.length;
        if (nRows == 0)
            return;
        int nCols = m[0].length;
        do { if (!(v.length <= nCols)) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+1322 +"): " + "v.length <= nCols" + ""); } while (false);
        int i, j;
        for (i = 0; (i) < (nRows); ++i)
        {
            int m_i[] = m[i];
            int sum = /*(int)*/0;
            for (j = 0; (j) < (v.length); ++j)
            {
                sum += m_i[j] * v[j];
            }
            // if v is short, pretend it's padded with 1's
            for (; j < nCols; ++j)
            {
                sum += m_i[j];
            }
            result[i] = sum;
        }
    }

    private static void twoNormallyDistributedRandomNumbers(double result[/*2*/])
    {
        double r0, r1, r;
        do {
            r0 = 2.*Math.random() - 1.;
            r1 = 2.*Math.random() - 1.;
            r = r0*r0 + r1*r1;
        } while (r > 1. || r == 0.);
        r = Math.sqrt(-2*Math.log(r)/r);
        r0 *= r;
        r1 *= r;
        result[0] = r0;
        result[1] = r1;
    } // private twoNormallyDistributedRandomNumbers

    /** return a random vector with length <= 1. XXX currently broken */
    /* XXX this can take forever if v.length is big! like, > 7 */
    public static void random(double v[])
    {
        if (false) // really slow way if n >= 7 or so...
        {
            do
                for (int i = (v.length)-1; (i) >= 0; --i)
                    v[i] = (2.*Math.random() - 1.);
            while (normsqrd(v) > 1);
        }
        else
        {
            // From Bob Jenkins who got the idea from Steve Rayhawk...
            // http://burtleburtle.net/bob/rand/unitvec.html
            // XXX WOOPS! this gives a random vector *on* the sphere,
            // not inside it!
            double twoNormalRandoms[] = new double[2];
            for (int i = 0; (i) < (v.length); ++i)
            {
                int which = i%2;
                if (which == 0)
                    twoNormallyDistributedRandomNumbers(twoNormalRandoms);
                v[i] = twoNormalRandoms[which];
            }
            // XXX okay we are screwed... at this point,
            // XXX do we just return a unit vector?
            // XXX or return something with uniformly distributed
            // XXX angle but gaussian magnitude?
            if (false)
            {
                // unit vector
                normalize(v, v);
            }
            else
            {
                // gaussian magnitude-- do nothing
            }
        }
    }
    /** return a random vector with length <= 1. XXX currently broken */
    public static void random(double v[], java.util.Random generator)
    {
        do
            for (int i = (v.length)-1; (i) >= 0; --i)
                v[i] = (2.*generator.nextDouble() - 1.);
        while (normsqrd(v) > 1);
    }

    /** vector distance squared */
    public static double distsqrd(int n, double v0[], double v1[])
    {
        double result = (float)0;
        for (int i = 0; (i) < (n); ++i)
        {
            double diff = v1[i]-v0[i];
            result += diff*diff;
        }
        return result;
    }
    /** vector distance squared */
    public static float distsqrd(int n, float v0[], float v1[])
    {
        float result = (float)0;
        for (int i = 0; (i) < (n); ++i)
        {
            float diff = v1[i]-v0[i];
            result += diff*diff;
        }
        return result;
    }
    /** vector distance squared */
    public static int distsqrd(int n, int v0[], int v1[])
    {
        int result = /*(int)*/0;
        for (int i = 0; (i) < (n); ++i)
        {
            int diff = v1[i]-v0[i];
            result += diff*diff;
        }
        return result;
    }
    /** vector distance squared */
    public static double distsqrd(double v0[], double v1[])
    {
        int n = v0.length; // == v1.length
        return distsqrd(n, v0, v1);
    }
    /** vector distance squared */
    public static float distsqrd(float v0[], float v1[])
    {
        int n = v0.length; // == v1.length
        return distsqrd(n, v0, v1);
    }
    /** vector distance squared */
    public static int distsqrd(int v0[], int v1[])
    {
        int n = v0.length; // == v1.length
        return distsqrd(n, v0, v1);
    }

    /** vector distance */
    public static double dist(int n, double v0[], double v1[])
    {
        return Math.sqrt(distsqrd(n, v0, v1));
    }
    /** vector distance */
    public static double dist(double v0[], double v1[])
    {
        return Math.sqrt(distsqrd(v0, v1));
    }
    /** vector distance */
    public static float dist(int n, float v0[], float v1[])
    {
        return (float)Math.sqrt(distsqrd(n, v0, v1));
    }
    /** vector distance */
    public static float dist(float v0[], float v1[])
    {
        return (float)Math.sqrt(distsqrd(v0, v1));
    }

    /** vector norm (length) squared */
    public static double normsqrd(int n, double v[])
    {
        return dot(n, v,v);
    }
    public static double normsqrd(double v[])
    {
        return dot(v,v);
    }
    /** vector norm (length) squared */
    public static float normsqrd(int n, float v[])
    {
        return dot(n, v,v);
    }
    /** vector norm (length) squared */
    public static float normsqrd(float v[])
    {
        return dot(v,v);
    }
    /** vector norm (length) */
    public static double norm(int n, double v[])
    {
        return Math.sqrt(dot(n, v,v));
    }
    /** vector norm (length) */
    public static double norm(double v[])
    {
        return Math.sqrt(dot(v,v));
    }
    /** vector norm (length) */
    public static float norm(int n, float v[])
    {
        return (float)Math.sqrt(dot(n, v,v)); // XXX is there a sqrtf?
    }
    /** vector norm (length) */
    public static float norm(float v[])
    {
        return (float)Math.sqrt(dot(v,v)); // XXX is there a sqrtf?
    }

    /** returns index of least magnitude element */
    public static int minabsi(double v[])
    {
        int mini = -1;
        double min = Double.POSITIVE_INFINITY;
        for (int i = 0; (i) < (v.length); ++i) // not FORIDOWN, so smallest index will be chosen
        {
            double thisabs = ((v[i]) < 0 ? -(v[i]) : (v[i]));
            if (thisabs < min)
            {
                min = thisabs;
                mini = i;
            }
        }
        return mini;
    }
    /** returns index of least element */
    public static int mini(double v[])
    {
        int mini = -1;
        double min = Double.POSITIVE_INFINITY;
        for (int i = 0; (i) < (v.length); ++i) // not FORIDOWN, so smallest index will be chosen
        {
            if (v[i] < min)
            {
                min = v[i];
                mini = i;
            }
        }
        return mini;
    }
    /** returns index of greatest magnitude element */
    public static int maxabsi(double v[])
    {
        int maxi = -1;
        double max = Double.NEGATIVE_INFINITY;
        for (int i = 0; (i) < (v.length); ++i) // not FORIDOWN, so smallest index will be chosen
        {
            double thisabs = ((v[i]) < 0 ? -(v[i]) : (v[i]));
            if (thisabs > max)
            {
                max = thisabs;
                maxi = i;
            }
        }
        return maxi;
    }
    /** returns index of greatest element */
    public static int maxi(double v[])
    {
        int maxi = -1;
        double max = Double.NEGATIVE_INFINITY;
        for (int i = 0; (i) < (v.length); ++i) // not FORIDOWN, so smallest index will be chosen
        {
            if (v[i] > max)
            {
                max = v[i];
                maxi = i;
            }
        }
        return maxi;
    }

    /** returns index of least element */
    public static int mini(int v[])
    {
        if (v.length == 0) return -1;
        int min = v[0];
        int mini = 0;
        for (int i = 1; i < v.length; ++i)
        {
            if (v[i] < min)
            {
                min = v[i];
                mini = i;
            }
        }
        return mini;
    }
    /** returns index of greatest element */
    public static int maxi(int v[])
    {
        if (v.length == 0) return -1;
        int max = v[0];
        int maxi = 0;
        for (int i = 1; i < v.length; ++i)
        {
            if (v[i] > max)
            {
                max = v[i];
                maxi = i;
            }
        }
        return maxi;
    }

    /** returns minimum element */
    public static double min(int n, double v[])
    {
        double min = Double.POSITIVE_INFINITY;
        for (int i = 0; (i) < (n); ++i)
            min = Math.min(min, v[i]);
        return min;
    }
    /** returns minimum element */
    public static int min(int n, int v[])
    {
        int min = Integer.MAX_VALUE;
        for (int i = 0; (i) < (n); ++i)
            min = Math.min(min, v[i]);
        return min;
    }
    /** returns maximum element */
    public static double max(int n, double v[])
    {
        double max = Double.NEGATIVE_INFINITY;
        for (int i = 0; (i) < (n); ++i)
            max = Math.max(max, v[i]);
        return max;
    }
    /** returns maximum element */
    public static int max(int n, int v[])
    {
        int max = Integer.MIN_VALUE;
        for (int i = 0; (i) < (n); ++i)
            max = Math.max(max, v[i]);
        return max;
    }

    /** returns minimum element */
    public static double min(double v[])
    {
        return min(v.length, v);
    }
    /** returns minimum element */
    public static int min(int v[])
    {
        return min(v.length, v);
    }
    /** returns maximum element */
    public static double max(double v[])
    {
        return max(v.length, v);
    }
    /** returns maximum element */
    public static int max(int v[])
    {
        return max(v.length, v);
    }

    /** sum of elements */
    public static int sum(int v[])
    {
        int sum = 0;
        for (int i = (v.length)-1; (i) >= 0; --i)
            sum += v[i];
        return sum;
    }
    /** sum of elements */
    public static float sum(float v[])
    {
        float sum = 0.f;
        for (int i = (v.length)-1; (i) >= 0; --i)
            sum += v[i];
        return sum;
    }
    /** sum of elements */
    public static double sum(double v[])
    {
        double sum = 0.;
        for (int i = (v.length)-1; (i) >= 0; --i)
            sum += v[i];
        return sum;
    }
    /** average of elements */
    public static double average(double array[])
    {
        return sum(array) / array.length;
    }
    /** product of elements, not using log (fast) */
    public static double productNotUsingLog(double array[])
    {
        double product = 1.;
        for (int i = (array.length)-1; (i) >= 0; --i)
            product *= array[i];
        return product;
    }
    /** product of elements, using log to avoid over/underflow (slow) */
    public static double productUsingLog(double array[])
    {
        double logProd = 0.;
        for (int i = (array.length)-1; (i) >= 0; --i)
        {
            if (array[i] == 0.)
                return 0.;
            logProd += Math.log(array[i]);
        }
        return Math.exp(logProd);
    }
    /** geometric average of elements */
    public static double geomAverage(double array[])
    {
        double logProd = 0.;
        for (int i = (array.length)-1; (i) >= 0; --i)
        {
            if (array[i] == 0.)
                return 0.;
            logProd += Math.log(array[i]);
        }
        return Math.exp(logProd / array.length);
    }

    /** vector sum of vectors (array rows) */
    public static void sum(float result[], float array[][])
    {
        zerovec(result);
        for (int i = (array.length)-1; (i) >= 0; --i)
            vpv(result, result, array[i]);
    }
    /** vector sum of vectors (array rows) */
    public static void sum(double result[], double array[][])
    {
        zerovec(result);
        for (int i = (array.length)-1; (i) >= 0; --i)
            vpv(result, result, array[i]);
    }
    /** vector average of vectors (array rows) */
    public static void average(double result[], double array[][])
    {
        sum(result, array);
        vxs(result, result, 1./array.length);
    }
    /** vector sum of indexed list into array of vectors */
    public static void sumIndexed(double result[], int inds[], double array[][])
    {
        zerovec(result);
        for (int i = (inds.length)-1; (i) >= 0; --i)
            vpv(result, result, array[inds[i]]);
    }
    /** vector sum of indexed list into array of vectors */
    public static void sumIndexed(float result[], int inds[], float array[][])
    {
        zerovec(result);
        for (int i = (inds.length)-1; (i) >= 0; --i)
            vpv(result, result, array[inds[i]]);
    }
    /** vector average of indexed list into array of vectors */
    public static void averageIndexed(double result[], int inds[], double array[][])
    {
        sumIndexed(result, inds, array);
        vxs(result, result, (double)1/(double)inds.length);
    }
    /** vector average of indexed list into array of vectors */
    public static void averageIndexed(float result[], int inds[], float array[][])
    {
        sumIndexed(result, inds, array);
        vxs(result, result, (float)1/(float)inds.length);
    }
    /** vector average of two-dimensional indexed list into array of vectors */
    public static void averageIndexed(double result[], int inds[][], double array[][])
    {
        int totalInds = 0;
        zerovec(result);
        for (int i = (inds.length)-1; (i) >= 0; --i)
        {
            int row[] = inds[i];
            for (int j = (row.length)-1; (j) >= 0; --j)
            {
                vpv(result, result, array[row[j]]);
                totalInds++;
            }
        }
        vxs(result, result, (double)1/(double)totalInds);
    }
    /** vector average of two-dimensional indexed list into array of vectors */
    public static void averageIndexed(float result[], int inds[][], float array[][])
    {
        int totalInds = 0;
        zerovec(result);
        for (int i = (inds.length)-1; (i) >= 0; --i)
        {
            int row[] = inds[i];
            for (int j = (row.length)-1; (j) >= 0; --j)
            {
                vpv(result, result, array[row[j]]);
                totalInds++;
            }
        }
        vxs(result, result, (float)1/(float)totalInds);
    }

    /**
    *  Compute the array of sums-- each element of result
    *  is the sum of the box starting at index 0,0,...0
    *  up to and including the given index.
    *  result is allowed to be the same as from.
    */
    public static void integrate(Object result, Object from)
    {
        if (result instanceof int[])
        {
            int resultArray[] = (int[])result;
            int fromArray[] = (int[])from;
            int sum = 0;
            int n = resultArray.length;
            for (int i = 0; (i) < (n); ++i)
            {
                sum += fromArray[i];
                resultArray[i] = sum;
            }
        }
        else if (result instanceof double[])
        {
            double resultArray[] = (double[])result;
            double fromArray[] = (double[])from;
            double sum = 0;
            int n = resultArray.length;
            for (int i = 0; (i) < (n); ++i)
            {
                sum += fromArray[i];
                resultArray[i] = sum;
            }
        }
        else // must be a higher-dimensonal array of int or double
        {
            Object resultArray[] = (Object[])result;
            Object fromArray[] = (Object[])from;
            int n = resultArray.length;
            for (int i = 0; (i) < (n); ++i)
                integrate(resultArray[i], fromArray[i]);
            for (int i = 0; (i) < (n-1); ++i)
                mpm(resultArray[i+1], resultArray[i], resultArray[i+1]);
        }
    } // integrate

    /**
    *  Inverse of the integrate function.
    *  result is allowed to be the same as from.
    */
    public static void differentiate(Object result, Object from)
    {
        if (result instanceof int[])
        {
            int resultArray[] = (int[])result;
            int fromArray[] = (int[])from;
            for (int i = (resultArray.length-1)-1; (i) >= 0; --i)
                resultArray[i+1] = fromArray[i+1] - fromArray[i];
            if (resultArray.length > 0)
                resultArray[0] = fromArray[0];
        }
        else if (result instanceof double[])
        {
            double resultArray[] = (double[])result;
            double fromArray[] = (double[])from;
            for (int i = (resultArray.length-1)-1; (i) >= 0; --i)
                resultArray[i+1] = fromArray[i+1] - fromArray[i];
            if (resultArray.length > 0)
                resultArray[0] = fromArray[0];
        }
        else // must be a higher-dimensional array of int or double
        {
            Object resultArray[] = (Object[])result;
            Object fromArray[] = (Object[])from;
            for (int i = (resultArray.length)-1; (i) >= 0; --i)
                differentiate(resultArray[i], fromArray[i]);
            for (int i = (resultArray.length-1)-1; (i) >= 0; --i)
                mmm(resultArray[i+1], resultArray[i+1], resultArray[i]);
        }
    } // differentiate

        /** recursive function used by bboxIndexed... */
        private static void _bboxIndexed(double result[/*2*/][],
                                         double coords[][],
                                         Object inds) // array of ints, dim >= 1
        {
            int nDims = coords[0].length;
            Class<?> indsClass = inds.getClass();
            Class<?> componentType = indsClass.getComponentType();
            do { if (!(componentType != null)) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+1896 +"): " + "componentType != null" + ""); } while (false); // inds must be an array
            if (componentType.isArray())
            {
                int n = java.lang.reflect.Array.getLength(inds);
                for (int i = (n)-1; (i) >= 0; --i)
                    _bboxIndexed(result,
                                 coords,
                                 java.lang.reflect.Array.get(inds, i));
            }
            else
            {
                int ints[] = (int[])inds;
                for (int iInt = (ints.length)-1; (iInt) >= 0; --iInt)
                for (int iDim = (nDims)-1; (iDim) >= 0; --iDim)
                {
                    double val = coords[ints[iInt]][iDim];
                    result[0][iDim] = Math.min(result[0][iDim], val);
                    result[1][iDim] = Math.max(result[1][iDim], val);
                }
            }
        } // _bboxIndexed
    /** bounding box of multidimensional indexed list into an array of points */
    public static void bboxIndexed(double result[/*2*/][],
                                   double coords[][],
                                   Object inds) // array of ints, dim >= 1
    {
        fillvec(result[0], Double.POSITIVE_INFINITY);
        fillvec(result[1], Double.NEGATIVE_INFINITY);
        _bboxIndexed(result, coords, inds);

    } // bboxIndexed

    /** bounding box of an array of points */
    public static void bbox(float result[/*2*/][], float array[][])
    {
        for (int i = (result[0].length)-1; (i) >= 0; --i)
        {
            result[0][i] = Float.POSITIVE_INFINITY;
            result[1][i] = Float.NEGATIVE_INFINITY;
        }
        for (int i = (array.length)-1; (i) >= 0; --i)
        for (int j = (array[i].length)-1; (j) >= 0; --j)
        {
            result[0][j] = Math.min(result[0][j], array[i][j]);
            result[1][j] = Math.max(result[1][j], array[i][j]);
        }
    }
    /** bounding box of an array of points */
    public static void bbox(double result[/*2*/][], double array[][])
    {
        for (int i = (result[0].length)-1; (i) >= 0; --i)
        {
            result[0][i] = Double.POSITIVE_INFINITY;
            result[1][i] = Double.NEGATIVE_INFINITY;
        }
        for (int i = (array.length)-1; (i) >= 0; --i)
        for (int j = (array[i].length)-1; (j) >= 0; --j)
        {
            result[0][j] = Math.min(result[0][j], array[i][j]);
            result[1][j] = Math.max(result[1][j], array[i][j]);
        }
    }

    /** uniform (i.e. square, cube, etc.) bounding box of array of points */
    public static void bboxUniform(double bbox[/*2*/][], double array[][])
    {
        bbox(bbox, array);
        double bboxCenter[] = average(bbox);
        double bboxDims[] = vmv(bbox[1], bbox[0]);
        double bboxMaxDim = max(bboxDims);
        fillvec(bboxDims, bboxMaxDim);
        vpsxv(bbox[0], bboxCenter, -.5, bboxDims);
        vpsxv(bbox[1], bboxCenter, .5, bboxDims);
    }

    /** intersect two boxes */
    public static void bboxIntersect(double result[/*2*/][],
                                     double bbox0[/*2*/][],
                                     double bbox1[/*2*/][])
    {
        int n = result[0].length;
        for (int i = 0; (i) < (n); ++i)
        {
            result[0][i] = ((bbox0[0][i])>=(bbox1[0][i])?(bbox0[0][i]):(bbox1[0][i]));
            result[1][i] = ((bbox0[1][i])<=(bbox1[1][i])?(bbox0[1][i]):(bbox1[1][i]));
        }
    }

    /** bounding box of union of two boxes */
    public static void bboxUnion(double result[/*2*/][],
                                 double bbox0[/*2*/][],
                                 double bbox1[/*2*/][])
    {
        int n = result[0].length;
        for (int i = 0; (i) < (n); ++i)
        {
            result[0][i] = ((bbox0[0][i])<=(bbox1[0][i])?(bbox0[0][i]):(bbox1[0][i]));
            result[1][i] = ((bbox0[1][i])>=(bbox1[1][i])?(bbox0[1][i]):(bbox1[1][i]));
        }
    }

    /** whether bbox (including boundary) contains point, within tolerance */
    public static boolean closedBBoxContains(double bbox[/*2*/][],
                                             double point[],
                                             double tol)
    {
        for (int i = (point.length)-1; (i) >= 0; --i)
            if (!((bbox[0][i] - tol <=(point[i]))&&((point[i])<= bbox[1][i] + tol)))
                return false;
        return true;
    }
    /** whether bbox (exluding boundary) contains point, within tolerance */
    public static boolean bboxInteriorContains(double bbox[/*2*/][],
                                               double point[],
                                               double tol)
    {
        for (int i = (point.length)-1; (i) >= 0; --i)
            if (!((bbox[0][i] + tol <(point[i]))&&((point[i])< bbox[1][i] - tol)))
                return false;
        return true;
    }


    /** transpose matrix */
    public static void transpose(double result[][], double M[][])
    {
        do { if (!(result != M)) throw new Error("Assumption failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+2022 +"): " + "result != M" + ""); } while (false);
        for (int i = (M.length)-1; (i) >= 0; --i)
        for (int j = (M[i].length)-1; (j) >= 0; --j)
            result[j][i] = M[i][j];
    }

    /**
     * LU decompomposition, straight out of Numerical recipes in C.
     * <p>
     * The nxn matrix A is replaced by the LU decomposition
     * of a rowwise permutation of itself.
     * indx is an output vector that records the row permutation
     * effected by the partial pivoting;
     * the function return value is +-1 depending on whether
     * the number of row interchanges was even or odd, respectively.
     * <p>
     * This function is used in combination with luBackSubstitute
     * to solve linear equations or invert a matrix.
     * <p>
     * These functions are used internally by
     * <code>invmxv</code>,
     * <code>invmxm</code>,
     * <code>vxinvm</code>,
     * and <code>mxinvm</code>
     * which provide an easier-to-use
     * interface for solving linear (and linear least-squares) systems.
     */
    public static int luDecompose(double A[/*n*/][/*n*/],
                             int n, int indx[])
        throws Exception // when singular
    {
        double vv[] = new double[n]; // stores the implicit scaling of each row.
        int d = 1; // no row interchanges yet.
        for (int i = 0; (i) < (n); ++i) // Loop over rows to get the implicit scaling information.
        {
            // max will be absolute value of largest element in row i.
            double max = 0.;
            for (int j = 0; (j) < (n); ++j)
            {
                double temp = ((A[i][j]) < 0 ? -(A[i][j]) : (A[i][j]));
                if (temp > max)
                    max = temp;
            }
            if (max == 0.)
            {
                throw new Exception("Singular matrix in routine luDecompose"); // No nonzero largest element.  // XXX should throw something else? XXX should make sure we handle this exception in all functions that call this one?
            }
            vv[i] = 1./max;
        }
        for (int j = 0; (j) < (n); ++j) // This is the loop over columns of Crout's method.
        {
            for (int i = 0; (i) < (j); ++i) // This is equation (2.3.12) except for i==j.
            {
                double sum = A[i][j];
                for (int k = 0; (k) < (i); ++k)
                    sum -= A[i][k] * A[k][j];
                A[i][j] = sum;
            }

            double max = 0.; // Initialize for the search for largest pivot element.
            int imax = -1;
            for (int i = j; i < n; i++) // This is i==j of equation (2.3.12) and i==j+1..n-1 of equation (2.3.13).
            {
                double sum = A[i][j];
                for (int k = 0; (k) < (j); ++k)
                    sum -= A[i][k] * A[k][j];
                A[i][j] = sum;
                double dum = vv[i] * ((sum) < 0 ? -(sum) : (sum));
                if (dum >= max) // Is the figure of merit for the pivot better than the best so far?
                {
                    max = dum;
                    imax = i;
                }
            }
            if (imax == -1)
            {
                System.out.println("uh oh...");
                System.out.println("        " + "A" + " =\n" + VecMath.toString(A));
            }
            do { if (!(imax != -1)) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+2101 +"): " + "imax != -1" + ""); } while (false); // XXX this can happen, if NaNs in the matrix
            if (j != imax) // Do we need to interchange rows?
            {
                // Yes, do so...
                double temp[];
                {temp=(A[imax]);A[imax]=(A[j]);A[j]=(temp);};
                d = -d; // ... and change the parity of d.
                vv[imax] = vv[j]; // Also interchange the scale factor.
            }
            indx[j] = imax;
            if (A[j][j] == 0.)
            {
                // If the pivot element is zero the matrix is singular
                // (at least to the precision of the algorithm).
                // For some applications on singular matrices,
                // it is desirable to substitute TINY for zero.

                A[j][j] = 1e-40;
            }
            if (j != n-1) // now, finally, divide by the pivot element.
            {
                double invAjj = 1./A[j][j];
                for (int i = j+1; i < n; i++)
                    A[i][j] *= invAjj;
            }
        }
        return d;
    } // luDecompose

    /**
     * Solves the set of n linear equations A*x = b.
     * <p>
     * Here A[0..n-1] is input,
     * not as the matrix A but rather its LU decomposition,
     * determined by the routing luDecompose.
     * indx[0..n-1] is input as the permutation vector returned by luDecompose.
     * b[0..n-1] is input as the right-hand side vector b,
     * and returns with the solution vector x.
     * A, n, and indx are not modified by this routine
     * and can be left in place for successive calls
     * with different right-hand sides b.
     * <p>
     * This routine takes into account the possibility that b will begin
     * with many zero elements, so it is efficient for use
     * in matrix inversion.
     * <p>
     * These functions are used internally by
     * <code>invmxv</code>,
     * <code>invmxm</code>,
     * <code>vxinvm</code>,
     * and <code>mxinvm</code>
     * which provide an easier-to-use
     * interface for solving linear (and linear least-squares) systems.
     */
    public static void luBackSubstitute(double A[][],
                              int n,
                              int indx[],
                              double b[])
    {
        int ii = -1;
        // when ii is set to a nonnegative value,
        // it will become the index of the first nonvanishing element
        // of b.

        // We now do the forward substitution, equation (2.3.6).
        // The only new wrinkle is to unscramble the permutation as we go.
        for (int i = 0; (i) < (n); ++i)
        {
            int ip = indx[i];
            double sum = b[ip];
            b[ip] = b[i];
            if (ii >= 0)
                for (int j = ii; j < i; j++)
                    sum -= A[i][j] * b[j];
            else if (sum != 0.)
                ii = i; // A nonzero element was encountered, so from now on we will have to do the sums in the loop above.
            b[i] = sum;

        }
        for (int i = (n)-1; (i) >= 0; --i) // Now we do the backsubstitution, equation (2.3.7).
        {
            double sum = b[i];
            for (int j = i+1; j < n;j++)
                sum -= A[i][j] * b[j];
            b[i] = sum / A[i][i]; // Store a component of the solution vector x.
        } // All done!
    } // luBackSubstitute


    /**
     * Linear equation solver and matrix inverter
     * by Gauss-Jordan elimination with full pivoting,
     * straight out of Numerical recipes in C, page 39.
     * <p>
     * a[0..n-1][0..n-1] is the input matrix.
     * b[0..n-1][0..m-1] is input containing the m
     * right-hand vectors as columns.
     * On output, a is replaced by its matrix inverse, and b is replaced
     * by the corresponding set of solution vectors (as columns).
     */
    public static void gaussj(double a[/*n*/][/*n*/], int n,
                              double b[/*n*/][/*m*/], int m)
        throws Exception // on exactly singular matrix
    {
        int indxc[], indxr[], ipiv[];
        int i,icol=-1,irow=-1,j,k,l,ll;
        double big,dum,pivinv,doubletemp;

        indxc = new int[n];
        indxr = new int[n];
        ipiv = new int[n];
        for (j = 0; (j) < (n); ++j)
            ipiv[j] = 0;
        for (i = 0; (i) < (n); ++i) {
            big = 0.;
            for (j = 0; (j) < (n); ++j) {
                if (ipiv[j] != 1) {
                    for (k = 0; (k) < (n); ++k) {
                        if (ipiv[k] == 0) {
                            if (((a[j][k]) < 0 ? -(a[j][k]) : (a[j][k])) >= big) {
                                big = ((a[j][k]) < 0 ? -(a[j][k]) : (a[j][k]));
                                irow = j;
                                icol = k;
                            }
                        } else if (ipiv[k] > 1) {
                            // XXX Error - singular matrix, 1
                            throw new Exception("Singular matrix in routine gaussj, 1"); // XXX should throw something else? XXX should make sure we handle this exception in all functions that call this one?
                        }
                    }
                }
            }
            ++ipiv[icol];
            /*
             * We now have the pivot, so interchange rows, if needed,
             * to put the pivot element on the diagonal.
             */
            if (irow != icol) {
                for (l = 0; (l) < (n); ++l) {doubletemp=(a[irow][l]);a[irow][l]=(a[icol][l]);a[icol][l]=(doubletemp);};
                for (l = 0; (l) < (m); ++l) {doubletemp=(b[irow][l]);b[irow][l]=(b[icol][l]);b[icol][l]=(doubletemp);};
            }
            indxr[i]=irow;
            indxc[i]=icol;
            if (a[icol][icol] == 0.) {
                // XXX Error - singular matrix, 2
                throw new Exception("Singular matrix in routine gaussj, 2"); // XXX should throw something else? XXX should make sure we handle this exception in all functions that call this one?
            }
            pivinv = 1.0/a[icol][icol];
            a[icol][icol] = 1.;
            for (l = 0; (l) < (n); ++l) a[icol][l] *= pivinv;
            for (l = 0; (l) < (m); ++l) b[icol][l] *= pivinv;
            for (ll = 0; (ll) < (n); ++ll) {
                if (ll != icol) {
                    dum = a[ll][icol];
                    a[ll][icol] = 0.;
                    for (l = 0; (l) < (n); ++l) a[ll][l] -= a[icol][l]*dum;
                    for (l = 0; (l) < (m); ++l) b[ll][l] -= b[icol][l]*dum;
                }
            }
        }
        /*
         * Unscramble the solution in view of the column interchanges.
         */
        for (l = n-1; l >= 0; --l) {
            if (indxr[l] != indxc[l])
                for (k = 0; (k) < (n); ++k)
                    {doubletemp=(a[k][indxr[l]]);a[k][indxr[l]]=(a[k][indxc[l]]);a[k][indxc[l]]=(doubletemp);};
        }
    } // gaussj

    /** invert matrix */
    public static void invertmat(double result[][], double M[][])
    {
        int nRows = M.length;
        int nCols = ((M).length==0 ? 0 : (M)[0].length);
        do { if (!((nRows)==(result.length))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+2275 +"): (" + "nRows" + ")" + "==" + "(" + "result.length" + ") ("+(nRows)+" vs. "+(result.length)+")"); } while (false);
        do { if (!((nCols)==(((result).length==0 ? 0 : (result)[0].length)))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+2276 +"): (" + "nCols" + ")" + "==" + "(" + "((result).length==0 ? 0 : (result)[0].length)" + ") ("+(nCols)+" vs. "+(((result).length==0 ? 0 : (result)[0].length))+")"); } while (false);
        if (nRows == nCols)
        {




            double temp[][] = copymat(M);
            int indx[] = new int[nRows];
            try
            {
                /*(void)*/luDecompose(temp, nRows, indx); // decompose the matrix just once.
            }
            catch (Exception e)
            {
                fillmat(result, Double.POSITIVE_INFINITY);
                return;
            }

            double col[] = new double[nRows];
            for (int j = 0; (j) < (nRows); ++j)
            {
                zerovec(col);
                col[j] = 1.;
                luBackSubstitute(temp,nRows,indx,col);
                setcolumn(result, j, col);
            }

        }
        else
        {
            int n = ((nRows)>=(nCols)?(nRows):(nCols));
            double temp[][] = identitymat(n);
            copymat(temp, M);



            invertmat(temp, temp);

            copymat(result, temp);
        }
    } // invertmat

    /** Compute determinant using LQ. M may have fewer rows than columns. */
    public static double detUsingLQ(int nRows, int nCols, double M[][], boolean destructive)
    {
        double betas[] = null; // don't care about betas
        double LQcompressed[][] = destructive ? M : copymat(nRows, nCols, M);
        int detSign = LQdecompositionCompressed(nRows, nCols,
                                                LQcompressed, // in/out
                                                betas); // out
        double det = (double)detSign;
        for (int i = 0; (i) < (nRows); ++i)
            det *= LQcompressed[i][i];
        return det;
    } // detUsingLQ
    /** Compute determinant using LQ. M may have fewer rows than columns. */
    public static double detUsingLQ(double M[][], boolean destructive)
    {
        return detUsingLQ(M.length, ((M).length==0 ? 0 : (M)[0].length), M, destructive);
    }

    /** compute the k-dimensional content of k vectors in n dimensions. */
    public static double orthotopeContent(int k, int n, double vecs[][], boolean destructive)
    {
        return detUsingLQ(k, n, vecs, destructive);
    } // orthotopeContent

    /** compute the k-dimensional content of k vectors in n dimensions. */
    public static double orthotopeContent(double vecs[][], boolean destructive)
    {
        return detUsingLQ(vecs.length, ((vecs).length==0 ? 0 : (vecs)[0].length), vecs, destructive);
    } // orthotopeContent

    /** compute the (k-1)-dimensional content of k points in n dimensions. */
    public static double relativeOrthotopeContent(int nPoints, int dim, double points[][], boolean destructive)
    {
        do { if (!(nPoints >= 1)) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+2353 +"): " + "nPoints >= 1" + ""); } while (false);
        double relativeTo[] = points[nPoints-1];
        if (!destructive)
            points = copymat(nPoints-1, dim, points); // can omit relativeTo
        for (int iPoint = 0; (iPoint) < (nPoints-1); ++iPoint)
            vmv(dim, points[iPoint], points[iPoint], relativeTo);
        return detUsingLQ(nPoints-1, dim, points, true); // fine for it to be destructive now
    } // orthotopeContent

    public static double detUsingLU(double M[][], boolean destructive)
    {
        if (!destructive)
            M = copymat(M);
        int n = M.length;
        do { if (!((n)==(((M).length==0 ? 0 : (M)[0].length)))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+2367 +"): (" + "n" + ")" + "==" + "(" + "((M).length==0 ? 0 : (M)[0].length)" + ") ("+(n)+" vs. "+(((M).length==0 ? 0 : (M)[0].length))+")"); } while (false);
        try
        {
            int indx[] = new int[n];
            double d = (double)luDecompose(M, n, indx); // this returns d as +-1.
            for (int j = 0; (j) < (n); ++j)
                d *= M[j][j];
            return d;
        }
        catch (Exception e)
        {
            return 0.; // XXX not sure this is really exceptional, but...
        }
    } // detUsingLU

    /** matrix determinant (optionally destroys the contents of M in the process, but faster) */
    public static double det(double M[][], boolean destructive)
    {
        int n = M.length;
        do { if (!((n)==(((M).length==0 ? 0 : (M)[0].length)))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+2386 +"): (" + "n" + ")" + "==" + "(" + "((M).length==0 ? 0 : (M)[0].length)" + ") ("+(n)+" vs. "+(((M).length==0 ? 0 : (M)[0].length))+")"); } while (false);

        if (true)
        {
            // optimize for small cases...
            switch (n)
            {
                case 0:
                    return 1.;
                case 1:
                    return M[0][0];
                case 2:
                    return vxv2(M[0], M[1]);
                case 3:
                    return vxvxv3(M[0], M[1], M[2]); // XXX is this robust?
            }
        }
        else
        {
            if (((0 <=(n))&&((n)<= 3)))
                System.err.println("WARNING: doing slow detDestructive for testing, dim = "+n+"");
        }
        return detUsingLU(M, destructive);
    } // det with optional destructivity

    /** destructive matrix determinant (destroys the contents of M in the process) */
    public static double detDestructive(double M[][])
    {
        return det(M, true);
    } // detDestructive

    /** matrix determinant */
    public static double det(double M[][])
    {
        return det(M, false);
    } // det


    /**
     * Matrix inverse times column vector
     * (linear equations or least-squares solver).
     * <p>
     * Given a matrix A and column vector b,
     * computes A^-1 b, i.e. the solution x
     * to the system of linear equations A x = b.
     * <p>
     * If the system is overdetermined by dimensions
     * (i.e. A has more rows than columns),
     * then the solution x will be found
     * that minimizes ||A x - b||;
     * that is, x that solves A^T A x = A^T b,
     * that is, x = (A^T A)^-1 A^T b.
     */
    public static void invmxv(double result[], double A[][], double b[])
    {
        if (result.length == 0)
            return; // avoid dangerous assertions

        if (false) // XXX get rid
        {
            {System.out.print("        "); System.out.println("result.length" + " = " + (result.length));};
            {System.out.print("        "); System.out.println("A.length" + " = " + (A.length));};
            {System.out.print("        "); System.out.println("((A).length==0 ? 0 : (A)[0].length)" + " = " + (((A).length==0 ? 0 : (A)[0].length)));};
            {System.out.print("        "); System.out.println("b.length" + " = " + (b.length));};
        }

        int n = b.length;
        do { if (!((n)==(A.length))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+2453 +"): (" + "n" + ")" + "==" + "(" + "A.length" + ") ("+(n)+" vs. "+(A.length)+")"); } while (false);
        int rowlength = ((A).length==0 ? 0 : (A)[0].length);
        do { if (!((rowlength)==(result.length))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+2455 +"): (" + "rowlength" + ")" + "==" + "(" + "result.length" + ") ("+(rowlength)+" vs. "+(result.length)+")"); } while (false);
        if (rowlength < n)
        {
            // Linear least squares
            double Atranspose[][] = transpose(A);
            double bb[] = mxv(Atranspose, b); // column vector of size rowlength
            double AA[][] = mxm(Atranspose, A); // rowlength by rowlength
            invmxv(result, AA, bb); // recurse on the normal equation
            return;
        }
        do { if (!((rowlength)==(n))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+2465 +"): (" + "rowlength" + ")" + "==" + "(" + "n" + ") ("+(rowlength)+" vs. "+(n)+")"); } while (false); // A is square
                // XXX note, we get a different assertion above if A is 0x1, should make that more clear

        double temp[][] = copymat(A);
        int indx[] = new int[n];
        try
        {
            /*(void)*/luDecompose(temp, n, indx);
        }
        catch (Exception e)
        {
            fillvec(result, Double.POSITIVE_INFINITY);
            return;
        }
        copyvec(result, b);
        luBackSubstitute(temp, n, indx, result);

        if (normsqrd(result) < 1e20) // XXX work around the TINY thing... this is going to have to cleaned up eventually to deal with nearly singular matrices anyway
        {
            // check that it worked, i.e. that b = A * result
            do { if (!(result != b)) throw new Error("Assumption failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+2485 +"): " + "result != b" + ""); } while (false); // XXX shouldn't assume this
            double bb[] = mxv(A, result);
            //PRINTMAT(A);
            //PRINTVEC(result);
            //PRINTVEC(b);
            //PRINTVEC(bb);

            for (int i = 0; (i) < (n); ++i)
            {
                //CHECK_EQ(1. + SQR(bb[i] - b[i]), 1.);
                /*
                if (1. + SQR(bb[i] - b[i]) != 1.)
                {
                    PRINT("WARNING!"); // XXX lame behavior!
                    PRINT(bb[i]);
                    PRINT(b[i]);
                    PRINT(SQR(bb[i] - b[i]));
                    PRINT(1. + SQR(bb[i] - b[i]));
                }
                */
                if (((b[i]) < 0 ? -(b[i]) : (b[i])) > 1. && ((bb[i]) < 0 ? -(bb[i]) : (bb[i])) > 1.)
                    do { if (!(((float)(bb[i]/b[i]))==((float)1.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+2506 +"): (" + "(float)(bb[i]/b[i])" + ")" + "==" + "(" + "(float)1." + ") ("+((float)(bb[i]/b[i]))+" vs. "+((float)1.)+")"); } while (false);
                else
                    do { if (!(((float)(1. + ((bb[i] - b[i])*(bb[i] - b[i]))))==((float)1.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+2508 +"): (" + "(float)(1. + ((bb[i] - b[i])*(bb[i] - b[i])))" + ")" + "==" + "(" + "(float)1." + ") ("+((float)(1. + ((bb[i] - b[i])*(bb[i] - b[i]))))+" vs. "+((float)1.)+")"); } while (false);
            }
        }
    } // invmxv

    /** matrix inverse times matrix */
    public static void invmxm(double result[][], double A[][], double B[][])
    {
        if (result.length == 0 || result[0].length == 0)
            return; // avoid dangerous assertions

        int n = B.length;
        do { if (!((n)==(A.length))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+2520 +"): (" + "n" + ")" + "==" + "(" + "A.length" + ") ("+(n)+" vs. "+(A.length)+")"); } while (false);
        int rowlength = ((A).length==0 ? 0 : (A)[0].length);
        do { if (!((rowlength)==(result.length))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+2522 +"): (" + "rowlength" + ")" + "==" + "(" + "result.length" + ") ("+(rowlength)+" vs. "+(result.length)+")"); } while (false);
        int nCols = ((result).length==0 ? 0 : (result)[0].length);
        do { if (!((nCols)==(((B).length==0 ? 0 : (B)[0].length)))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+2524 +"): (" + "nCols" + ")" + "==" + "(" + "((B).length==0 ? 0 : (B)[0].length)" + ") ("+(nCols)+" vs. "+(((B).length==0 ? 0 : (B)[0].length))+")"); } while (false);
        if (rowlength < n)
        {
            // Linear least squares
            double Atranspose[][] = transpose(A);
            double BB[][] = mxm(Atranspose, B);
            double AA[][] = mxm(Atranspose, A); // rowlength by rowlength
            invmxm(result, AA, BB); // recurse on the normal equation, of size rowlength
            return;
        }
        do { if (!((rowlength)==(n))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+2534 +"): (" + "rowlength" + ")" + "==" + "(" + "n" + ") ("+(rowlength)+" vs. "+(n)+")"); } while (false); // A is square

        double temp[][] = copymat(A);
        int indx[] = new int[n];
        try
        {
            /*(void)*/luDecompose(temp, n, indx);
        }
        catch (Exception e)
        {
            fillmat(result, Double.POSITIVE_INFINITY);
            return;
        }
        double col[] = new double[n];
        for (int i = 0; (i) < (nCols); ++i)
        {
            getcolumn(col, B, i);
            luBackSubstitute(temp, n, indx, col);
            setcolumn(result, i, col);
        }
    } // invmxm

    /**
     * Row vector times matrix inverse
     * (linear equations or least-squares solver).
     * <p>
     * Given a row vector b and a matrix A,
     * computes b A^-1, i.e. the solution x
     * to the system of linear equations x A = b.
     * <p>
     * If the system is overdetermined by dimensions
     * (i.e. A has more columns than rows),
     * then the solution x will be found
     * that minimizes ||x A - b||;
     * that is, x that solves x A A^T = b A^T,
     * that is, x = b A^T (A A^T)^-1.
     */
    public static void vxinvm(double result[], double b[], double A[][])
    {
        if (result.length == 0)
            return; // avoid dangerous assertions
        invmxv(result, transpose(A), b);
    } // vxinvm

    /** matrix times matrix inverse */
    public static void mxinvm(double result[][], double B[][], double A[][])
    {
        if (result.length == 0 || result[0].length == 0)
            return; // avoid dangerous assertions
        double transposeResult[][] = new double[((result).length==0 ? 0 : (result)[0].length)][result.length];
        invmxm(transposeResult, transpose(A), transpose(B));
        transpose(result, transposeResult);
    }

    /** square submatrix */
    public static void submat(double result[][], double M[][], int inds[])
    {
        for (int i = (inds.length)-1; (i) >= 0; --i)
        for (int j = (inds.length)-1; (j) >= 0; --j)
            result[i][j] = M[inds[i]][inds[j]];
    }

    /** set matrix to identity */
    public static void identitymat(double M[][])
    {
        for (int i = (M.length)-1; (i) >= 0; --i)
        for (int j = (M[i].length)-1; (j) >= 0; --j)
            M[i][j] = (i==j ? 1 : 0);
    }
    /** set matrix to identity */
    public static void identitymat(float M[][])
    {
        for (int i = (M.length)-1; (i) >= 0; --i)
        for (int j = (M[i].length)-1; (j) >= 0; --j)
            M[i][j] = (i==j ? 1 : 0);
    }

    /** Finds the matrix that rotates radians in the direction from fromAxis to toAxis, when applied to a vector by multiplying the matrix on the right by the row vector on the left. */
    public static void makeRowRotMat(double M[][], int fromAxis, int toAxis, double radians)
    {
        do { if (!(fromAxis != toAxis)) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+2614 +"): " + "fromAxis != toAxis" + ""); } while (false); // which means dim must be >= 2
        identitymat(M);
        double s = Math.sin(radians);
        double c = Math.cos(radians);
        M[fromAxis][fromAxis] = c;
        M[fromAxis][toAxis] = s;
        M[toAxis][fromAxis] = -s;
        M[toAxis][toAxis] = c;
    }
    /** Finds the matrix that rotates radians in the direction from fromAxis to toAxis, when applied to a vector by multiplying the matrix on the right by the row vector on the left. */
    public static void makeRowRotMat(float M[][], int fromAxis, int toAxis, float radians)
    {
        do { if (!(fromAxis != toAxis)) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+2626 +"): " + "fromAxis != toAxis" + ""); } while (false); // which means dim must be >= 2
        identitymat(M);
        float s = (float)Math.sin(radians);
        float c = (float)Math.cos(radians);
        M[fromAxis][fromAxis] = c;
        M[fromAxis][toAxis] = s;
        M[toAxis][fromAxis] = -s;
        M[toAxis][toAxis] = c;
    }

    /** Finds the matrix that translates by a given amount, when applied to a vector by multiplying the matrix on the right by the row vector on the left. */
    public static void makeRowTransMat(double M[][], double translate[])
    {
        identitymat(M); // non-square is okay
        int nRows = M.length;
        for (int i = (translate.length)-1; (i) >= 0; --i)
            M[nRows-1][i] = translate[i];
    }
    /** Finds the matrix that translates by minus a given amount, when applied to a vector by multiplying the matrix on the right by the row vector on the left. */
    public static void makeRowTransMatInv(double M[][], double translate[])
    {
        identitymat(M); // non-square is okay
        int nRows = M.length;
        for (int i = (translate.length)-1; (i) >= 0; --i)
            M[nRows-1][i] = -translate[i];
    }

    // XXX got bored and stopped converting from FOR to FORIDOWN here


    /** Finds the matrix that non-uniformly scales by a given amount, when applied to a vector by multiplying the matrix on the right by the row vector on the left. */
    public static void makeRowScaleMat(double M[][], double scale[])
    {
        int i, j, n = M.length, m = (n == 0 ? 0 : M[0].length);
        for (i = 0; (i) < (n); ++i)
        for (j = 0; (j) < (m); ++j)
            M[i][j] = (i==j ? i>=scale.length ? 1.
                                              : scale[i]
                            : 0);
    }

    /**
     * Calculates the angle between two unit vectors,
     * using the robust algorithm described in <a href="http://plunk.org/~hatch/rightway.php">http://plunk.org/~hatch/rightway.php</a>.
     */
    public static double angleBetweenUnitVectors(int n, double u0[], double u1[])
    {
        // XXX can we cleverly avoid the square root?
        if (dot(n, u0, u1) > (double)0)
            return 2*Math.asin(.5*dist(n, u0,u1));
        else
        {
            double minusU1[] = sxv(n, (double)-1,u1);
            return Math.PI - 2*Math.asin(.5*dist(n, u0,minusU1));
        }
    }
    public static double angleBetweenUnitVectors(double u0[], double u1[])
    {
        return angleBetweenUnitVectors(((u0.length)<=(u1.length)?(u0.length):(u1.length)), u0, u1);
    }
    public static float angleBetweenUnitVectors(float u0[], float u1[])
    {
        // XXX can we cleverly avoid the square root?
        if (dot(u0, u1) > (float)0)
            return (float)(2*Math.asin(.5*dist(u0,u1)));
        else
        {
            float minusU1[] = sxv((float)-1,u1);
            return (float)(Math.PI - 2*Math.asin(.5*dist(u0,minusU1)));
        }
    }

    public static double synopsis(int n, double v[])
    {
        for (int i = 0; (i) < (n); ++i)
            if (v[i] <= 0) // non-strict so we do it this way if on the boundary of the positive orthant
            {
                //
                // Outside the positive orthant,
                // return minus the euclidean distance
                // to the positive orthant.
                //
                double sum = 0.;
                for (; i < n; i++)
                    if (v[i] < 0.)
                        sum += v[i]*v[i];
                return -Math.sqrt(sum);
            }
        {
            //
            // Inside the positive orthant, return the "-2"-norm.
            //
            double sum = 0.;
            for (int i = 0; (i) < (n); ++i)
                sum += 1. / (v[i]*v[i]);
            return Math.sqrt(1. / sum);
            /*
                More stable to calculate it differently,
                    e.g. x / sqrt(1) instead of 1/sqrt(1/x^2)
                    e.g. x y / sqrt(x^2 + y^2) instead of 1/sqrt(1/x^2 + 1/y^2)
                    e.g. x y z / sqrt(x^2 y^2 + x^2 z^2 + y^2 z^2)  instead of 1/sqrt(1/x^2 + 1/y^2 + 1/z^2)
                    I think the following works, but I haven't tested it yet...
                double sum = 0., prod = 1.;
                FORI (i, n)
                {
                    // sum is now the sum of squares of all products of i-1 items from v[0]..v[i-1]  (0 if i=0, 1 if i=1)
                    sum = sum*(v[i]*v[i]) + prod*prod;
                    prod *= v[i];
                    // sum is now the sum of squares of all products of i items from v[0]..v[i]  (1 if i=0)
                }
                // sum is now the sum of squares of all products of n-1 items from v[0]..v[n-1] (0 if n=0, 1 if n=1)
                return sum==0. ? 0. : prod / Math.sqrt(sum);
            */
        }
    } // synopsis of vector returning double

    /* XXX figure out how to expose this, see Holyhedron/SynopsisStuff.prejava */
    public static double synopsis(double v[])
    {
        return synopsis(v.length, v);
    }

    /**
     * Calculates the angular distance from the boundary of the positive orthant
     * to the vector:
     * positive if inside the positive orthant,
     * and negative if outside it.
     * <p>
     * This angle will be
     * in the range [-pi/2 - asin(1/sqrt(n)) .. asin(1/sqrt(n))].
     * It will be positive for vectors in the all-positive orthant,
     * and less than -pi/2 for numbers in the all-negative orthant.
     */
    public static double positiveOrthantness(double v[],
                                             boolean useSynopsis)
    {
        int n = v.length;

        // Special case for trivial cases to prevent unstable math
        if (n <= 1)
            return n == 0 ? 0. : // abitrary
                   v[0] > 0. ? Math.PI/2 :
                   v[0] < 0. ? -Math.PI/2 : 0.;

        double posSum = 0., negSum = 0.;
        double smallestMagnitudePos = Double.POSITIVE_INFINITY;
        double smallestMagnitudeNeg = Double.NEGATIVE_INFINITY;
        for (int i = 0; (i) < (n); ++i)
        {
            double vi = v[i];
            if (vi <= 0)
            {
                negSum += vi*vi;
                smallestMagnitudeNeg = ((smallestMagnitudeNeg)>=(vi)?(smallestMagnitudeNeg):(vi));
            }
            if (vi >= 0)
            {
                posSum += vi*vi;
                smallestMagnitudePos = ((smallestMagnitudePos)<=(vi)?(smallestMagnitudePos):(vi));
            }

        }
        if (negSum == 0. && posSum == 0.)
            return 0.; // arbitrary, instead of blowing up
        else if (negSum == 0.) // if inside all-positive octant
        {
            if (useSynopsis)
                return synopsis(normalize(v));
            else
                return Math.asin(smallestMagnitudePos/Math.sqrt(posSum)); // stable since argument < 1/sqrt(2) since n>=2
        }
        else if (posSum == 0.) // if inside all-negative octant
        {
            if (useSynopsis)
                return -Math.PI/2 - synopsis(normalize(sxv(-1,v)));
            else
                return -Math.PI/2 + Math.asin(smallestMagnitudeNeg/Math.sqrt(negSum)); // stable since argument < 1/sqrt(2) since n>=2
        }
        else // in intermediate octant
            return -Math.atan2(Math.sqrt(negSum), Math.sqrt(posSum));
    } // positiveOrthantness

    /**
     * Returns the matrix obtained from M by adding one identity row and column
     * at the given index.
     */
    public static double[][] insertIdentityRowAndColumn(double M[][], int ind, double zero, double one)
    {
        double[][] result = new double[M.length+1][M.length+1];
        int i, j;
        for (i = 0; (i) < (M.length); ++i)
        for (j = 0; (j) < (M.length); ++j)
            result[i>=ind?i+1:i][j>=ind?j+1:j] = M[i][j];
        for (i = 0; (i) < (result.length); ++i)
            result[i][ind] = result[ind][i] = zero;
        result[ind][ind] = one;
        return result;
    }

    /**
     * Returns the matrix obtained from M by deleting one row and colum
     * at the given index.
     */
    public static double[][] deleteRowAndColumn(double M[][], int ind)
    {
        double[][] result = new double[M.length-1][M.length-1];
        int i, j, n = result.length;
        for (i = 0; (i) < (n); ++i)
        for (j = 0; (j) < (n); ++j)
            result[i][j] = M[i>=ind?i+1:i][j>=ind?j+1:j];
        return result;
    }


    /** exact vector equality to zero */
    public static boolean isZeroExactly(double v[])
    {
        if (v == null)
            return false;
        int n = v.length;
        for (int i = 0; (i) < (n); ++i)
            if (v[i] != 0.)
                return false;
        return true;
    }

    /** int vector equality test */
    public static boolean equals(int v0[], int v1[])
    {
        if (v0 == null)
            return v1 == null ? true : false;
        else if (v1 == null)
            return false;
        int n = v0.length;
        if (n != v1.length)
            return false;
        for (int i = 0; (i) < (n); ++i)
            if (v0[i] != v1[i])
                return false;
        return true;
    } // equals(int[],int[])
    /** int matrix equality test */
    public static boolean equals(int m0[][], int m1[][])
    {
        if (m0 == null)
            return m1 == null ? true : false;
        else if (m1 == null)
            return false;
        int n = m0.length;
        if (n != m1.length)
            return false;
        for (int i = 0; (i) < (n); ++i)
            if (!equals(m0[i], m1[i]))
                return false;
        return true;
    } // equals(int[][],int[][])
    /** exact double vector equality test */
    public static boolean equalsExactly(double v0[], double v1[])
    {
        if (v0 == null)
            return v1 == null ? true : false;
        else if (v1 == null)
            return false;
        int n = v0.length;
        if (n != v1.length)
            return false;
        for (int i = 0; (i) < (n); ++i)
            if (v0[i] != v1[i])
                return false;
        return true;
    } // equalsExactly(double[],double[])
    /** exact double matrix equality test */
    public static boolean equalsExactly(double m0[][], double m1[][])
    {
        if (m0 == null)
            return m1 == null ? true : false;
        else if (m1 == null)
            return false;
        int n = m0.length;
        if (n != m1.length)
            return false;
        for (int i = 0; (i) < (n); ++i)
            if (!equalsExactly(m0[i], m1[i]))
                return false;
        return true;
    } // equalsExactly(double[][],double[][])
    /** exact float vector equality test */
    public static boolean equalsExactly(float v0[], float v1[])
    {
        if (v0 == null)
            return v1 == null ? true : false;
        else if (v1 == null)
            return false;
        int n = v0.length;
        if (n != v1.length)
            return false;
        for (int i = 0; (i) < (n); ++i)
            if (v0[i] != v1[i])
                return false;
        return true;
    } // equalsExactly(float[],float[])
    /** exact float matrix equality test */
    public static boolean equalsExactly(float m0[][], float m1[][])
    {
        if (m0 == null)
            return m1 == null ? true : false;
        else if (m1 == null)
            return false;
        int n = m0.length;
        if (n != m1.length)
            return false;
        for (int i = 0; (i) < (n); ++i)
            if (!equalsExactly(m0[i], m1[i]))
                return false;
        return true;
    } // equalsExactly(float[][],float[][])

    /** Object vector equality test using == on each element Object */
    public static boolean equalsUsingEqualsSymbol(Object v0[], Object v1[])
    {
        if (v0 == null)
            return v1 == null ? true : false;
        else if (v1 == null)
            return false;
        int n = v0.length;
        if (n != v1.length)
            return false;
        for (int i = 0; (i) < (n); ++i)
            if (v0[i] != v1[i])
                return false;
        return true;
    } // equalsUsingEqualsSymbol(Object[],Object[])

    /** Fuzzy matrix equality test; works even if tol==0. */
    public static boolean equals(double M0[][], double M1[][], double tol)
    {
        if (M0 == null && M1 == null)
            return true;
        if (M0 == null || M1 == null || M0.length != M1.length)
            return false;
        int i, n = M0.length;
        for (i = 0; (i) < (n); ++i)
            if (!equals(M0[i], M1[i], tol))
                return false;
        return true;
    } // equals
    /** Fuzzy vector equality test; works even if tol==0. */
    public static boolean equals(int n, double v0[], double v1[], double tol)
    {
        for (int i = 0; (i) < (n); ++i)
        {
            if (v0[i] != v1[i] // avoid function call in common case
             && Math.abs(v0[i]-v1[i]) > tol)
                    return false;
        }
        return true;
    } // equals
    /** Fuzzy vector equality test; works even if tol==0. */
    public static boolean equals(double v0[], double v1[], double tol)
    {
        if (v0 == null && v1 == null)
            return true;
        if (v0 == null || v1 == null || v0.length != v1.length)
            return false;
        int i, n = v0.length;
        for (i = 0; (i) < (n); ++i)
        {
            if (v0[i] != v1[i] // avoid function call in common case
             && Math.abs(v0[i]-v1[i]) > tol)
                    return false;
        }
        return true;
    } // equals
    /** Fuzzy vector comparison: return -1,0,1 according to whether a <,==,> b lexicographically.  Works even if tol==0. */
    public static int cmp(int n, double a[], double b[], double tol)
    {
        for (int i = 0; (i) < (n); ++i)
        {
            if ((((b[i])-(a[i])) > (tol))) return -1;
            if ((((a[i])-(b[i])) > (tol))) return 1;
        }
        return 0;
    }
    /** Fuzzy vector comparison: return -1,0,1 according to whether a <,==,> b, lexicographically.  Works even if tol==0. */
    public static int cmp(double a[], double b[], double tol)
    {
        int alength = a.length;
        if (b.length == alength) return cmp(alength, a, b, tol); // common case
        int answer = cmp(((a.length)<=(b.length)?(a.length):(b.length)), a, b, tol);
        if (answer != 0) return answer;
        if (a.length < b.length) return -1;
        if (a.length > b.length) return 1;
        do { if (!(false)) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+3018 +"): " + "false" + ""); } while (false); // can't happen
        return 0;
    }

    /** downward circular shift */
    public static void downshift(double to[][], double from[][])
    {
        double from0[] = from[0];
        int i, n = from.length;
        for (i = 0; (i) < (n-1); ++i)
            to[i] = from[i+1];
        to[i] = from0;
    } // downshift

    /** upward circular shift */
    public static void upshift(double to[][], double from[][])
    {
        int i, n = from.length;
        double fromLast[] = from[n-1];
        for (i = n-1; i > 0; --i)
            to[i] = from[i-1];
        to[i] = fromLast;
    } // upshift

        /**
         * From numerical recipes in C.
         * <p>
         * Computes all eigenvalues and eigenvectors of a real symmetric matrix.
         * On output, elements of A above the diagonal are destroyed.
         * d[0..n-1] returns the eigenvalues of A.
         * V[0..n-1][0..n-1] is a matrix whose columns contain,
         * on output, the normalized eigenvectors of A.
         * The function return value is the number of Jacobi rotations
         * that were required.
         */
        public static int jacobi(double A[][], double d[], double V[][])
        {
            int n = d.length; // == A.length == A[0].length == V.length == V[0].length

            double b[] = new double[n];
            double z[] = new double[n];
            identitymat(V);

            // initialize b and d to the diagonal of A.
            {
                int i;
                for (i = 0; (i) < (n); ++i)
                {
                    b[i] = d[i] = A[i][i];
                    z[i] = 0.; // This vector will accumulate terms of the form ta_pq as in equation (11.1.14) in the book.
                }
            }

            int nRot = 0;
            int iIter;
            for (iIter = 0; (iIter) < (50); ++iIter) // XXX ? is this appropriate? why?
            {
                double sum = 0.;
                {
                    int i, j;
                    for (i = 0; (i) < (n-1); ++i) // sum off-diagonal elements
                    for (j = i+1; j < n; ++j)
                        sum += ((A[i][j]) < 0 ? -(A[i][j]) : (A[i][j]));
                }

                if (sum == 0.)
                {
                    // The normal return, which relies on quadratic convergence
                    // to machine underflow.
                    //PRINT(iIter);
                    return nRot;
                }
                double tresh = (iIter < 3 ? .2*sum/(n*n) : 0.);
                int i, j;
                for (i = 0; (i) < (n-1); ++i)
                for (j = i+1; j < n; ++j)
                {
                    double g = 100.*((A[i][j]) < 0 ? -(A[i][j]) : (A[i][j]));
                    // After four sweeps, skip the rotation if the off-diagonal element is small.
                    if (iIter > 3 && ((d[i]) < 0 ? -(d[i]) : (d[i]))+g == ((d[i]) < 0 ? -(d[i]) : (d[i]))
                                  && ((d[j]) < 0 ? -(d[j]) : (d[j]))+g == ((d[j]) < 0 ? -(d[j]) : (d[j])))
                        A[i][j] = 0.;
                    else if (((A[i][j]) < 0 ? -(A[i][j]) : (A[i][j])) > tresh)
                    {
                        double h = d[j] - d[i];
                        double t;
                        if (((h) < 0 ? -(h) : (h))+g == ((h) < 0 ? -(h) : (h)))
                        {
                            t = A[i][j]/h; // t = 1/(2*theta)
                        }
                        else
                        {
                            double theta = .5*h/(A[i][j]); // equation 11.1.10
                            t = 1./(((theta) < 0 ? -(theta) : (theta)) + Math.sqrt(1. + theta*theta));
                            if (theta < 0.)
                                t = -t;
                        }
                        double c = 1./Math.sqrt(1. + t*t);
                        double s = t*c;
                        double tau = s/(1. + c);
                        h = t * A[i][j];
                        z[i] -= h;
                        z[j] += h;
                        d[i] -= h;
                        d[j] += h;
                        A[i][j] = 0.;
                        int k;

                        for (k = 0; (k) < (i); ++k) // Case of rotations 1 <= k <= i
                            { g = A[k][i]; h = A[k][j]; A[k][i] = g-s*(h+g*tau); A[k][j] = h+s*(g-h*tau); };
                        for (k = i+1; k < j; ++k) // Case of rotations i < k < j
                            { g = A[i][k]; h = A[k][j]; A[i][k] = g-s*(h+g*tau); A[k][j] = h+s*(g-h*tau); };
                        for (k = j+1; k < n; ++k)
                            { g = A[i][k]; h = A[j][k]; A[i][k] = g-s*(h+g*tau); A[j][k] = h+s*(g-h*tau); };
                        for (k = 0; (k) < (n); ++k)
                            { g = V[k][i]; h = V[k][j]; V[k][i] = g-s*(h+g*tau); V[k][j] = h+s*(g-h*tau); };
                        nRot++;
                    }
                } // for i,j above diagonal
                // Update d with the sum of ta_pq, and reinitialize z.
                for (i = 0; (i) < (n); ++i)
                {
                    b[i] += z[i];
                    d[i] = b[i];
                    z[i] = 0.;
                }
            } // for iIter

            // in practice, it pretty much always converges by 8 iterations
            // (for up to an 11x11 matrix)
            System.err.println("Too many iterations in routine jacobi");
            return -1;
        } // jacobi

    /** From numerical recipes, through http://cacs.usc.edu/education/phys516/src/TB/svdcmp.c
    * Given a matrix a[0..m-1][1..n-1], this routine computes its singular value
    * decomposition, A = U W V^T.  The matrix U replaces a on output.  The diagonal
    * matrix of singular values W is output as a vector w[0..n-1].  The matrix V (not
    * the transpose VT) is output as v[0..n-1][0..n-1].
    */
    public static void svdcmp(double[][] a, int m, int n, double w[], double v[][])
    {


        boolean flag;
        int i,its,j,jj,k,l=-1,nm=-1;
        double anorm,c,f,g,h,s,scale,x,y,z;

        double[] rv1 = new double[n];

        g=scale=anorm=0.0; /* Householder reduction to bidiagonal form */
        for (i=0;i<n;i++) {
            l=i+1;
            rv1[i]=scale*g;
            g=s=scale=0.0;
            if (i < m) {
                for (k=i;k<m;k++) scale += Math.abs(a[k][i]);
                if (scale != 0.) {
                    for (k=i;k<m;k++) {
                        a[k][i] /= scale;
                        s += a[k][i]*a[k][i];
                    }
                    f=a[i][i];
                    g = -((f) >= 0.0 ? Math.abs(Math.sqrt(s)) : -Math.abs(Math.sqrt(s)));
                    h=f*g-s;
                    a[i][i]=f-g;
                    for (j=l;j<n;j++) {
                        for (s=0.0,k=i;k<m;k++) s += a[k][i]*a[k][j];
                        f=s/h;
                        for (k=i;k<m;k++) a[k][j] += f*a[k][i];
                    }
                    for (k=i;k<m;k++) a[k][i] *= scale;
                }
            }
            w[i]=scale *g;
            g=s=scale=0.0;
            if (i < m && i != n-1) {
                for (k=l;k<n;k++) scale += Math.abs(a[i][k]);
                if (scale != 0.) {
                    for (k=l;k<n;k++) {
                        a[i][k] /= scale;
                        s += a[i][k]*a[i][k];
                    }
                    f=a[i][l];
                    g = -((f) >= 0.0 ? Math.abs(Math.sqrt(s)) : -Math.abs(Math.sqrt(s)));
                    h=f*g-s;
                    a[i][l]=f-g;
                    for (k=l;k<n;k++) rv1[k]=a[i][k]/h;
                    for (j=l;j<m;j++) {
                        for (s=0.0,k=l;k<n;k++) s += a[j][k]*a[i][k];
                        for (k=l;k<n;k++) a[j][k] += s*rv1[k];
                    }
                    for (k=l;k<n;k++) a[i][k] *= scale;
                }
            }
            anorm = Math.max(anorm,(Math.abs(w[i])+Math.abs(rv1[i])));
        }
        for (i=n-1;i>=0;i--) { /* Accumulation of right-hand transformations. */
            if (i < n) {
                if (g != 0.) {
                    do { if (!(l != -1)) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+3218 +"): " + "l != -1" + ""); } while (false);
                    for (j=l;j<n;j++) /* Double division to avoid possible underflow. */
                        v[j][i]=(a[i][j]/a[i][l])/g;
                    for (j=l;j<n;j++) {
                        for (s=0.0,k=l;k<n;k++) s += a[i][k]*v[k][j];
                        for (k=l;k<n;k++) v[k][j] += s*v[k][i];
                    }
                }
                do { if (!(l != -1)) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+3226 +"): " + "l != -1" + ""); } while (false);
                for (j=l;j<n;j++) v[i][j]=v[j][i]=0.0;
            }
            v[i][i]=1.0;
            g=rv1[i];
            l=i;
        }
        for (i=Math.min(m,n)-1;i>=0;i--) { /* Accumulation of left-hand transformations. */
            l=i+1;
            g=w[i];
            for (j=l;j<n;j++) a[i][j]=0.0;
            if (g != 0.) {
                g=1.0/g;
                for (j=l;j<n;j++) {
                    for (s=0.0,k=l;k<m;k++) s += a[k][i]*a[k][j];
                    f=(s/a[i][i])*g;
                    for (k=i;k<m;k++) a[k][j] += f*a[k][i];
                }
                for (j=i;j<m;j++) a[j][i] *= g;
            } else for (j=i;j<m;j++) a[j][i]=0.0;
            ++a[i][i];
        }
        for (k=n-1;k>=0;k--) { /* Diagonalization of the bidiagonal form. */
            for (its=1;its<=60;its++) { // float code used 30 -donhatch
                flag=true;
                for (l=k;l>=0;l--) { /* Test for splitting. */
                    nm=l-1; /* Note that rv1[1] is always zero. */
                    if (Math.abs(rv1[l])+anorm == anorm) {
                        flag=false;
                        break;
                    }
                    if (Math.abs(w[nm])+anorm == anorm) break;
                }
                if (flag) {
                    c=0.0; /* Cancellation of rv1[l], if l > 1. */
                    s=1.0;
                    for (i=l;i<=k;i++) {
                        f=s*rv1[i];
                        rv1[i]=c*rv1[i];
                        if (Math.abs(f)+anorm == anorm) break;
                        g=w[i];
                        h=Math.hypot(f,g);
                        w[i]=h;
                        h=1.0/h;
                        c=g*h;
                        s = -f*h;
                        for (j=0;j<m;j++) {
                            do { if (!(nm != -1)) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+3273 +"): " + "nm != -1" + ""); } while (false);
                            y=a[j][nm];
                            z=a[j][i];
                            a[j][nm]=y*c+z*s;
                            a[j][i]=z*c-y*s;
                        }
                    }
                }
                z=w[k];
                if (l == k) { /* Convergence. */
                    if (z < 0.0) { /* Singular value is made nonnegative. */
                        w[k] = -z;
                        for (j=0;j<n;j++) v[j][k] = -v[j][k];
                    }
                    break;
                }
                if (its == 60)
                {
                    System.err.println("VecMath.svdcmp: no convergence in 60 svdcmp iterations");
                    do { if (!(false)) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+3292 +"): " + "false" + ""); } while (false); // not sure what to do here... throw?
                }
                x=w[l]; /* Shift from bottom 2-by-2 minor. */
                nm=k-1;
                y=w[nm];
                g=rv1[nm];
                h=rv1[k];
                f=((y-z)*(y+z)+(g-h)*(g+h))/(2.0*h*y);
                g=Math.hypot(f,1.0);
                f=((x-z)*(x+z)+h*((y/(f+((f) >= 0.0 ? Math.abs(g) : -Math.abs(g))))-h))/x;
                c=s=1.0; /* Next QR transformation: */
                for (j=l;j<=nm;j++) {
                    i=j+1;
                    g=rv1[i];
                    y=w[i];
                    h=s*g;
                    g=c*g;
                    z=Math.hypot(f,h);
                    rv1[j]=z;
                    c=f/z;
                    s=h/z;
                    f=x*c+g*s;
                    g = g*c-x*s;
                    h=y*s;
                    y *= c;
                    for (jj=0;jj<n;jj++) {
                        x=v[jj][j];
                        z=v[jj][i];
                        v[jj][j]=x*c+z*s;
                        v[jj][i]=z*c-x*s;
                    }
                    z=Math.hypot(f,h);
                    w[j]=z; /* Rotation can be arbitrary if z = 0. */
                    if (z != 0.) {
                        z=1.0/z;
                        c=f*z;
                        s=h*z;
                    }
                    f=c*g+s*y;
                    x=c*y-s*g;
                    for (jj=0;jj<m;jj++) {
                        y=a[jj][j];
                        z=a[jj][i];
                        a[jj][j]=y*c+z*s;
                        a[jj][i]=z*c-y*s;
                    }
                }
                rv1[l]=0.0;
                rv1[k]=f;
                w[k]=x;
            }
        }
    } // svdcmp

    /** svdcmp and svdcmpPolish, non-destructive.  Input may not be any of the outputs. */
    public static void SVD(double[][] M, // input
                           int m,
                           int n,
                           double[][] U, // output (may equal M)
                           double[] d, // output
                           double[][] V, // output (may equal M, but not U)
                           boolean force_positive_rotations)
    {
      do { if (!(U != M)) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+3355 +"): " + "U != M" + ""); } while (false);
      do { if (!(V != M)) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+3356 +"): " + "V != M" + ""); } while (false);
      do { if (!(V != U)) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+3357 +"): " + "V != U" + ""); } while (false);
      copymat(U, M); // since svdcmp operates in place
      svdcmp(U, m, n, d, V);
      svdcmpPolish(U, m, n, d, V, force_positive_rotations);
    } // SVD

    /** Find the best fit column-oriented homogeneous rotation and translation matrix
    * that takes point cloud A to point cloud B.  The translation part matches the centroids,
    * and the rotation part is the procrustes rotation.  This is used by the more convenient
    * {@link #bestFitRotatedAndTranslated}.
    * See https://en.wikipedia.org/wiki/Procrustes_analysis .
    */
    public static double[][] findColumnOrientedProcrustesRotationAndTranslation(double[][] A, double[][] B)
    {
      int n = A.length;
      int dim = A[0].length;
      do { if (!((n)==(B.length))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+3373 +"): (" + "n" + ")" + "==" + "(" + "B.length" + ") ("+(n)+" vs. "+(B.length)+")"); } while (false);
      do { if (!((dim)==(B[0].length))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+3374 +"): (" + "dim" + ")" + "==" + "(" + "B[0].length" + ") ("+(dim)+" vs. "+(B[0].length)+")"); } while (false);
      double[] Acentroid = VecMath.average(A);
      double[] Bcentroid = VecMath.average(B);
      double[][] crossCovarianceMatrix = new double[dim][dim];
      double[] a = new double[dim]; // scratch;
      double[] b = new double[dim]; // scratch;
      double[][] oneOuterProduct = new double[dim][dim]; // scratch;
      for (int i = 0; i < n; ++i) {
        VecMath.vmv(a, A[i], Acentroid);
        VecMath.vmv(b, B[i], Bcentroid);
        VecMath.outerProduct(oneOuterProduct, a, b);
        VecMath.mpm(crossCovarianceMatrix, crossCovarianceMatrix, oneOuterProduct);
      }
      // Compute the SVD.
      double[][] U = new double[dim][dim]; // LHS
      double[] d = new double[dim]; // middle diagonal part
      double[][] V = new double[dim][dim]; // transpose of RHS
      VecMath.SVD(crossCovarianceMatrix, dim, dim, U, d, V, /*force_positive_rotations=*/true);
      double[][] rotationPart = VecMath.mxtransposem(U, V);

      // XXX FUDGE: this seems to make it come out right.  So evidently I have something backwards.
      rotationPart = VecMath.transpose(rotationPart);

      double[][] rotationAndTranslation = new double[dim+1][dim+1]; // zeros
      for (int i = 0; i < dim; ++i) {
        for (int j = 0; j < dim; ++j) {
          rotationAndTranslation[i][j] = rotationPart[i][j];
        }
      }
      for (int i = 0; i < dim; ++i) {
        rotationAndTranslation[i][dim] = Bcentroid[i] - Acentroid[i];
      }
      rotationAndTranslation[dim][dim] = 1.;
      return rotationAndTranslation;
    } // findColumnOrientedProcrustesRotationAndTranslation

    /** Returns point cloud A rotated and translated so that it matches point cloud B
    * as closely as possible, by matching centers and using a procrustes rotation.
    * See https://en.wikipedia.org/wiki/Procrustes_analysis .
    */
    public static double[][] bestFitRotatedAndTranslated(double[][] A, double[][] B)
    {
        int n = A.length;
        int dim = A[0].length;
        do { if (!((n)==(B.length))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+3418 +"): (" + "n" + ")" + "==" + "(" + "B.length" + ") ("+(n)+" vs. "+(B.length)+")"); } while (false);
        do { if (!((dim)==(B[0].length))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+3419 +"): (" + "dim" + ")" + "==" + "(" + "B[0].length" + ") ("+(dim)+" vs. "+(B[0].length)+")"); } while (false);
        double[][] columnOrientedRotationAndTranslation = findColumnOrientedProcrustesRotationAndTranslation(A, B);
        double[][] answer = new double[n][dim];
        for (int i = 0; i < n; ++i) {
            VecMath.mxv(answer[i], columnOrientedRotationAndTranslation, A[i]);
        }
        return answer;
    }

    public static void testProcrustes()
    {
        System.out.println("    in testProcrustes");
        // Very minimal test of bestFitRotatedAndTranslated.  It seems to work.
        // square in xy plane
        double A[][] = {
            {1,0,0},
            {0,1,0},
            {-1,0,0},
            {0,-1,0},
        };
        // square in xz plane, at y=3
        double B[][] = {
            {1,3,0},
            {0,3,-1},
            {-1,3,0},
            {0,3,1},
        };
        System.out.println("        " + "A" + " =\n" + VecMath.toString(A));
        System.out.println("        " + "B" + " =\n" + VecMath.toString(B));
        // xform should be:
        //  rotate 90 around x axis (i.e. y goes to z)
        //  translate by 0,3,0
        // that is:
        //  1  0  0  0
        //  0  0 -1  3
        //  0  1  0  0
        //  0  0  0  1
        double[][] xform = findColumnOrientedProcrustesRotationAndTranslation(A, B);
        System.out.println("        " + "xform" + " =\n" + VecMath.toString(xform));
        double[][] Axformed = bestFitRotatedAndTranslated(A, B);
        System.out.println("        " + "Axformed" + " =\n" + VecMath.toString(Axformed));
        do { if (!(VecMath.equals(Axformed, B, 1e-12))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+3460 +"): " + "VecMath.equals(Axformed, B, 1e-12)" + ""); } while (false);
        System.out.println("    out testProcrustes");
    } // testProcrustes



    /** Polish results of svdcmp:
    * - put singular values in order of decreasing magnitude
    * - make sure both U and V have positive determinant.
    *   If not, adjust (XXX possibly by negating the smallest singular value? possibly by swapping columns? possibly by negating a column? have to think)
    */
    public static void svdcmpPolish(double[][] U, int m, int n, final double d[], double V[][], boolean force_positive_rotations)
    {
        // TODO: can we relax some of these?  or maybe just get rid of m and n?
        do { if (!((U.length)==(m))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+3474 +"): (" + "U.length" + ")" + "==" + "(" + "m" + ") ("+(U.length)+" vs. "+(m)+")"); } while (false);
        do { if (!(m==0 || U[0].length == n)) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+3475 +"): " + "m==0 || U[0].length == n" + ""); } while (false);
        do { if (!((m)>=(n))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+3476 +"): (" + "m" + ")" + ">=" + "(" + "n" + ") ("+(m)+" vs. "+(n)+")"); } while (false);
        do { if (!((d.length)==(n))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+3477 +"): (" + "d.length" + ")" + "==" + "(" + "n" + ") ("+(d.length)+" vs. "+(n)+")"); } while (false);
        do { if (!((V.length)==(n))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+3478 +"): (" + "V.length" + ")" + "==" + "(" + "n" + ") ("+(V.length)+" vs. "+(n)+")"); } while (false);
        do { if (!(n==0 || V[0].length == n)) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+3479 +"): " + "n==0 || V[0].length == n" + ""); } while (false);

        do { if (!((m)==(n))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+3481 +"): (" + "m" + ")" + "==" + "(" + "n" + ") ("+(m)+" vs. "+(n)+")"); } while (false); // TODO: haven't thought about non-square case, yet.

        {
            int[] order = identityperm(d.length);
            SortStuff.sort(order, new SortStuff.IntComparator() {
                @Override public int compare(int i, int j) {
                    return d[i] < d[j] ? 1 : d[i] > d[j] ? -1 : 0; // backwards, for decreasing
                }
            });
            double[] scratch = new double[d.length];
            for (int i = 0; i < d.length; ++i) scratch[i] = d[order[i]];
            copyvec(d, scratch);
            for (int iRow = 0; iRow < U.length; ++iRow) {
              for (int i = 0; i < d.length; ++i) {
                scratch[i] = U[iRow][order[i]];
              }
              copyvec(U[iRow], scratch);
            }
            for (int iRow = 0; iRow < V.length; ++iRow) {
              for (int i = 0; i < d.length; ++i) {
                scratch[i] = V[iRow][order[i]];
              }
              copyvec(V[iRow], scratch);
            }
            int sign = permutationSignDestructive(order);
            if (sign < 0) {
                // we just reflected both U and V.
                // undo that by negating last column of each.
                // XXX is this legit?  does it even matter?  they aren't guaranteed to be positive anyway
                for (int iRow = 0; iRow < U.length; ++iRow) {
                    U[iRow][U[iRow].length-1] *= -1.;
                }
                for (int iRow = 0; iRow < V.length; ++iRow) {
                    V[iRow][V[iRow].length-1] *= -1.;
                }
            }
        }
        {
            double detU = det(U);
            double detV = det(V);
            do { if (!(((((Math.abs(detU))-(1.)) <= (1e-12)) && (((1.)-(Math.abs(detU))) <= (1e-12))))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+3521 +"): " + "EQ(Math.abs(detU), 1., 1e-12)" + ""); } while (false);
            do { if (!(((((Math.abs(detV))-(1.)) <= (1e-12)) && (((1.)-(Math.abs(detV))) <= (1e-12))))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+3522 +"): " + "EQ(Math.abs(detV), 1., 1e-12)" + ""); } while (false);
            if (detU < 0. || detV < 0.) {
                if (detU < 0. && detV < 0.) {
                    // Both U and V are reflections.
                    // This happens sometimes, even if all SVs were positive, distinct, and in order.
                    // XXX or does it? didn't we gratuitously reverse sign of both U and V?  yeah, I think so, oh well.
                    // It can be fixed by simply negating the last column of each.
                    for (int iRow = 0; iRow < U.length; ++iRow) {
                        U[iRow][U[iRow].length-1] *= -1.;
                    }
                    for (int iRow = 0; iRow < V.length; ++iRow) {
                        V[iRow][V[iRow].length-1] *= -1.;
                    }
                } else if (detU < 0.) {
                    //if (force_positive_rotations) {  // XXX tolerance? in which case would we force it to 0 rather than negating?
                    if (force_positive_rotations || d[d.length-1] == 0.) { // XXX tolerance? in which case would we force it to 0 rather than negating?
                        for (int iRow = 0; iRow < U.length; ++iRow) {
                            U[iRow][U[iRow].length-1] *= -1.;
                        }
                        //d[d.length-1] = 0.;  // make it exact
                        d[d.length-1] *= -1.;
                        // XXX I'm conflicted here.  on one hand, this is the way to make the product come out right.  on the other hand, it can introduce an actually slightly negative sv, when in fact the original didn't have any
                    }
                } else if (detV < 0.) {
                    //if (force_positive_rotations) {  // XXX tolerance? in which case would we force it to 0 rather than negating?
                    if (force_positive_rotations || d[d.length-1] == 0.) { // XXX tolerance? in which case would we force it to 0 rather than negating?
                        for (int iRow = 0; iRow < V.length; ++iRow) {
                            V[iRow][V[iRow].length-1] *= -1.;
                        }
                        //d[d.length-1] = 0.;  // make it exact
                        d[d.length-1] *= -1.;
                        // XXX I'm conflicted here.  on one hand, this is the way to make the product come out right.  on the other hand, it can introduce an actually slightly negative sv, when in fact the original didn't have any
                    }
                }
            }
            detU = det(U);
            detV = det(V);
            do { if (!(detU > 0. || detV > 0.)) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+3559 +"): " + "detU > 0. || detV > 0." + ""); } while (false); // not both negative, or we would have fixed
            if (force_positive_rotations || (d.length >= 1 && d[d.length-1] == 0.)) {
                do { if (!(((((detU)-(1.)) <= (1e-12)) && (((1.)-(detU)) <= (1e-12))))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+3561 +"): " + "EQ(detU, 1., 1e-12)" + ""); } while (false);
                do { if (!(((((detV)-(1.)) <= (1e-12)) && (((1.)-(detV)) <= (1e-12))))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+3562 +"): " + "EQ(detV, 1., 1e-12)" + ""); } while (false);
            }
        }
    } // svdcmpPolish


    /** Return the singular values of the matrix M. */
    // XXX TODO: reimplement this now that we have an SVD function!
    public static double[] singularValues(double M[][])
    {
        // XXX TODO: should do it the smaller of the two ways, I think
        double MM[][] = mxtransposem(M,M); // gets destroyed
        double d[] = new double[MM.length];
        double VthrowAway[][] = new double[MM.length][MM.length];
        jacobi(MM, d, VthrowAway);
        return d;
    }
    /** Return the condition number (ratio of max and min singular values) of M, which need not be symmetric. */
    public static double conditionNumber(double M[][])
    {
        double singularValues[] = singularValues(M);
        return Math.sqrt(max(singularValues)/min(singularValues));
    }

    /** Find a matrix L such that L*transpose(L) = C. */
    public static int leftSqrtOfSymmetricMatrix(double result[][], boolean whichColumnsOfResultAreImaginary[], double C[][])
    {
        int n = C.length; // == C[0].length
        do { if (!((n)==(result.length))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+3590 +"): (" + "n" + ")" + "==" + "(" + "result.length" + ") ("+(n)+" vs. "+(result.length)+")"); } while (false);
        double eigenValues[] = new double[n];
        double eigenVectors[][] = new double[n][n]; // columns
        double temp[][] = copymat(C); // since jacobi is destructive
        int nRot = jacobi(temp, eigenValues, eigenVectors); // XXX not the most efficient when n is big (they say 10 or so)
        if (nRot < 0)
        {
            // it failed; not much we can do
            // XXX should return a more useful failure status though
            if (result != null)
                identitymat(result);
            return -2;
        }

        if (true)
        {
            // check that it worked, i.e. that
            //     C * eigenvectors = eigenVectors * diag(eigenValues)
            double diagEigenValues[][] = identitymat(n);
            int i;
            for (i = 0; (i) < (n); ++i)
                diagEigenValues[i][i] = eigenValues[i];
            double A[][] = mxm(C, eigenVectors);
            double B[][] = mxm(eigenVectors, diagEigenValues);
            //PRINTMAT(C);
            //PRINTVEC(eigenValues);
            //PRINTMAT(eigenVectors);
            //PRINTMAT(A);
            //PRINTMAT(B);
            int j;
            for (i = 0; (i) < (n); ++i)
            for (j = 0; (j) < (n); ++j)
                do { if (!((1. + ((A[i][j]-B[i][j])*(A[i][j]-B[i][j])))==(1.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+3622 +"): (" + "1. + ((A[i][j]-B[i][j])*(A[i][j]-B[i][j]))" + ")" + "==" + "(" + "1." + ") ("+(1. + ((A[i][j]-B[i][j])*(A[i][j]-B[i][j])))+" vs. "+(1.)+")"); } while (false);
        }

        // XXX if result is null, shouldn't do the sqrts and stuff in the
        // XXX following loop

        /*
        PRINTVEC(eigenValues);
        PRINTMAT(eigenVectors);
        */

        //PRINT(nRot);

        int positiveDefiniteStatus = 1; // positive semidefinite until proven otherwise
        int i;
        for (i = 0; (i) < (n); ++i)
        {
            double eigenValue = eigenValues[i];
            if (1.+((eigenValue)*(eigenValue)) == 1.)
                positiveDefiniteStatus = ((positiveDefiniteStatus)<=(0)?(positiveDefiniteStatus):(0)); // borderline
            else if (eigenValue < 0.)
                positiveDefiniteStatus = -1; // definitely not positive semidefinite

            double sqrtEigenValue;
            if (whichColumnsOfResultAreImaginary != null)
            {
                if ((whichColumnsOfResultAreImaginary[i] = (eigenValue < 0.)) == true)
                    sqrtEigenValue = Math.sqrt(-eigenValue);
                else
                    sqrtEigenValue = Math.sqrt(eigenValue);
            }
            else
                sqrtEigenValue = Math.sqrt(((eigenValue)>=(0.)?(eigenValue):(0.)));

            // multiply column i by corrected eigenValue...
            int j;
            for (j = 0; (j) < (n); ++j)
                eigenVectors[j][i] *= sqrtEigenValue;
        }

        copymat(result, eigenVectors);
        return positiveDefiniteStatus;
    } // leftSqrtOfSymmetricMatrix

    /**
     * From paper "The most general methodology to create a valid
     * correlation matrix for risk management and option pricing purposes"
     * by Riccardo Rebonato and Peter Jackel, October 19, 1999.
     * <p>
     * Returns -1 if it changed, 0 if on boundary (within some fuzzy tolerance),
     * 1 if it didn't change.
     * C is assumed to be symmetric and have 1's on the diagonal.
     * <p>
     * XXX maybe should just return the smallest eigenvalue before correction?
     *     then the caller can decide what to do with it.
     */
    public static int positiveSemiDefinitizeWithUnitDiagonal(double result[][], boolean whichColumnsAreImaginary[], double C[][])
    {
        double B[][] = new double[result.length][result.length];
        int positiveDefiniteStatus = leftSqrtOfSymmetricMatrix(B, whichColumnsAreImaginary, C);
        if (positiveDefiniteStatus == -2)
        {
            // failed. XXX throw an exception?
            identitymat(result);
        }
        else
        {
            if (whichColumnsAreImaginary == null)
                correlate(result, B);
        }
        return positiveDefiniteStatus;
    } // positiveSemiDefinitizeWithUnitDiagonal

    /**
     * XXX this is not used; I'm pretty sure it core dumps.
     * <p>
     * -1 = not positive semidefinite
     * <br>
     * 0 = positive semidefinite but not positive definite (within some fuzz)
     * <br>
     * 1 = positive definite
     */
    public static int positiveDefiniteness(double M[][])
    {
        return positiveSemiDefinitizeWithUnitDiagonal(null, null, M);
    }

    /** return the correlation matrix of the rows of V. */
    public static void correlate(double result[][], double V[][])
    {
        double normalizedV[][] = new double[V.length][V.length==0?0:V[0].length];
        normalizeRows(normalizedV, V);
        mxm(result, normalizedV, transpose(normalizedV));
    } // correlate

    /** sets result matrix to M with each row normalized. */
    public static void normalizeRows(double result[][], double M[][])
    {
        int i, n = M.length;
        for (i = 0; (i) < (n); ++i)
            normalize(result[i], M[i]);
    }

    /** Normalize a vector, returning the previous length. */
    public static double normalize(int n, double result[], double v[])
    {
        double len = norm(n, v);
        if (len == 0)
        {
            zerovec(n, result);
            if (n >= 1)
                result[0] = (double)1;
        }
        else
            vxs(n, result, v, (double)1/len);
        return len;
    }
    /** Normalize a vector, returning the previous length. */
    public static double normalize(double result[], double v[])
    {
        return normalize(((result.length)<=(v.length)?(result.length):(v.length)), result, v);
    }
    /** Normalize a vector, returning the previous length. In case previous length was <= tol, zero the vector and return zero. */
    public static double normalizeOrZero(int n, double result[], double v[], double tol)
    {
        double len = norm(n, v);
        if (len <= tol)
        {
            zerovec(n, result);
            len = 0;
        }
        else
            vxs(n, result, v, (double)1/len);
        return len;
    }
    /** Normalize a vector, returning the previous length. In case previous length was <= tol, zero the vector and return zero. */
    public static double normalizeOrZero(double result[], double v[], double tol)
    {
        return normalizeOrZero(((result.length)<=(v.length)?(result.length):(v.length)), result, v, tol);
    }
    /** Normalize a vector, returning the previous length. */
    public static float normalize(int n, float result[], float v[])
    {
        float len = norm(n, v);
        if (len == 0.f)
        {
            zerovec(n, result);
            if (result.length >= 1)
                result[0] = (float)1;
        }
        else
            vxs(n, result, v, (float)1/len);
        return len;
    }
    /** Normalize a vector, returning the previous length. */
    public static float normalize(float result[], float v[])
    {
        return normalize(((result.length)<=(v.length)?(result.length):(v.length)), result, v);
    }
    /** Normalize a vector, returning the previous length. In case previous length was <= tol, zero the vector and return zero. */
    public static float normalizeOrZero(int n, float result[], float v[], float tol)
    {
        float len = norm(n, v);
        if (len <= tol)
        {
            zerovec(n, result);
            len = 0;
        }
        else
            vxs(n, result, v, (float)1/len);
        return len;
    }
    /** Normalize a vector, returning the previous length. In case previous length was <= tol, zero the vector and return zero. */
    public static float normalizeOrZero(float result[], float v[], float tol)
    {
        return normalizeOrZero(((result.length)<=(v.length)?(result.length):(v.length)), result, v, tol);
    }

    /**
    * Helper function for LQdecomposition:
    * Householder Vector algorithm
    * from Golub&Van Loan page 210, Algorithm 5.1.1.
    * Given vector v, computes vector h and returns scalar beta
    * such that the first entry of h is 1
    * and P = I - beta h h^T is orthogonal
    * and P v == (||v||, 0, 0, ...)
    * i.e. P reflects v to the nonnegative x axis.
    * beta will be 2/||h||^2,
    * except when v is already a *non-negative* multiple of the x axis,
    * in which case it will be zero,
    * making P the identity matrix instead of a reflection).
    * (The function in the book returns beta=0
    * even when v is a *negative* multiple of the x axis;
    * that doesn't seem right to me since it violates
    * the principle that P should send v to the non-negative x axis
    * in every case, which is required by the caller.)
    * Important: this function overwrites v with h,
    * but it does NOT fill in the 1 into the first entry of h.
    * instead, it puts the original ||v|| there.
    */
    private static double house(
        int n, // dimension of subvector of interest in v and in destination h
        double v[], int i0) // source v, (and dest h) and starting index
    {
        if (n < 1)
            return 0.;
        double sigma = 0.; // for starters
        for (int i = 1; i < n; ++i) // all but 0
            sigma += ((v[i0+i])*(v[i0+i]));
        double v0 = v[i0];
        double h[] = v; // use same storage
        double beta;
        if (sigma == 0.)
        {
            // Note, the following isn't strictly necessary
            // since all those entries should be zero already anyway,
            // since the sum of their squares is zero...
            // however there might be cases when they hold very tiny values
            // whose squares turned out to be zero numerically,
            // so we set them to zero
            // here to be safe.
            for (int i = 1; i < n; ++i) // all but 0
                h[i0+i] = 0.;
            if (v0 < 0.)
            {
                beta = 2.;
                h[i0] = -v0; // i.e. ||v||
            }
            else
            {
                // not a reflection, the identity xform instead
                beta = 0.;
                // and leave h[0] alone, it's already ||v||
            }
        }
        else
        {
            double lenV = Math.sqrt(((v0)*(v0)) + sigma);
            double h0;
            if (v0 <= 0.)
                h0 = v0 - lenV;
            else
                h0 = -sigma/(v0 + lenV);
            beta = 2. * ((h0)*(h0)) / (sigma + ((h0)*(h0)));
            for (int i = 1; i < n; ++i) // all but 0
                h[i0+i] /= h0;
            // per contract, omit the 1 in h[i0], put ||v|| there instead
            h[i0] = lenV;
        }
        return beta;
    } // house

    /**
    * QR decomposition from Golub & Van Loan,
    * but we do LQ decomposition instead since we like to think
    * in terms of row vectors instead of column vectors.
    *
    * The LQ decomposition of a matrix A (nCols >= nRows)
    * is a decomposition A = L*Q
    * where L is lower triangular and Q is orthogonal.
    * L has the same dimensionality as A (nRows x nCols)
    * and Q is square with the larger dimension (nCols x nCols).
    * One use of this is to orthogonalize a set of vectors:
    * the first nRows rows of Q will be an orthogonal basis
    * for the row space of A, and the remaining rows of Q
    * will extend that basis orthogonally.
    *
    * This function is to be used on the result of LQdecompositionCompressed.
    */
    public static void uncompressLQdecomposition(int nRows, int nCols, // in compressed and in L... Q can have more (or fewer) rows than this
                                                 double compressed[/*nRows*/][/*nCols*/],
                                                 double betas[/*nRows*/],
                                                 double det, // -1 iff the composition of the householder reflections amount to a reflection rather than a rotation
                                                 double L[/*nRows*/][/*nCols*/],
                                                 double Q[/*<=nCols*/][/*nCols*/])
    {
        if (L != null)
            for (int iRow = 0; (iRow) < (nRows); ++iRow)
            for (int iCol = 0; (iCol) < (nCols); ++iCol)
                L[iRow][iCol] = (iCol <= iRow ? compressed[iRow][iCol]
                                              : 0.);
        if (Q != null)
        {
            for (int iRowInQ = 0; (iRowInQ) < (((Q.length)<=(nCols)?(Q.length):(nCols))); ++iRowInQ)
            {
                // Start Q[iRowInQ] to be the iRowInQ'th canonical unit basis vector
                zerovec(Q[iRowInQ]); Q[iRowInQ][iRowInQ] = 1.;

                // Apply the householder vectors and betas in order
                // from end to start.
                // The ones after iRowInQ
                // are irrelevant since they will just be pushing zeros around.
                for (int iH = ((iRowInQ)<=(nRows-1)?(iRowInQ):(nRows-1)); iH >= 0; --iH)
                {
                    double h[] = compressed[iH];
                    double beta = betas[iH];
                    // Q[iRowInQ] -= beta * (Q[iRowInQ] dot h) * h
                    double dotProduct = Q[iRowInQ][iH]; // times h[iH] which is implicity 1
                    for (int iCol = iH+1; iCol < nCols; ++iCol)
                        dotProduct += Q[iRowInQ][iCol] * h[iCol];

                    double betaTimesDotProduct = beta * dotProduct;
                    Q[iRowInQ][iH] -= betaTimesDotProduct; // times h[iH] which is implicitly 1
                    for (int iCol = iH+1; iCol < nCols; ++iCol) // all but iH
                        Q[iRowInQ][iCol] -= betaTimesDotProduct * h[iCol];
                }
            }
            if (det < 0. && Q.length >= nCols)
            {
                // Q is square; fix its determinant to be positive if we can,
                // namely if A is less than full rank.
                if (nRows < nCols)
                    vxs(Q[nRows], Q[nRows], -1.); // negate the row of Q
                else
                {
                    // If any diagonal entry of L is zero,
                    // we can negate that column of L and that row of Q.
                    // This isn't watertight behavior (since
                    // something might be very close to zero) but it tries
                    // to make things a little friendlier
                    // by not returning a reflection when it's not necessary.
                    for (int iDiag = 0; (iDiag) < (nRows); ++iDiag)
                    {
                        if (compressed[iDiag][iDiag] == 0.) // compressed[iDiag][iDiag] is L[iDiag][iDiag], except L might be NULL
                        {
                            // negate the row of Q
                            vxs(Q[iDiag], Q[iDiag], -1.);
                            if (L != null)
                            {
                                // negate the column of L (above diagonal is zero)
                                for (int iRow = iDiag; iRow < nRows; ++iRow)
                                    L[iRow][iDiag] *= -1;
                            }
                            break;
                        }
                    }
                }
            }
        }
    } // uncompressLQdecomposition

    /**
    * The LQ decomposition is R^T Q^T where Q R is the QR decomposition of A^T.
    * The function returns -1 or 1 depending on whether the number of reflections done
    * odd or even.
    */
    public static int LQdecompositionCompressed(int nRows, int nCols, // use only first nRows and nCols of A
                                double A[/*nRows*/][/*nCols*/], // gets overwritten with the essential parts of R and Q as in the book, but transposed
                                double betas[/*nRows*/]) // gets filled with the corresponding betas, as in the book
    {
        if (!(nRows <= nCols))
            throw new IllegalArgumentException("LQdecompositionCompressed called with too many vectors");
        int determinant = 1;
        for (int iRow = 0; (iRow) < (nRows); ++iRow)
        {
            // we reuse the part of A[iRow] that we're about to zero out,
            // namely A[iRow][iRow+1..iCol],
            // to store (all but the first entry of) the householder vector h...
            double beta = house(nCols-iRow,
                                A[iRow], iRow); // A[iRow] starting at col iRow
            double h[] = A[iRow]; // that's where h got put
            if (betas != null)
                betas[iRow] = beta;

            // For row iRow, the "essential part" of the householder vector
            // got put into indices iRow+1..nCols-1 (replacing the entries
            // that were going to zeroed out anyway).
            // As for A[iRow][iRow],
            // the contract of h and beta
            // is that they send A[iRow][iRow..nCols-1] to
            // its (non-negative) length times the first axis,
            // so A[iRow][iRow] should get set to the original length
            // of A[iRow][iRow..nCols-1],
            // and that's exactly what house() already did.
            // So A[iRow] is exactly right.

            // for the remaining rows...
            for (int jRow = iRow+1; jRow < nRows; ++jRow)
            {
                // A[jRow][iRow..nCols-1] -= beta * (... dot h) * h
                double AjRow[] = A[jRow];
                double dotProduct = AjRow[iRow]; // times h[iRow] which is implicitly 1
                for (int iCol = iRow+1; iCol < nCols; ++iCol) // all but iRow
                    dotProduct += AjRow[iCol] * h[iCol];
                double betaTimesDotProduct = beta * dotProduct;

                AjRow[iRow] -= betaTimesDotProduct; // times h[iRow] which is implicitly 1
                for (int iCol = iRow+1; iCol < nCols; ++iCol) // all but iRow
                    AjRow[iCol] -= betaTimesDotProduct * h[iCol];
                // we reuse the part of A[iRow] that we zeroed out,
                // namely A[iRow][iRow+1..iCol],
                // to store (all but the first entry of) the householder vector h...
            }
            if (beta != 0)
                determinant = -determinant;
        }

        return determinant;
    } // LQdecompositionCompressed



    /**
    * Extend the k vectors to n vectors and gramschmidt.
    * If the result is a square matrix and the original wasn't
    * (or was less than full rank),
    * make sure the result's determinant is +1, not -1.
    * Note, you should use extendAndOrthogonalize instead of this.
    */
    public static void extendAndGramSchmidt(int k, int n, double result[][], double vecs[][])
    {
        copymat(k, result, vecs);
        for (int i = k; i < n; ++i)
        {
            if (i == result[0].length-1)
                crossprod(result[i], result);
            else
            {
                zerovec(result[i]);
                result[i][mostOrthogonalAxis(i, result)] = 1;
            }
        }
        gramschmidt(n, result, result);
        //if (result.length > 0 && result[0].length == n) PRINT(det(result));
    } // extendAndGramSchmidt

    /**
    * Extend the k vectors to n vectors and orthogonalize
    * (by Householder orthogonalization, which is more robust than gram-schmidt).
    * If the result is a square matrix and the original wasn't
    * (or was less than full rank),
    * make sure the result's determinant is +1, not -1.
    */
    public static void extendAndOrthogonalize(int k, int n, double result[][], double vecs[][])
    {
        //System.out.println("    in extendAndOrthogonalize(k="+k+", n="+n+", dim="+(result.length==0 ? -1 : result[0].length)+"");
        if (n < 1)
            return; // we have no idea what dimension is and don't care
        do { if (!(0 <= k && k <= n && n <= result[0].length)) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+4060 +"): " + "0 <= k && k <= n && n <= result[0].length" + ""); } while (false);
        double scratch[][] = new double[k][result[0].length];
        copymat(k, scratch, vecs);
        double betas[] = new double[k];
        int det = LQdecompositionCompressed(k,
                                            result[0].length,
                                            scratch,
                                            betas);
        // result may have more than n rows, but uncompressLQdecomposition requires its result to have exactly the number of desired rows.  so make a scratch Q
        double Q[][] = new double[n][result[0].length];
        uncompressLQdecomposition(k, vecs[0].length,
                                  scratch,
                                  betas,
                                  det,
                                  null, // don't need L
                                  Q);
        copymat(n, result, Q);
        //System.out.println("    out extendAndOrthogonalize");
    } // extendAndOrthogonalize
    public static double[][] extendAndOrthogonalize(int k, int n, double vecs[][])
    {
        double result[][] = new double[n][vecs[0].length];
        extendAndOrthogonalize(k, n, result, vecs);
        return result;
    }


    /** Find the axis that is most orthogonal to the given k vectors. */
    public static int mostOrthogonalAxis(int k, double vecs[][])
    {
        if (vecs.length == 0)
            return 0;
        double mat[][] = new double[k+1][vecs[0].length];
        double matTransposed[][] = new double[vecs[0].length][k+1];
        double product[][] = new double[k+1][k+1];
        int bestAxis = -1;
        double bestAbsDet = -1.;
        copymat(k, mat, vecs); // same for all iterations
        for (int iAxis = 0; (iAxis) < (vecs[0].length); ++iAxis)
        {
            zerovec(mat[k]);
            mat[k][iAxis] = 1.;
            transpose(matTransposed, mat);
            mxm(product, mat, matTransposed);
            double det = detDestructive(product);
            double absDet = Math.abs(det);
            //PRINT(iAxis);
            //PRINTMAT(mat);
            //PRINTMAT(matTransposed);
            //PRINTMAT(product);
            //PRINT(absDet);
            if (absDet > bestAbsDet)
            {
                bestAbsDet = absDet;
                bestAxis = iAxis;
            }
        }
        //PRINT(k);
        //PRINTVEC(vecs[0]);
        //PRINTVEC(vecs[1]);
        //PRINT(bestAxis);
        return bestAxis;
    } // mostOrthogonalAxis

    /** Gram-Schmidt orthonormalize the first k rows of a matrix. */
    public static void gramschmidt(int k, double result[][], double M[][])
    {
        if (result != M)
            copymat(result, M);
        for (int i = 0; i < result.length; ++i)
        {
            for (int j = 0; j < i; ++j)
            {
                // result[j] is already unit length...
                // result[i] -= (result[i] dot result[j])*result[j]
                com.donhatchsw.util.VecMath.vpsxv(result[i],
                              result[i],
                              -com.donhatchsw.util.VecMath.dot(result[i],result[j]),
                              result[j]);
            }
            com.donhatchsw.util.VecMath.normalize(result[i], result[i]);
        }
    } // gramschmidt
    /** Gram-Schmidt orthonormalize the first k rows of a matrix. */
    public static void gramschmidt(int k, float result[][], float M[][])
    {
        if (result != M)
            copymat(result, M);
        for (int i = 0; i < result.length; ++i)
        {
            for (int j = 0; j < i; ++j)
            {
                // result[j] is already unit length...
                // result[i] -= (result[i] dot result[j])*result[j]
                com.donhatchsw.util.VecMath.vpsxv(result[i],
                              result[i],
                              -com.donhatchsw.util.VecMath.dot(result[i],result[j]),
                              result[j]);
            }
            com.donhatchsw.util.VecMath.normalize(result[i], result[i]);
        }
    } // gramschmidt
    /** Gram-Schmidt orthonormalize a matrix. */
    public static void gramschmidt(double result[][], double M[][])
    {
        gramschmidt(((result.length)<=(M.length)?(result.length):(M.length)), result, M);
    } // gramschmidt
    /** Gram-Schmidt orthonormalize a matrix. */
    public static void gramschmidt(float result[][], float M[][])
    {
        gramschmidt(((result.length)<=(M.length)?(result.length):(M.length)), result, M);
    } // gramschmidt


    /* XXX can we make a general method that takes any kind of array? yes, @see Arrays class */
    public static String toString(boolean v[])
    {
        if (v == null)
            return "(null)";
        int i, n = v.length;
        String result = "<";
        for (i = 0; (i) < (n); ++i)
        {
            result += v[i];
            if (i < n-1)
                result += ",";
        }
        result += ">";
        return result;
    }
    public static String toString(int v[])
    {
        if (v == null)
            return "(null)";
        int i, n = v.length;
        String result = "<";
        for (i = 0; (i) < (n); ++i)
        {
            result += v[i];
            if (i < n-1)
                result += ",";
        }
        result += ">";
        return result;
    }

    public static String toString(long v[])
    {
        if (v == null)
            return "(null)";
        int i, n = v.length;
        String result = "<";
        for (i = 0; (i) < (n); ++i)
        {
            result += v[i];
            if (i < n-1)
                result += ",";
        }
        result += ">";
        return result;
    }
    public static String toString(double v[])
    {
        if (v == null)
            return "(null)";
        int i, n = v.length;
        String result = "<";
        for (i = 0; (i) < (n); ++i)
        {
            result += v[i];
            if (i < n-1)
                result += ",";
        }
        result += ">";
        return result;
    }
    public static String toString(float v[])
    {
        if (v == null)
            return "(null)";
        int i, n = v.length;
        String result = "<";
        for (i = 0; (i) < (n); ++i)
        {
            result += v[i];
            if (i < n-1)
                result += ",";
        }
        result += ">";
        return result;
    }
    public static String toString(Object v[])
    {
        if (v == null)
            return "(null)";
        int i, n = v.length;
        String result = "<";
        for (i = 0; (i) < (n); ++i)
        {
            result += v[i]==null ? "(null)" : v[i].toString();
            if (i < n-1)
                result += ",";
        }
        result += ">";
        return result;
    }

    public static String toString(double m[][])
    {
        return Arrays.toStringNonCompact(m, "", "    ");
    }

    public static String toString(float m[][])
    {
        return Arrays.toStringNonCompact(m, "", "    ");
    }
    public static String toString(int m[][])
    {
        return Arrays.toStringNonCompact(m, "", "    ");
    }
    public static String toString(long m[][])
    {
        return Arrays.toStringNonCompact(m, "", "    ");
    }
    public static String toString(boolean m[][])
    {
        return Arrays.toStringNonCompact(m, "", "    ");
    }
    public static String toString(Object m[][])
    {
        return Arrays.toStringNonCompact(m, "", "    ");
    }

    /* XXX convert this to Arrays.toString! */
    public static String toString(int m[][][], String bigSep, String littleSep)
    {
        if (m == null)
            return "(null)";
        String result = "";
        int iLayer, nLayers = m.length;
        for (iLayer = 0; (iLayer) < (nLayers); ++iLayer)
        {
            int iRow, nRows = m[iLayer].length;
            for (iRow = 0; (iRow) < (nRows); ++iRow)
            {
                result += "    [";
                int iCol, nCols = m[iLayer][iRow].length;
                for (iCol = 0; (iCol) < (nCols); ++iCol)
                {
                    result += m[iLayer][iRow][iCol];
                    if (iCol+1 < nCols)
                        result += " ";
                }
                result += "]";
                if (iRow+1 < nRows)
                    result += littleSep;
            }
            if (iLayer+1 < nLayers)
                result += bigSep;
        }
        return result;
    } // toString(int [][][])
    public static String toString(int m[][][])
    {
        return toString(m, "\n\n", "\n");
        //return toString(m, "\n", "");
    } // toString(int [][][])


    // Versions which return a newly allocated array...
    // These are more convenient but slower,
    // and should not be called in compute-intensive inner loops.
    // XXX JAVADOC GROUP

        /** vector plus vector, returning newly allocated result */
        public static double[] vpv(double v0[], double v1[])
        {
            double result[] = new double[v0.length];
            vpv(result, v0, v1);
            return result;
        }
        /** vector plus vector, returning newly allocated result */
        public static float[] vpv(float v0[], float v1[])
        {
            float result[] = new float[v0.length];
            vpv(result, v0, v1);
            return result;
        }
        /** vector plus vector, returning newly allocated result */
        public static int[] vpv(int v0[], int v1[])
        {
            int result[] = new int[v0.length];
            vpv(result, v0, v1);
            return result;
        }
        /** scalar times vector, returning newly allocated result */
        public static double[] sxv(int n, double s, double v[])
        {
            double result[] = new double[n];
            sxv(n, result, s, v);
            return result;
        }
        /** scalar times vector, returning newly allocated result */
        public static double[] sxv(double s, double v[])
        {
            return sxv(v.length, s, v);
        }
        /** scalar times vector, returning newly allocated result */
        public static float[] sxv(int n, float s, float v[])
        {
            float result[] = new float[n];
            sxv(n, result, s, v);
            return result;
        }
        /** scalar times vector, returning newly allocated result */
        public static float[] sxv(float s, float v[])
        {
            return sxv(v.length, s, v);
        }
        /** scalar times vector, returning newly allocated result */
        public static int[] sxv(int n, int s, int v[])
        {
            int result[] = new int[n];
            sxv(n, result, s, v);
            return result;
        }
        /** scalar times vector, returning newly allocated result */
        public static int[] sxv(int s, int v[])
        {
            return sxv(v.length, s, v);
        }
        public static double[] normalize(double v[])
        {
            double result[] = new double[v.length];
            normalize(result, v);
            return result; // XXX should return NULL on failure?  Not sure
        }
        public static double[] normalizeOrZero(double v[], double tol)
        {
            double result[] = new double[v.length];
            normalizeOrZero(result, v, tol);
            return result;
        }
        public static float[] normalize(float v[])
        {
            float result[] = new float[v.length];
            normalize(result, v);
            return result; // XXX should return NULL on failure?  Not sure
        }
        public static float[] normalizeOrZero(float v[], float tol)
        {
            float result[] = new float[v.length];
            normalizeOrZero(result, v, tol);
            return result;
        }

        /** v0 as a single-column matrix times v1 as a single-row matrix,
        * returning newly allocated result */
        public static double[][] outerProduct(double v0[], double v1[])
        {
            double result[][] = new double[v0.length][v1.length];
            outerProduct(result, v0, v1);
            return result;
        }
        /** perp dot, returning newly allocated result */
        public static double[] xv2(double v[/*2*/])
        {
            double result[] = new double[2];
            xv2(result, v);
            return result;
        }
        /** vector minus vector, returning newly allocated result */
        public static double[] vmv(int n, double v0[], double v1[])
        {
            double result[] = new double[n];
            vmv(n, result, v0, v1);
            return result;
        }
        /** vector minus vector, returning newly allocated result */
        public static float[] vmv(int n, float v0[], float v1[])
        {
            float result[] = new float[n];
            vmv(n, result, v0, v1);
            return result;
        }
        /** vector minus vector, returning newly allocated result */
        public static int[] vmv(int n, int v0[], int v1[])
        {
            int result[] = new int[n];
            vmv(n, result, v0, v1);
            return result;
        }
        /** vector minus vector, returning newly allocated result */
        public static double[] vmv(double v0[], double v1[])
        {
            double result[] = new double[v0.length];
            vmv(result, v0, v1);
            return result;
        }
        /** vector minus vector, returning newly allocated result */
        public static float[] vmv(float v0[], float v1[])
        {
            float result[] = new float[v0.length];
            vmv(result, v0, v1);
            return result;
        }
        /** vector minus vector, returning newly allocated result */
        public static int[] vmv(int v0[], int v1[])
        {
            int result[] = new int[v0.length];
            vmv(result, v0, v1);
            return result;
        }
        /** subtract v from each row of M, returning newly allocated result */
        public static int[][] mmv(int M[][], int v[])
        {
            int result[][] = new int[M.length][v.length];
            mmv(result, M, v);
            return result;
        }
        /** subtract v from each row of M, returning newly allocated result */
        public static double[][] mmv(double M[][], double v[])
        {
            double result[][] = new double[M.length][v.length];
            mmv(result, M, v);
            return result;
        }
        /** linear interpolation between vectors, returning newly allocated result */
        public static double[] lerp(double p0[], double p1[], double t)
        {
            double result[] = new double[p0.length];
            lerp(result, p0, p1, t);
            return result;
        }
        /** linear interpolation between vectors, returning newly allocated result */
        public static float[] lerp(float p0[], float p1[], float t)
        {
            float result[] = new float[p0.length];
            lerp(result, p0, p1, t);
            return result;
        }
        /** barycentric interpolation between vectors, returning newly allocated result */
        public static double[] bary(double p0[],
                                    double p1[], double t1,
                                    double p2[], double t2)
        {
            double result[] = new double[p0.length];
            bary(result, p0, p1, t1, p2, t2);
            return result;
        }
        /** return a new vector of zeros */
        public static double[] zerovec(int dim)
        {
            double result[] = new double[dim];
            zerovec(result);
            return result;
        }
        /** return a new vector filled with a given scalar */
        public static double[] fillvec(int dim, double s)
        {
            double result[] = new double[dim];
            fillvec(result,s);
            return result;
        }
        /** return a new vector filled with a given scalar */
        public static int[] fillvec(int dim, int s)
        {
            int result[] = new int[dim];
            fillvec(result,s);
            return result;
        }
        /** return a new vector filled with a given scalar */
        public static boolean[] fillvec(int dim, boolean s)
        {
            boolean result[] = new boolean[dim];
            fillvec(result,s);
            return result;
        }
        /** return a new matrix filled with a given scalar */
        public static double[][] fillmat(int dim0, int dim1, double s)
        {
            double result[][] = new double[dim0][dim1];
            fillmat(result,s);
            return result;
        }
        /** return a new matrix filled with a given scalar */
        public static int[][] fillmat(int dim0, int dim1, int s)
        {
            int result[][] = new int[dim0][dim1];
            fillmat(result,s);
            return result;
        }
        /** return a new matrix filled with a given scalar */
        public static boolean[][] fillmat(int dim0, int dim1, boolean s)
        {
            boolean result[][] = new boolean[dim0][dim1];
            fillmat(result,s);
            return result;
        }
        /** vector sum, returning newly allocated result */
        public static float[] sum(float array[][])
        {
            if (array.length == 0)
                return null;
            float result[] = new float[array[0].length];
            sum(result, array);
            return result;
        }
        /** vector sum, returning newly allocated result */
        public static double[] sum(double array[][])
        {
            if (array.length == 0)
                return null;
            double result[] = new double[array[0].length];
            sum(result, array);
            return result;
        }
        /** vector average, returning newly allocated result */
        public static double[] average(double array[][])
        {
            if (array.length == 0)
                return null;
            double result[] = new double[array[0].length];
            average(result, array);
            return result;
        }
        /** vector average indexed, returning newly allocated result */
        public static double[] averageIndexed(int inds[], double array[][])
        {
            if (array.length == 0)
                return null;
            double result[] = new double[array[0].length];
            averageIndexed(result, inds, array);
            return result;
        }
        /** vector average indexed, returning newly allocated result */
        public static float[] averageIndexed(int inds[], float array[][])
        {
            if (array.length == 0)
                return null;
            float result[] = new float[array[0].length];
            averageIndexed(result, inds, array);
            return result;
        }
        /** vector average indexed, returning newly allocated result */
        public static double[] averageIndexed(int inds[][], double array[][])
        {
            if (array.length == 0)
                return null;
            double result[] = new double[array[0].length];
            averageIndexed(result, inds, array);
            return result;
        }
        /** vector average indexed, returning newly allocated result */
        public static float[] averageIndexed(int inds[][], float array[][])
        {
            if (array.length == 0)
                return null;
            float result[] = new float[array[0].length];
            averageIndexed(result, inds, array);
            return result;
        }
        /** bbox indexed, returning newly allocated result */
        public static double[/*2*/][] bboxIndexed(double array[][],
                                                  Object inds)
        {
            if (array.length == 0)
                return null; // XXX could be dangerous
            double result[][] = new double[2][array[0].length];
            bboxIndexed(result, array, inds);
            return result;
        }
        /** uniform bounding box, returning newly allocated result */
        public static double[/*2*/][] bboxUniform(double array[][])
        {
            if (array.length == 0)
                return null; // XXX could be dangerous
            double result[][] = new double[2][array[0].length];
            bboxUniform(result, array);
            return result;
        }
        /** bounding box, returning newly allocated result */
        public static float[/*2*/][] bbox(float array[][])
        {
            if (array.length == 0)
                return null; // XXX could be dangerous
            float result[][] = new float[2][array[0].length];
            bbox(result, array);
            return result;
        }
        /** bounding box, returning newly allocated result */
        public static double[/*2*/][] bbox(double array[][])
        {
            if (array.length == 0)
                return null; // XXX could be dangerous
            double result[][] = new double[2][array[0].length];
            bbox(result, array);
            return result;
        }
        /** bounding box intersect, returning newly allocated result */
        public static double[/*2*/][] bboxIntersect(double bbox0[/*2*/][],
                                                    double bbox1[/*2*/][])
        {
            double result[][] = new double[2][bbox0[0].length];
            bboxIntersect(result, bbox0, bbox1);
            return result;
        }
        /** bounding box union, returning newly allocated result */
        public static double[/*2*/][] bboxUnion(double bbox0[/*2*/][],
                                                double bbox1[/*2*/][])
        {
            double result[][] = new double[2][bbox0[0].length];
            bboxUnion(result, bbox0, bbox1);
            return result;
        }

        /** submatrix, returning newly allocated result */
        public static double[][] submat(double M[][], int inds[])
        {
            double result[][] = new double[inds.length][inds.length];
            submat(result, M, inds);
            return result;
        }
        /** return newly allocated identity matrix of given dimension */
        public static double[][] identitymat(int n)
        {
            double result[][] = new double[n][n];
            identitymat(result);
            return result;
        }
        /** return newly allocated identity matrix of given dimensions */
        public static double[][] identitymat(int n, int m)
        {
            double result[][] = new double[n][m];
            identitymat(result);
            return result;
        }
        /** transpose matrix, returning newly allocated result */
        public static double[][] transpose(double M[][])
        {
            double result[][] = new double[M.length==0 ? 0 : M[0].length][M.length];
            transpose(result, M);
            return result;
        }
        /** matrix copy, returning newly allocated result */
        public static double[][] copymat(int nRows, int nCols, double M[][])
        {
            double result[][] = new double[nRows][nCols];
            copymat(nRows, nCols, result, M);
            return result;
        }
        /** matrix copy, returning newly allocated result */
        public static double[][] copymat(double M[][])
        {
            return copymat(M.length, ((M).length==0 ? 0 : (M)[0].length), M);
        }
        /** matrix copy, returning newly allocated result */
        public static float[][] copymat(int nRows, int nCols, float M[][])
        {
            float result[][] = new float[nRows][nCols];
            copymat(nRows, nCols, result, M);
            return result;
        }
        /** matrix copy, returning newly allocated result */
        public static float[][] copymat(float M[][])
        {
            return copymat(M.length, ((M).length==0 ? 0 : (M)[0].length), M);
        }
        /** matrix copy, returning newly allocated result */
        public static int[][] copymat(int nRows, int nCols, int M[][])
        {
            int result[][] = new int[nRows][nCols];
            copymat(nRows, nCols, result, M);
            return result;
        }
        /** matrix copy, returning newly allocated result */
        public static int[][] copymat(int M[][])
        {
            return copymat(M.length, ((M).length==0 ? 0 : (M)[0].length), M);
        }
        /** vector copy, returning newly allocated result */
        public static boolean[] copyvec(boolean v[])
        {
            boolean result[] = new boolean[v.length];
            copyvec(result, v);
            return result;
        }
        /** vector copy, returning newly allocated result */
        public static int[] copyvec(int v[])
        {
            int result[] = new int[v.length];
            copyvec(result, v);
            return result;
        }
        /** vector copy, returning newly allocated result */
        public static double[] copyvec(double v[])
        {
            return copyvec(v.length, v);
        }
        /** vector copy, returning newly allocated result */
        public static float[] copyvec(float v[])
        {
            return copyvec(v.length, v);
        }
        /** vector copy, returning newly allocated result */
        public static double[] copyvec(int n, double v[])
        {
            double result[] = new double[n];
            copyvec(n, result, v);
            return result;
        }
        /** vector copy, returning newly allocated result */
        public static float[] copyvec(int n, float v[])
        {
            float result[] = new float[n];
            copyvec(n, result, v);
            return result;
        }

        /** convert double to float vector, returning newly allocated result */
        public static double[] floatToDouble(float v[])
        {
            return floatToDouble(v.length, v);
        }
        /** convert double to float vector, returning newly allocated result */
        public static float[] doubleToFloat(double v[])
        {
            return doubleToFloat(v.length, v);
        }
        /** convert float to double vector, returning newly allocated result */
        public static double[] floatToDouble(int n, float v[])
        {
            double result[] = new double[n];
            floatToDouble(n, result, v);
            return result;
        }
        /** convert double to float vector, returning newly allocated result */
        public static float[] doubleToFloat(int n, double v[])
        {
            float result[] = new float[n];
            doubleToFloat(n, result, v);
            return result;
        }
        /** convert float to double matrix, returning newly allocated result */
        public static double[][] floatToDouble(float m[][])
        {
            double result[][] = new double[m.length][];
            for (int i = (m.length)-1; (i) >= 0; --i)
                result[i] = floatToDouble(m[i]);
            return result;
        }
        /** convert double to float matrix, returning newly allocated result */
        public static float[][] doubleToFloat(double m[][])
        {
            float result[][] = new float[m.length][];
            for (int i = (m.length)-1; (i) >= 0; --i)
                result[i] = doubleToFloat(m[i]);
            return result;
        }

        /** TODO: make this more general and move it into Arrays */
        public static Object[] doubleToFloat(Object m)
        {
            if (m instanceof double[][])
            {
                return doubleToFloat((double[][])m);
            }
            else
            {
                int n = java.lang.reflect.Array.getLength(m);
                // CBB: figure out the right type right away, rather than relying
                // on a sub-result
                Object[] scratch = new Object[n];
                for (int i = 0; i < n; ++i) {
                    scratch[i] = doubleToFloat(java.lang.reflect.Array.get(m, i));
                }
                Object[] answer = (Object[])java.lang.reflect.Array.newInstance(
                    scratch[0].getClass(),
                    n);
                for (int i = 0; i < n; ++i) {
                    answer[i] = scratch[i];
                }
                return answer;
            }
        }

        /** get matrix column, returning newly allocated result */
        public static double[] getcolumn(double M[][], int iCol)
        {
            double result[] = new double[M.length];
            getcolumn(result, M, iCol);
            return result;
        }
        /** matrix times matrix, returning newly allocated result */
        public static double[][] mxm(double m0[/*n*/][/*dotLength*/],
                                     double m1[/*dotLength*/][/*m*/])
        {

            int n = m0.length;
            int dotLength = m1.length;
            int m = (dotLength == 0 ? 0 : m1[0].length);

            {
                // XXX hack-- fix when I'm awake
                if (n != 0 && dotLength != ((m0).length==0 ? 0 : (m0)[0].length))
                {
                    /*
                    assumpt(dotLength == 4 && m0[0].length == 3);
                    n = 4;
                    m = 3;
                    */
                    do { if (!(dotLength == m0[0].length+1)) throw new Error("Assumption failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+4871 +"): " + "dotLength == m0[0].length+1" + ""); } while (false);
                    n = dotLength;
                    m = m0[0].length;
                }
            }

            double[][] result = new double[n][m];
            mxm(result, m0, m1);
            return result;
// 4987 # 4888 "com/donhatchsw/util/VecMath.prejava"
        }

        /** inverse matrix times matrix, returning newly allocated result */
        public static double[][] invmxm(double m0[][],
                                        double m1[][])
        {
            int n = m1.length;
            int m = n==0 ? 0 : m1[0].length;
            double result[][] = new double[n][m];
            invmxm(result, m0, m1);
            return result;
        }

        /** matrix times inverse matrix, returning newly allocated result */
        public static double[][] mxinvm(double m0[][],
                                        double m1[][])
        {
            int n = m0.length;
            int m = n==0 ? 0 : m0[0].length;
            double result[][] = new double[n][m];
            mxinvm(result, m0, m1);
            return result;
        }

        // XXX duplicate code
        /** matrix times matrix, returning newly allocated result */
        public static float[][] mxm(float m0[/*n*/][/*dotLength*/],
                                    float m1[/*dotLength*/][/*m*/])
        {
            int n = m0.length;
            int dotLength = m1.length;
            int m = (dotLength == 0 ? 0 : m1[0].length);
            float[][] result = new float[n][m];
            mxm(result, m0, m1);
            return result;
        }
        // XXX duplicate code
        /** matrix times matrix, returning newly allocated result */
        public static int[][] mxm(int m0[/*n*/][/*dotLength*/],
                                  int m1[/*dotLength*/][/*m*/])
        {
            int n = m0.length;
            int dotLength = m1.length;
            int m = (dotLength == 0 ? 0 : m1[0].length);
            int[][] result = new int[n][m];
            mxm(result, m0, m1);
            return result;
        }

        /** vector plus vector minus vector, returning newly allocated result */
        public static double[] vpvmv(double v0[], double v1[], double v2[])
        {
            double[] result = new double[v0.length];
            vpvmv(result, v0, v1, v2);
            return result;
        }

        /** (scalar times vector) plus (scalar times vector), returning newly allocated result */
        public static double[] sxvpsxv(double s0, double v0[],
                                       double s1, double v1[])
        {
            double[] result = new double[v0.length];
            sxvpsxv(result, s0, v0, s1, v1);
            return result;
        }
        /** vector plus (scalar times vector) plus (scalar times vector), returning newly allocated result */
        public static double[] vpsxvpsxv( double v0[],
                                         double s1, double v1[],
                                         double s2, double v2[])
        {
            double[] result = new double[v0.length];
            vpsxvpsxv(result, v0, s1, v1, s2, v2);
            return result;
        }
        /** (scalar times vector) plus (scalar times vector), returning newly allocated result */
        public static double[] sxvpsxvpsxv(double s0, double v0[],
                                           double s1, double v1[],
                                           double s2, double v2[])
        {
            double[] result = new double[v0.length];
            sxvpsxvpsxv(result, s0, v0, s1, v1, s2, v2);
            return result;
        }
        /** matrix times scalar, returning newly allocated result */
        public static double[][] mxs(double M[][], double s)
        {
            double result[][] = new double[M.length][M.length==0 ? 0 : M[0].length];
            mxs(result, M, s);
            return result;
        }
        /** matrix times scalar, returning newly allocated result */
        public static float[][] mxs(float M[][], float s)
        {
            float result[][] = new float[M.length][M.length==0 ? 0 : M[0].length];
            mxs(result, M, s);
            return result;
        }
        /** scalar times matrix, returning newly allocated result */
        public static double[][] sxm(double s, double M[][])
        {
            double result[][] = new double[M.length][M.length==0 ? 0 : M[0].length];
            sxm(result, s, M);
            return result;
        }
        /** vector times scalar, returning newly allocated result */
        public static double[] vxs(int n, double v[], double s)
        {
            double result[] = new double[n];
            vxs(n, result, v, s);
            return result;
        }
        /** vector times scalar, returning newly allocated result */
        public static double[] vxs(double v[], double s)
        {
            return vxs(v.length, v, s);
        }
        /** vector times scalar, returning newly allocated result */
        public static float[] vxs(int n, float v[], float s)
        {
            float result[] = new float[n];
            vxs(n, result, v, s);
            return result;
        }
        /** vector times scalar, returning newly allocated result */
        public static float[] vxs(float v[], float s)
        {
            return vxs(v.length, v, s);
        }
        /** row vector times matrix, returning newly allocated result */
        public static double[] vxm(double v[], double M[][])
        {
            double result[] = new double[M.length == 0 ? 0 : M[0].length];
            vxm(result, v, M);
            return result;
        }
        /** row vector times matrix, returning newly allocated result */
        public static float[] vxm(float v[], float M[][])
        {
            float result[] = new float[M.length == 0 ? 0 : M[0].length];
            vxm(result, v, M);
            return result;
        }
        /** row vector times matrix, returning newly allocated result */
        public static int[] vxm(int v[], int M[][])
        {
            int result[] = new int[M.length == 0 ? 0 : M[0].length];
            vxm(result, v, M);
            return result;
        }
        /** matrix times column vector, returning newly allocated result */
        public static double[] mxv(double M[][], double v[])
        {
            double result[] = new double[M.length];
            mxv(result, M, v);
            return result;
        }
        /** matrix times column vector, returning newly allocated result */
        public static float[] mxv(float M[][], float v[])
        {
            float result[] = new float[M.length];
            mxv(result, M, v);
            return result;
        }
        /** matrix times column vector, returning newly allocated result */
        public static int[] mxv(int M[][], int v[])
        {
            int result[] = new int[M.length];
            mxv(result, M, v);
            return result;
        }
        /** vector plus (scalar times vector), returning newly allocated result */
        public static double[] vpsxv(int n, double v0[], double s1, double v1[])
        {
            double result[] = new double[n];
            vpsxv(n, result, v0, s1, v1);
            return result;
        }
        /** vector plus (scalar times vector), returning newly allocated result */
        public static double[] vpsxv(double v0[], double s1, double v1[])
        {
            return vpsxv(v0.length, v0, s1, v1);
        }
        /** vector plus (scalar times vector), returning newly allocated result */
        public static float[] vpsxv(int n, float v0[], float s1, float v1[])
        {
            float result[] = new float[n];
            vpsxv(n, result, v0, s1, v1);
            return result;
        }
        /** vector plus (scalar times vector), returning newly allocated result */
        public static float[] vpsxv(float v0[], float s1, float v1[])
        {
            return vpsxv(v0.length, v0, s1, v1);
        }

        /** vector plus (scalar times vector), returning newly allocated result */
        public static int[] vpsxv(int n, int v0[], int s1, int v1[])
        {
            int result[] = new int[n];
            vpsxv(n, result, v0, s1, v1);
            return result;
        }
        /** vector plus (scalar times vector), returning newly allocated result */
        public static int[] vpsxv(int v0[], int s1, int v1[])
        {
            return vpsxv(v0.length, v0, s1, v1);
        }

        /** add v to every row of m, returning newly allocated result */
        public static double[][] vpm(double v[], double m[][])
        {
            double result[][] = new double[m.length][((m).length==0 ? 0 : (m)[0].length)];
            vpm(result, v, m);
            return result;
        }
        /** add v to every row of m, returning newly allocated result */
        public static int[][] vpm(int v[], int m[][])
        {
            int result[][] = new int[m.length][((m).length==0 ? 0 : (m)[0].length)];
            vpm(result, v, m);
            return result;
        }
        /** add v to every row of m, returning newly allocated result */
        public static double[][] mpv(double v[], double m[][])
        {
            double result[][] = new double[m.length][((m).length==0 ? 0 : (m)[0].length)];
            vpm(result, v, m);
            return result;
        }
        /** add v to every row of m, returning newly allocated result */
        public static int[][] mpv(int v[], int m[][])
        {
            int result[][] = new int[m.length][((m).length==0 ? 0 : (m)[0].length)];
            vpm(result, v, m);
            return result;
        }

        /** invert matrix, returning newly allocated result */
        public static double[][] invertmat(double M[][])
        {
            double result[][] = new double[M.length][M.length==0 ? 0 : M[0].length];
            invertmat(result, M);
            return result;
        }
        /** matrix inverse times column vector, returning newly allocated result */
        public static double[] invmxv(double M[][], double v[])
        {
            double result[] = new double[((M).length==0 ? 0 : (M)[0].length)];
            invmxv(result, M, v);
            return result;
        }
        /** row vector times inverse matrix, returning newly allocated result */
        public static double[] vxinvm(double v[], double M[][])
        {
            double result[] = new double[M.length];
            vxinvm(result, v, M);
            return result;
        }

        /** 3-dimensional cross product, returning newly allocated result */
        public static double[] vxv3(final double v1[/*3*/], final double v2[/*3*/])
        {
            double result[] = new double[3];
            vxv3(result, v1, v2);
            return result;
        }
        /** 3-dimensional cross product, returning newly allocated result */
        public static float[] vxv3(final float v1[/*3*/], final float v2[/*3*/])
        {
            float result[] = new float[3];
            vxv3(result, v1, v2);
            return result;
        }

        /** n-dimensional cross product of n-1 n-dimensional vectors, returning newly allocated result */
        public static double[] crossprod(double vectors[][])
        {
            double result[] = new double[vectors.length+1];
            crossprod(result, vectors);
            return result;
        }

        /** return a random vector with length <= 1, in a newly allocated result XXX currently broken */
        public static double[] random(int dim)
        {
            double result[] = new double[dim];
            random(result);
            return result;
        }
        /** return a random vector with length <= 1, in a newly allocated result XXX currently broken */
        public static double[] random(int dim, java.util.Random generator)
        {
            double result[] = new double[dim];
            random(result, generator);
            return result;
        }


        /** make row-oriented translation matrix, returning newly allocated result */
        public static double[][] makeRowTransMat(double translate[])
        {
            double result[][] = new double[translate.length+1][translate.length];
            makeRowTransMat(result, translate);
            return result;
        }

        /** make row-oriented inverse translation matrix, returning newly allocated result */
        public static double[][] makeRowTransMatInv(double translate[])
        {
            double result[][] = new double[translate.length+1][translate.length];
            makeRowTransMatInv(result, translate);
            return result;
        }

        /** make row-oriented translation matrix, returning newly allocated result */
        public static double[][] makeRowTransMat(double x, double y, double z)
        {
            return makeRowTransMat(new double[] {x, y, z});
        }

        /** make row-oriented inverse translation matrix, returning newly allocated result */
        public static double[][] makeRowTransMatInv(double x, double y, double z)
        {
            return makeRowTransMatInv(new double[] {x, y, z});
        }

        /** make row-oriented non-uniform scale matrix, returning newly allocated result */
        public static double[][] makeRowScaleMat(double scale[])
        {
            double result[][] = new double[scale.length+1][scale.length];
            makeRowScaleMat(result, scale);
            return result;
        }
        /** make row-oriented non-uniform scale matrix with tie points, returning newly allocated result */
        public static double[][] makeRowScaleMat(double scale[],
                        double tiePointIn[],
                        double tiePointOut[])
        {
            double M[][] = makeRowScaleMat(scale);
            if (tiePointIn != null)
                M = mxm(makeRowTransMatInv(tiePointIn), M); // move in to 0
            if (tiePointOut != null)
                M = mxm(M, makeRowTransMat(tiePointOut)); // move 0 to out
            return M;
        }
        /** make row-oriented non-uniform scale matrix with fixed point, returning newly allocated result */
        public static double[][] makeRowScaleMat(double scale[],
                        double fixedPoint[])
        {
            return makeRowScaleMat(scale, fixedPoint, fixedPoint);
        }

        /** make row-oriented uniform scale matrix with tie points, returning newly allocated result */
        public static double[][] makeRowScaleMat(int n, double scale,
                        double tiePointIn[],
                        double tiePointOut[])
        {
            return makeRowScaleMat(fillvec(n,scale),tiePointIn,tiePointOut); // XXX not the most efficient way to do this
        }
        /** make row-oriented uniform scale matrix with fixed point, returning newly allocated result */
        public static double[][] makeRowScaleMat(int n, double scale,
                                                 double fixedPoint[])
        {
            return makeRowScaleMat(n,scale,fixedPoint,fixedPoint);
        }
        /** make row-oriented uniform scale matrix, returning newly allocated result */
        public static double[][] makeRowScaleMat(int n, double scale)
        {
            return makeRowScaleMat(n,scale,null,null);
        }
        /** make row-oriented non-uniform scale matrix, returning newly allocated result */
        public static double[][] makeRowScaleMat(double x, double y, double z)
        {
            return makeRowScaleMat(new double[]{x,y,z},null,null);
        }




        /** make row-oriented rotation matrix, returning newly allocated result */
        public static double[][] makeRowRotMat(int n, int fromAxis, int toAxis, double radians)
        {
            double result[][] = new double[n][n];
            makeRowRotMat(result, fromAxis, toAxis, radians);
            return result;
        }
        /** make row-oriented rotation matrix, returning newly allocated result */
        public static float[][] makeRowRotMat(int n, int fromAxis, int toAxis, float radians)
        {
            float result[][] = new float[n][n];
            makeRowRotMat(result, fromAxis, toAxis, radians);
            return result;
        }

        /** make row-oriented rotation matrix with tie points, returning newly allocated result */
        public static double[][] makeRowRotMat(int n, int fromAxis, int toAxis, double radians,
                double tiePointIn[],
                double tiePointOut[])
        {
            double M[][] = makeRowRotMat(n, fromAxis, toAxis, radians);
            if (tiePointIn != null)
                M = mxm(makeRowTransMatInv(tiePointIn), M);
            if (tiePointOut != null)
                M = mxm(M, makeRowTransMat(tiePointOut));
            return M;
        }

        /** make row-oriented rotation matrix with fixed point, returning newly allocated result */
        public static double[][] makeRowRotMat(int n, int fromAxis, int toAxis, double radians, double fixedPoint[])
        {
            return makeRowRotMat(n, fromAxis, toAxis, radians, fixedPoint, fixedPoint);
        }

        /** make row-oriented rotation matrix that fixes a given subset of the n-2 axes, returning newly allocated result */
        // XXX hmm, can simplify and generalize this with extendAndGramSchmidt, I think
        public static double[][] makeRowRotMat(double radians, double fixedAxes[/*n-2*/][])
        {
            int nFixedAxes = fixedAxes.length;
            int n = (nFixedAxes == 0 ? 2 : fixedAxes[0].length);
            do { if (!((nFixedAxes)==(n-2))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+5307 +"): (" + "nFixedAxes" + ")" + "==" + "(" + "n-2" + ") ("+(nFixedAxes)+" vs. "+(n-2)+")"); } while (false);
            double rotXtoFixedAxes[][] = new double[n][n];
            extendAndGramSchmidt(nFixedAxes, n, rotXtoFixedAxes, fixedAxes);
            return mxmxm(transpose(rotXtoFixedAxes),
                         makeRowRotMat(n, n-2,n-1, radians),
                         rotXtoFixedAxes);


        } // makeRowRotMat around axes

        /** make row-oriented rotation matrix that fixes a given subset of the n-2 axes, returning newly allocated result */
        public static float[][] makeRowRotMat(float radians, float fixedAxes[/*n-2*/][])
        {
            return doubleToFloat(makeRowRotMat((double)radians,
                                               floatToDouble(fixedAxes)));
        }


        /** make row-oriented rotation matrix that slerps from vector towards to vector */
        public static double[][] makeRowRotMatThatSlerps(double from[], double to[], double t)
        {
            int n = from.length;
            do { if (!((n)==(to.length))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+5329 +"): (" + "n" + ")" + "==" + "(" + "to.length" + ") ("+(n)+" vs. "+(to.length)+")"); } while (false);
            do { if (!(n >= 2)) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+5330 +"): " + "n >= 2" + ""); } while (false);
            from = normalize(from);
            to = normalize(to);
            if (n == 2)
            {
                double angle = t * angleBetweenUnitVectors(from, to);
                return vxv2(from,to) < 0 ? makeRowRotMat(2, 0,1, angle)
                                         : makeRowRotMat(2, 1,0, angle);
            }
            do { if (!(n >= 3)) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+5339 +"): " + "n >= 3" + ""); } while (false);
            if (1. + distsqrd(from, to) == 1.) // XXX I'm suspicious of this test.  I think this is the right threshold for when to switch between the trig formula and linear interpolation when slerping vectors themselves, but does that mean it makes sense here?
            {
                return identitymat(n);
            }
            if (1. + distsqrd(from, vxs(to, -1.)) == 1.)
            {
                // Vectors are opposite each other.
                // Choose an arbitrary waypoint vector orthogonal
                // to from and to, and use that instead.
                // XXX this code is untested as far as I know
                // choose ax in which abs(from[ax]) is minimal
                int ax = 0;
                for (int i = 1; i < n; ++i) // start at 1
                    if (from[i]*from[i] < from[ax]*from[ax])
                        ax = i;
                double waypoint[] = new double[n]; // zeros
                waypoint[ax] = 1.;
                double fromAndWaypoint[][] = {from, waypoint};
                gramschmidt(fromAndWaypoint, fromAndWaypoint);
                to = waypoint;
                t *= 2.;
            }

            double mat[][] = new double[n][n];
            copyvec(mat[0], from);
            copyvec(mat[1], to);
            if (n > 3)
            {
                java.util.Random generator = new java.util.Random(3); // same thing each time XXX should try not to have to randomize at all!
                for (int i = 2; i < n-1; ++i) // all but the last
                    random(mat[i]);
            }
            crossprod(mat[n-1], mat); // last row is cross prod of other rows, guarantees positive determininant
            gramschmidt(mat, mat);

            double angle = t * angleBetweenUnitVectors(from, to);
            double matXY[][] = makeRowRotMat(n, 0, 1, angle);
            // Return the matrix that:
            //    rotates from,to to the +X,+Y axes, then
            //    rotates +X towards +Y by angle, then
            //    rotates +X,+Y back to from,to
            return mxmxm(transpose(mat),
                         matXY,
                         mat);
        } // makeRowMatThatSlerps

        /** make row-oriented rotation matrix that slerps from vector towards to vector */
        public static float[][] makeRowRotMatThatSlerps(float from[], float to[], float t)
        {
            return doubleToFloat(makeRowRotMatThatSlerps(floatToDouble(from),
                                                         floatToDouble(to),
                                                         (double)t));
        } // makeRotMatThatSlerps

        /**
         * Compute a matrix M
         * such that inTiePoints * M = outTiePoints.
         * <br>
         * I.e.
         * <br>
         *      M = inTiePoints^-1 * outTiePoints.
         */
        public static double[/*dim+1*/][/*dim*/] makeRowTiePointMat(
                               double inTiePoints[][],
                               double outTiePoints[][])
        {
            do { if (!(inTiePoints.length > 0)) throw new Error("Assumption failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+5406 +"): " + "inTiePoints.length > 0" + ""); } while (false); // XXX could fix this if I had an attention span, maybe

            int dim = inTiePoints[0].length;
            do { if (!(inTiePoints.length == dim+1)) throw new Error("Assumption failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+5409 +"): " + "inTiePoints.length == dim+1" + ""); } while (false);
            do { if (!(outTiePoints[0].length == dim)) throw new Error("Assumption failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+5410 +"): " + "outTiePoints[0].length == dim" + ""); } while (false);
            do { if (!(outTiePoints.length == dim+1)) throw new Error("Assumption failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+5411 +"): " + "outTiePoints.length == dim+1" + ""); } while (false);

            // Do it using padding inTiePoints to homogeneous coords,
            // so I don't have to think.
            double inPadded[][] = VecMath.fillmat(dim+1,dim+1, 1.);
            VecMath.copymat(inPadded, inTiePoints); // using the smaller of the two sizes
            double Mpadded[][] = VecMath.mxm(VecMath.invertmat(inPadded),
                                             outTiePoints);
            double M[][] = new double[dim+1][dim];
            VecMath.copymat(M, Mpadded); // using the smaller of the two sizes
            return M;
        } // makeRowTiePointMat


        /** Flattens the rows of matrix M into a single vector. */
        public static void flatten(double flattened[], double M[][])
        {
            int iFlat = 0;
            for (int i = 0; (i) < (M.length); ++i)
                for (int j = 0; (j) < (M[i].length); ++j)
                    flattened[iFlat++] = M[i][j];
        }

        /** Flattens the rows of matrix M into a single vector. */
        public static double[] flatten(double M[][])
        {
            return (double[])Arrays.flatten(M, 0, 2); // flatten 2 dimensions into 1
        }

        /**
         * Join a rectangular array of matrices into one giant matrix,
         */
        // XXX this should really be in the Arrays class, if I could
        // figure out a decent way to generalize it...
        // it's really flattening between non-adjacent dimensions...?
        // so if flatten could take an int[][] specifying
        // where to get the final dims from...
        //      transposeAndOrFlatten(mats, new int[][] {{0,2},{1,3}});
        // This is sort of like Mathematica's flatten,
        // except that the list is a lookup from result dimensions
        // to original dimensions instead of vice versa,
        // and no dups are allowed, and all dims in the input must be referenced.
        // Negative numbers could mean traverse the twos-complement
        // of the specified dimension backwards.
        // Maybe should be a flag saying how to combine more than
        // one input dimension into one output dimension:
        // flatten or diagonal?  Or maybe two functions,
        // one that flattens and one that diagonalizes?
        // Hey but what if we only want to take a particular slice(s)
        // of a dimension? Maybe have to separate that into a separate function.
        //
        // XXX try to make a more efficient in-place version?
        //     I started trying to do that, but it became very messy very fast.
        //
        public static double[][] joinmats(double mats[][][][])
        {
            double resultBigRows[][][] = new double[mats.length][][];
            for (int iBigRow = 0; (iBigRow) < (mats.length); ++iBigRow)
            {
                double transposedMatsOnBigRow[][][] = new double[mats[iBigRow].length][][];
                for (int iBigCol = 0; (iBigCol) < (mats[iBigRow].length); ++iBigCol)
                    transposedMatsOnBigRow[iBigCol] = VecMath.transpose(
                                                       mats[iBigRow][iBigCol]);
                resultBigRows[iBigRow] = VecMath.transpose(
                       (double[][])Arrays.flatten(transposedMatsOnBigRow,0,2));
            }
            return (double[][])Arrays.flatten(resultBigRows,0,2);
        } // joinmats


        /** product of three matrices, returning newly allocated result */
        public static double[][] mxmxm(double A[][], double B[][], double C[][])
        {
            return mxm(mxm(A,B),C);
        }
        /** product of three matrices, returning newly allocated result */
        public static float[][] mxmxm(float A[][], float B[][], float C[][])
        {
            return mxm(mxm(A,B),C);
        }
        /** product of four matrices, returning newly allocated result */
        public static double[][] mxmxmxm(double A[][], double B[][], double C[][], double D[][])
        {
            return mxm(mxmxm(A,B,C),D);
        }
        /** product of four matrices, returning newly allocated result */
        public static float[][] mxmxmxm(float A[][], float B[][], float C[][], float D[][])
        {
            return mxm(mxmxm(A,B,C),D);
        }
        /** row vector times matrix times matrix, returning newly allocated result */
        public static double[] vxmxm(double a[], double B[][], double C[][])
        {
            // left-to-right to avoid matrix multiplication
            return vxm(vxm(a,B),C);
        }
        /** row vector times matrix times matrix, returning newly allocated result */
        public static float[] vxmxm(float a[], float B[][], float C[][])
        {
            // left-to-right to avoid matrix multiplication
            return vxm(vxm(a,B),C);
        }

        /** compute the sign of a permutation, destroying the contents of perm in the process */
        public static int permutationSignDestructive(int perm[])
        {
            int sign = 1;
            int permi;
            int n = perm.length;
            for (int i = 0; (i) < (n); ++i)
            {
                permi = perm[i];
                while (permi != i)
                {
                    // swap permi with perm[permi]...
                    {
                        // order dependent-- very subtle!
                        // (I tried using SWAP but it bombed)
                        int temp = perm[permi];
                        perm[permi] = permi;
                        permi = temp;
                    }
                    sign = -sign;
                }
            }
            return sign;
        } // permutationSignDestructive

        /** tell whether the given permutation is the identity */
        public static boolean isIdentityPerm(int perm[])
        {
            for (int i = (perm.length)-1; (i) >= 0; --i)
                if (perm[i] != i)
                    return false;
            return true;
        }
        /** set the given permuation to the identity */
        public static void identityperm(int perm[], int n)
        {
            for (int i = 0; (i) < (n); ++i)
                perm[i] = i;
        } // identityperm
        /** set the given permuation to the identity */
        public static void identityperm(int perm[])
        {
            identityperm(perm, perm.length);
        } // identityperm
        /** return newly allocated identity permutation of given length */
        public static int[] identityperm(int n)
        {
            int result[] = new int[n];
            identityperm(result);
            return result;
        } // identityperm
        /** compute a random permutation of given length */
        public static void randomperm(int perm[], int n, java.util.Random generator)
        {
            identityperm(perm, n);
            Arrays.shuffle(perm, n, generator);
        } // randomperm
        /** compute a random permutation of given length */
        public static void randomperm(int perm[], java.util.Random generator)
        {
            randomperm(perm, perm.length, generator);
        } // randomperm
        /** compute a random permutation of given length, returning newly allocated result */
        public static int[] randomperm(int n, java.util.Random generator)
        {
            int result[] = new int[n];
            randomperm(result, generator);
            return result;
        } // randomperm

        /** invert permutation */
        public static void invertperm(int result[], int perm[], int n)
        {
            do { if (!(result != perm)) throw new Error("Assumption failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+5587 +"): " + "result != perm" + ""); } while (false);
            for (int i = 0; (i) < (n); ++i)
                result[perm[i]] = i;
        } // invertperm
        /** invert permutation */
        public static void invertperm(int result[], int perm[])
        {
            int n = ((result.length)<=(perm.length)?(result.length):(perm.length));
            invertperm(result, perm, n);
        } // invertperm
        /** invert permutation, returning newly allocated result */
        public static int[] invertperm(int perm[], int n)
        {
            do { if (!(n <= perm.length)) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+5600 +"): " + "n <= perm.length" + ""); } while (false);
            int result[] = new int[n];
            invertperm(result, perm, n);
            return result;
        } // invertperm
        /** invert permutation, returning newly allocated result */
        public static int[] invertperm(int perm[])
        {
            return invertperm(perm, perm.length);
        } // invertperm

        /**
         * Compose lookup tables (e.g. perms).
         * <br>
         * lut0[lut1[i]] = composeluts(lut0,lut1)[i]
         */
        public static void composeluts(int result[],
                                       int lut0[],
                                       int lut1[])
        {
            int n = lut1.length;
            do { if (!((n)==(result.length))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+5621 +"): (" + "n" + ")" + "==" + "(" + "result.length" + ") ("+(n)+" vs. "+(result.length)+")"); } while (false);
            for (int i = 0; (i) < (n); ++i)
                result[i] = lut0[lut1[i]];
        } // composeluts
        /**
         * Compose lookup tables (e.g. perms).
         * <br>
         * lut0[lut1[i]] = composeluts(lut0,lut1)[i]
         */
        public static int[] composeluts(int lut0[],
                                        int lut1[])
        {
            int result[] = new int[lut1.length];
            composeluts(result, lut0, lut1);
            return result;
        } // composeluts






    /**
     * Test some stuff...
     */

    public static void householderTestOneMatrix(int nRows, int nCols, double A[][])
    {
        System.out.println("-----------------");
        System.out.println("        " + "A" + " =\n" + VecMath.toString(A));

        {System.out.print("        "); System.out.println("detUsingLQ(A, false)" + " = " + (detUsingLQ(A, false)));};

        double betas[] = new double[A.length];
        double LQcompressed[][] = copymat(A);
        int detSign = LQdecompositionCompressed(nRows, nCols,
                                                LQcompressed, // in/out
                                                betas); // out
        System.out.println("        " + "LQcompressed" + " =\n" + VecMath.toString(LQcompressed));
        System.out.println("        " + "betas" + " = " + VecMath.toString(betas));

        double L[][] = new double[nRows][nCols];
        // Q can be null, or any number of rows up to nCols. test all options.
        for (int nRowsInQ = -1; nRowsInQ <= nCols; ++nRowsInQ)
        {
            System.out.println("----------");
            double Q[][] = nRowsInQ==-1 ? null : new double[nRowsInQ][nCols];
            uncompressLQdecomposition(nRows, nCols,
                                      LQcompressed, // in
                                      betas, // in
                                      detSign, // in
                                      L, Q); // out
            System.out.println("        " + "L" + " =\n" + VecMath.toString(L));
            System.out.println("        " + "Q" + " =\n" + VecMath.toString(Q));

            // Assert stuff about L and Q
            {
                for (int iRow = 0; (iRow) < (nRows); ++iRow)
                for (int iCol = 0; (iCol) < (nCols); ++iCol)
                {
                    if (iCol == iRow)
                        do { if (!(L[iRow][iCol] >= 0.)) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+5682 +"): " + "L[iRow][iCol] >= 0." + ""); } while (false);
                    if (iCol > iRow)
                        do { if (!((L[iRow][iCol])==(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+5684 +"): (" + "L[iRow][iCol]" + ")" + "==" + "(" + "0." + ") ("+(L[iRow][iCol])+" vs. "+(0.)+")"); } while (false);
                }
                if (nRowsInQ != -1)
                {
                    double shouldBeIdentity[][] = mxm(Q, transpose(Q));
                    System.out.println("        " + "shouldBeIdentity" + " =\n" + VecMath.toString(shouldBeIdentity));
                    if (nRowsInQ == nCols)
                    {
                        double shouldBeA[][] = mxm(L, Q);
                        System.out.println("        " + "shouldBeA" + " =\n" + VecMath.toString(shouldBeA));
                        do { if (!(equals(shouldBeIdentity, identitymat(nRowsInQ), 1e-6))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+5694 +"): " + "equals(shouldBeIdentity, identitymat(nRowsInQ), 1e-6)" + ""); } while (false);
                        do { if (!(equals(shouldBeA, A, 1e-6))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+5695 +"): " + "equals(shouldBeA, A, 1e-6)" + ""); } while (false);
                    }
                    else
                    {
                        // should maybe an assertion that the product is rightup to nRowsInQ, or something? although the code is straightforward enough that it probably doesn't matter
                    }
                }

                if (nRowsInQ == nCols) // if Q is a square matrix
                {
                    double detQ = det(Q);
                    {System.out.print("        "); System.out.println("detQ" + " = " + (detQ));};
                    double AcontentSquared = det(mxm(transpose(A),A));
                    double LcontentSquared = det(mxm(transpose(L),L));
                    System.out.println("        " + "mxm(transpose(A),A)" + " =\n" + VecMath.toString(mxm(transpose(A),A)));
                    System.out.println("        " + "mxm(transpose(L),L)" + " =\n" + VecMath.toString(mxm(transpose(L),L)));
                    {System.out.print("        "); System.out.println("AcontentSquared" + " = " + (AcontentSquared));};
                    {System.out.print("        "); System.out.println("LcontentSquared" + " = " + (LcontentSquared));};
                    do { if (!(((((AcontentSquared)-(0.)) <= (1e-6)) && (((0.)-(AcontentSquared)) <= (1e-6))) == ((((LcontentSquared)-(0.)) <= (1e-6)) && (((0.)-(LcontentSquared)) <= (1e-6))))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+5713 +"): " + "EQ(AcontentSquared, 0., 1e-6) == EQ(LcontentSquared, 0., 1e-6)" + ""); } while (false)
                                                         ;
                    // testing L is safer than testing A here,
                    // since the algorithm looks at L to decide whether
                    // to enforce positive determinant of Q.
                    if (LcontentSquared == 0.) // includes the case nRows < nCols
                    {
                        // A has fewer rows than columns,
                        // or it's square but has less than full rank,
                        // so it should always be possible to make Q
                        // a rotation (not a reflection),
                        // by negating one of the axes if necessary.
                        // The algorithm should have done that,
                        // so detQ should be 1.
                        do { if (!(((((detQ)-(1.)) <= (1e-6)) && (((1.)-(detQ)) <= (1e-6))))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+5727 +"): " + "EQ(detQ, 1., 1e-6)" + ""); } while (false);
                    }
                    else
                    {
                        // detQ should be +-1.
                        do { if (!(((((((detQ) < 0 ? -(detQ) : (detQ)))-(1.)) <= (1e-6)) && (((1.)-(((detQ) < 0 ? -(detQ) : (detQ)))) <= (1e-6))))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+5732 +"): " + "EQ(ABS(detQ), 1., 1e-6)" + ""); } while (false);

                        {System.out.print("        "); System.out.println("det(mxm(transpose(L),L))" + " = " + (det(mxm(transpose(L),L))));};
                        do { if (!(nRows == nCols || nRows == 0)) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+5735 +"): " + "nRows == nCols || nRows == 0" + ""); } while (false)
                                          ; // transpose wasn't necessarily the right size in that case but whatever
                    }
                }
            }
            System.out.println("----------");
        }
        System.out.println("-----------------");
    } // householderTestOneMatrix

    public static void svdcmpTest(int mindim, int maxdim)
    {
        // TODO: (implement and) test non-square matrices
        System.out.println("============================================");
        System.out.println("SVDCMP TEST");
        System.out.println("  dims "+mindim+".."+maxdim+"");
        for (int dim = mindim; dim <= maxdim; ++dim)
        {
            System.out.println("      dim = "+dim);
            int nItersPerDim = 10;
            for (int iIter = 0; iIter < nItersPerDim; ++iIter) {
                System.out.println("          dim="+dim+" iIter="+iIter+"/"+nItersPerDim+"");
                System.out.println("          ----------------------");
                double D[][] = new double[dim][dim];
                for (int i = 0; i < dim; ++i) {
                  D[i][i] = dim + 1. - i; // e.g. dim=3 -> 4,3,2
                }
                if (true) {
                    // Randomly make some of them equal to others
                    for (int i = 1; i < dim; ++i) {
                      if (Math.random() >= .5) D[i][i] = D[i-1][i-1];
                    }
                }
                if (true)
                {
                    // Maybe set last, or last two, to zero
                    if (dim >= 1 && Math.random() >= .5)
                    {
                        D[dim-1][dim-1] = 0.;
                        if (dim >= 2 && Math.random() >= .5)
                        {
                            D[dim-2][dim-2] = 0.;
                        }
                    }
                }
                if (true)
                {
                    if (dim >= 1) {
                        // Randomly negate the last one.
                        // Negating more than one is pointless; it would just make our representation non-canonical
                        // (since any two negations can be resolved by adding some 180 degree rotation
                        // into U or V).
                        if (Math.random() >= .5) {
                          D[dim-1][dim-1] *= -1;
                        }
                    }
                }

                double U[][] = new double[dim][dim];
                for (int i = 0; (i) < (dim-1); ++i) { VecMath.random(U[i]); }
                VecMath.extendAndOrthogonalize(dim-1, dim, U, U);
                double V[][] = new double[dim][dim];
                for (int i = 0; (i) < (dim-1); ++i) { VecMath.random(V[i]); }
                VecMath.extendAndOrthogonalize(dim-1, dim, V, V);

                for (int i = 0; (i) < (dim); ++i) {
                  {System.out.print("        "); System.out.println("norm(U[i])" + " = " + (norm(U[i])));};
                  {System.out.print("        "); System.out.println("norm(V[i])" + " = " + (norm(V[i])));};
                }
                double detU = det(U);
                double detV = det(V);
                {System.out.print("        "); System.out.println("detU" + " = " + (detU));};
                {System.out.print("        "); System.out.println("detV" + " = " + (detV));};
                do { if (!(((((detU)-(1.)) <= (1e-12)) && (((1.)-(detU)) <= (1e-12))))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+5808 +"): " + "EQ(detU, 1., 1e-12)" + ""); } while (false);
                do { if (!(((((detV)-(1.)) <= (1e-12)) && (((1.)-(detV)) <= (1e-12))))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+5809 +"): " + "EQ(detV, 1., 1e-12)" + ""); } while (false);

                for (int iForcePositiveRotations = 0; iForcePositiveRotations < 2; ++iForcePositiveRotations)
                {
                    boolean force_positive_rotations = iForcePositiveRotations==1;
                    System.out.println("          force_positive_rotations = "+force_positive_rotations);

                    // CBB: don't need to do this twice; the only reason we're doing it twice is that svdcmpPolish wiped out the previous result.  should make copies of them instead of recomputing
                    double M[][] = mxtransposem(mxm(U,D),V);
                    double[][] shouldBeU = copymat(M);
                    double[] shouldBeDvector = new double[dim];
                    double[][] shouldBeV = new double[dim][dim];
                    svdcmp(shouldBeU, dim, dim, shouldBeDvector, shouldBeV);
                    System.out.println("              before polishing:");
                    System.out.println("        " + "U" + " =\n" + VecMath.toString(U));
                    System.out.println("        " + "shouldBeU" + " =\n" + VecMath.toString(shouldBeU));
                    System.out.println("        " + "D" + " =\n" + VecMath.toString(D));
                    System.out.println("        " + "shouldBeDvector" + " = " + VecMath.toString(shouldBeDvector));
                    System.out.println("        " + "V" + " =\n" + VecMath.toString(V));
                    System.out.println("        " + "shouldBeV" + " =\n" + VecMath.toString(shouldBeV));
                    {System.out.print("        "); System.out.println("det(shouldBeU)" + " = " + (det(shouldBeU)));};
                    {System.out.print("        "); System.out.println("det(shouldBeV)" + " = " + (det(shouldBeV)));};

                    // Make sure raw svdcmp produced something that's technically correct,
                    // even though far from canonical.
                    {
                        double[][] shouldBeD = new double[dim][dim];
                        for (int i = 0; i < dim; ++i) shouldBeD[i][i] = shouldBeDvector[i];
                        double[][] shouldBeM = mxtransposem(mxm(shouldBeU, shouldBeD), shouldBeV);
                        do { if (!(equals(shouldBeM, M, 1e-12))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+5838 +"): " + "equals(shouldBeM, M, 1e-12)" + ""); } while (false);
                        double detShouldBeU = det(shouldBeU);
                        double detShouldBeV = det(shouldBeV);
                        do { if (!(((((((detShouldBeU) < 0 ? -(detShouldBeU) : (detShouldBeU)))-(1.)) <= (1e-12)) && (((1.)-(((detShouldBeU) < 0 ? -(detShouldBeU) : (detShouldBeU)))) <= (1e-12))))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+5841 +"): " + "EQ(ABS(detShouldBeU), 1., 1e-12)" + ""); } while (false);
                        do { if (!(((((((detShouldBeV) < 0 ? -(detShouldBeV) : (detShouldBeV)))-(1.)) <= (1e-12)) && (((1.)-(((detShouldBeV) < 0 ? -(detShouldBeV) : (detShouldBeV)))) <= (1e-12))))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+5842 +"): " + "EQ(ABS(detShouldBeV), 1., 1e-12)" + ""); } while (false);
                        // XXX TODO: should actually test them both for orthonormality
                    }

                    if (true) {
                        svdcmpPolish(shouldBeU, dim, dim, shouldBeDvector, shouldBeV, force_positive_rotations);
                        System.out.println("              after polishing:");
                        System.out.println("        " + "U" + " =\n" + VecMath.toString(U));
                        System.out.println("        " + "shouldBeU" + " =\n" + VecMath.toString(shouldBeU));
                        System.out.println("        " + "D" + " =\n" + VecMath.toString(D));
                        System.out.println("        " + "shouldBeDvector" + " = " + VecMath.toString(shouldBeDvector));
                        System.out.println("        " + "V" + " =\n" + VecMath.toString(V));
                        System.out.println("        " + "shouldBeV" + " =\n" + VecMath.toString(shouldBeV));
                        {System.out.print("        "); System.out.println("det(shouldBeU)" + " = " + (det(shouldBeU)));};
                        {System.out.print("        "); System.out.println("det(shouldBeV)" + " = " + (det(shouldBeV)));};
                        // Make sure it's still correct...
                        {
                            double[][] shouldBeD = new double[dim][dim];
                            for (int i = 0; i < dim; ++i) shouldBeD[i][i] = shouldBeDvector[i];
                            double[][] shouldBeM = mxtransposem(mxm(shouldBeU, shouldBeD), shouldBeV);
                            do { if (!(equals(shouldBeM, M, 1e-12))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+5862 +"): " + "equals(shouldBeM, M, 1e-12)" + ""); } while (false);
                            double detShouldBeU = det(shouldBeU);
                            double detShouldBeV = det(shouldBeV);
                            do { if (!(((((((detShouldBeU) < 0 ? -(detShouldBeU) : (detShouldBeU)))-(1.)) <= (1e-12)) && (((1.)-(((detShouldBeU) < 0 ? -(detShouldBeU) : (detShouldBeU)))) <= (1e-12))))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+5865 +"): " + "EQ(ABS(detShouldBeU), 1., 1e-12)" + ""); } while (false);
                            do { if (!(((((((detShouldBeV) < 0 ? -(detShouldBeV) : (detShouldBeV)))-(1.)) <= (1e-12)) && (((1.)-(((detShouldBeV) < 0 ? -(detShouldBeV) : (detShouldBeV)))) <= (1e-12))))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+5866 +"): " + "EQ(ABS(detShouldBeV), 1., 1e-12)" + ""); } while (false);
                            // XXX TODO: should actually test them both for orthonormality
                        }

                        // And that it's canonical, too.

                        // Uniqueness is not guaranteed.  But do assert some stuff.
                        // If force_positive_rotations, then:
                        //   the sv's should be in canonical order (nonincreasing magnitude) and at most the last one negative;
                        //   i.e. they should agree with the original D, which was of that form.
                        // If not force_positive_rotations, then:
                        //   the sv's should be all non-negative, and det of U or V (but not both) is allowed to be -1 (unless some answer sv was 0,
                        //   in which case the implementation is expected to fix it, since it can do that without violating non-negativeness of svs)
                        do { if (!((shouldBeDvector.length)==(D.length))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+5879 +"): (" + "shouldBeDvector.length" + ")" + "==" + "(" + "D.length" + ") ("+(shouldBeDvector.length)+" vs. "+(D.length)+")"); } while (false);
                        for (int i = 0; i < D.length; ++i) {
                            if (force_positive_rotations || shouldBeDvector[dim-1] == 0.) {
                                // when conflict, it forced positive rotation at the expense of possibly negating an sv...
                                // which is how we set up the problem originally, so the sv's will match ours exactly.
                                // which means it'll agree with our original sv.
                                do { if (!(((((shouldBeDvector[i])-(D[i][i])) <= (1e-12)) && (((D[i][i])-(shouldBeDvector[i])) <= (1e-12))))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+5885 +"): " + "EQ(shouldBeDvector[i], D[i][i], 1e-12)" + ""); } while (false);
                            } else {
                                // when conflict, it left a rotation negative (i.e. a reflection), leaving all sv's nonnegative.
                                do { if (!(((((shouldBeDvector[i])-(((D[i][i]) < 0 ? -(D[i][i]) : (D[i][i])))) <= (1e-12)) && (((((D[i][i]) < 0 ? -(D[i][i]) : (D[i][i])))-(shouldBeDvector[i])) <= (1e-12))))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+5888 +"): " + "EQ(shouldBeDvector[i], ABS(D[i][i]), 1e-12)" + ""); } while (false);
                            }
                        }

                        if (force_positive_rotations || (dim >= 1 && shouldBeDvector[dim-1] == 0.)) { // have to test shouldBeDvector, *not* D, since the implementation refrains when it doesn't realize it's exactly 0
                            do { if (!(det(shouldBeU) > 0.)) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+5893 +"): " + "det(shouldBeU) > 0." + ""); } while (false); // i.e. it's 1
                            do { if (!(det(shouldBeV) > 0.)) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+5894 +"): " + "det(shouldBeV) > 0." + ""); } while (false); // i.e. it's 1
                        }
                    }

                }
                System.out.println("          ----------------------");
            }
        }

        System.out.println("END SVDCMP TEST");
        System.out.println("============================================");
    } // svdcmpTest

    public static void householderTest()
    {
        System.out.println("============================================");
        System.out.println("HOUSEHOLDER STUFF TEST");

        {
            double testMatrices[][][] = {
                {
                    {1,0,0},
                    {1,1e-9,0},
                },
                {
                    {1,1e-9}, // see what it produces... hmm, there's a 1e9 in the compressed L,Q, that's disturbing.  I'm not sure I'm a fan of this normalize-so-first-entry-is-1 stuff.
                },
                {
                    {3., 4.},
                },
                {
                    {-3., 4.},
                },
                {
                    {3., -4.},
                },
                {
                    {-3., 4.},
                },
                { // case when det(A^T A) comes out slightly nonzero
                    {50,30,60,80},
                    {10,40,20,70},
                },
            };
            for (int iTestMatrix = 0; (iTestMatrix) < (testMatrices.length); ++iTestMatrix)
            {
                double A[][] = testMatrices[iTestMatrix];
                householderTestOneMatrix(A.length, ((A).length==0 ? 0 : (A)[0].length), A);
            }
        }


        java.util.Random generator = new java.util.Random();
        for (int nCols = 0; nCols <= 3; ++nCols)
            for (int nRows = 0; nRows <= nCols; ++nRows)
        //for (int nRows = 0; nRows <= 3; ++nRows)
            //for (int nCols = nRows; nCols <= nRows+2; ++nCols)
            {
                System.out.println("    ["+nRows+"]["+nCols+"]");
                double A[][] = new double[nRows][nCols]; // zeros

                for (int nNonzeroEntries = (nRows*nCols+1)-1; (nNonzeroEntries) >= 0; --nNonzeroEntries)
                {
                    System.out.println("        "+nNonzeroEntries+" nonzero entries");
                    int entries[] = new int[nRows*nCols]; // zeros
                    for (int i = 0; i < nNonzeroEntries; ++i)
                        entries[i] = (i+1) * 3;
                    // e.g. if nNonZeroEntries is 5, entries will be:
                    // 3, 6, 9, 12, 15, 0, 0, 0, ...
                    // (tried multiples of 10 but the determinants got too big
                    // and error-prone)

                    // simplistic way, instead of enumerating
                    // all possibilities, just pick permutations
                    // at random and discard the ones we've already seen
                    java.util.HashMap<String,int[]> seen = new java.util.HashMap<String,int[]>();
                    for (int iPerm = 0; iPerm < 1000; ++iPerm)
                    {
                        int perm[] = randomperm(nRows*nCols, generator);
                        int permutedEntries[] = composeluts(entries, perm);

                        if (seen.put(toString(permutedEntries), permutedEntries) != null)
                        {
                            //System.out.print("                old: ");
                            //PRINTVEC(permutedEntries);
                            continue; // saw it already
                        }
                        else
                        {
                            //System.out.print("            new: ");
                            //PRINTVEC(permutedEntries);
                        }
                        for (int i = 0; i < nRows*nCols; ++i)
                            A[i/nCols][i%nCols] = permutedEntries[i];

                        householderTestOneMatrix(nRows, nCols, A);
                    }
                }
            }
        System.out.println("END HOUSEHOLDER STUFF TEST");
        System.out.println("============================================");
    } // householderTest

    public static void sphericalAverageTestOnePointsAndPoint(double points[][], double q[])
    {
        System.out.println("        in sphericalAverageTestOnePointsAndPoint");
        System.out.println("          points = "+Arrays.toStringCompact(points));
        System.out.println("          q         = "+toString(q));
        int n = points.length;
        int d = points[0].length;
        double weights[] = new double[d];
        System.out.println("              calling getSphericalAverageWeights");
        getSphericalAverageWeights(weights, points, q);
        System.out.println("              returned from getSphericalAverageWeights");
        System.out.println("          weights = "+toString(weights));
        if (true)
        {
            // scaling weights shouldn't hurt
            vxs(weights, weights, 1.3);
        }
        double shouldBeQ[] = new double[d];
        System.out.println("              calling sphericalAverage");
        sphericalAverage(shouldBeQ, points, weights);
        System.out.println("              returned from sphericalAverage");
        System.out.println("          shouldBeQ = "+toString(shouldBeQ));
        {System.out.print("        "); System.out.println("dist(shouldBeQ, q)" + " = " + (dist(shouldBeQ, q)));};

        if (min(weights) >= 0.) // TODO: why is it failing otherwise?
        {
            do { if (!(equals(shouldBeQ, q, 1e-12))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+6023 +"): " + "equals(shouldBeQ, q, 1e-12)" + ""); } while (false); // not entirely principled
        }
        System.out.println("        out sphericalAverageTestOnePointsAndPoint");
    }
    public static void sphericalAverageTestOnePointsAndWeights(double points[][], double weights[])
    {
        System.out.println("        in sphericalAverageTestOnePointsAndWeights");
        System.out.println("          points = "+Arrays.toStringCompact(points));
        System.out.println("          weights         = "+toString(weights));
        int n = points.length;
        int d = points[0].length;
        double q[] = new double[d];
        System.out.println("              calling sphericalAverage");
        sphericalAverage(q, points, weights);
        System.out.println("              returned from sphericalAverage");
        System.out.println("          q = "+toString(q));
        double shouldBeWeights[] = new double[n];
        System.out.println("              calling getSphericalAverageWeights");
        getSphericalAverageWeights(shouldBeWeights, points, q);
        System.out.println("              returned from getSphericalAverageWeights");
        System.out.println("          shouldBeWeights = "+toString(shouldBeWeights));
        {System.out.print("        "); System.out.println("dist(shouldBeWeights, weights)" + " = " + (dist(shouldBeWeights, weights)));};
        do { if (!(equals(shouldBeWeights, weights, 1e-12))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+6045 +"): " + "equals(shouldBeWeights, weights, 1e-12)" + ""); } while (false); // not entirely principled
        System.out.println("        out sphericalAverageTestOnePointsAndWeights");
    }
    public static void sphericalAverageTestOnePoints(java.util.Random generator, int nRandomTries, double points[][])
    {
        System.out.println("    in sphericalAverageTestOnePoints");
        int n = points.length;
        int d = points[0].length;

        sphericalAverageTestOnePointsAndWeights(points, fillvec(n, 1./n));
        sphericalAverageTestOnePointsAndPoint(points, normalize(vxm(fillvec(n,1.),points)));

        for (int iTry = 0; (iTry) < (nRandomTries); ++iTry)
        {
            double weights[] = new double[d];
            while (true)
            {
                for (int i = 0; (i) < (n); ++i)
                    weights[i] = generator.nextDouble() * 2. - 1.; // from -1 to 1
                double sum = sum(weights);
                if (sum <= 0.) continue; // although negative would be interesting
                if (min(weights) < 0.) continue; // although negative would be interesting
                vxs(weights, weights, 1./sum);
                break;
            }
            sphericalAverageTestOnePointsAndWeights(points, weights);
        }
        double pointsSum[] = vxm(fillvec(n,1.), points);
        for (int iTry = 0; (iTry) < (nRandomTries); ++iTry)
        {
            double q[] = new double[d];
            while (true)
            {
                // TODO: randomSphereSurface()
                for (int i = 0; (i) < (n); ++i)
                    q[i] = generator.nextDouble() * 2. - 1.; // from -1 to 1
                double qLength2 = normsqrd(q);
                if (normsqrd(q) > 1.) continue;
                if (normsqrd(q) <= 1e-6) continue;
                if (dot(q, pointsSum) <= 0.) continue; // rough
                vxs(q, q, 1./Math.sqrt(qLength2));
                break;
            }
            sphericalAverageTestOnePointsAndPoint(points, q);
        }
        System.out.println("    out sphericalAverageTestOnePoints");
    }
    public static void sphericalAverageTest(int mindim, int maxdim)
    {
        System.out.println("============================================");
        System.out.println("SPHERICAL AVERAGE STUFF TEST");

        mindim = ((mindim)>=(2)?(mindim):(2)); // <2 doesn't work for spherical averaging
        if (true)
        {
            // Some test cases that were failing...
            if (((mindim <=(3))&&((3)<= maxdim)))
            {
                sphericalAverageTestOnePointsAndPoint(identitymat(3), new double[]{
                    0.5936548681899022,-0.7215803218556387,0.3562242784891879
                });
            }
            if (((mindim <=(4))&&((4)<= maxdim)))
            {
                sphericalAverageTestOnePointsAndPoint(identitymat(4), new double[]{
                    0.14894214452007834,-0.16975189085726003,-0.6428793129183206,0.731919887800443
                });

            }
        }

        java.util.Random generator = new java.util.Random(0);

        int nRandomTriesPerPoints = 1000;
        //int nRandomTriesPerPoints = 100;
        //int nRandomTriesPerPoints = 1;
        //int nRandomTriesPerPoints = 0;

        for (int d = 4; d <= maxdim; ++d)
        {
            double points[][] = identitymat(d);
            sphericalAverageTestOnePoints(generator, nRandomTriesPerPoints, points);
            if (d >= 2)
            {
                double temp[];
                {temp=(points[0]);points[0]=(points[1]);points[1]=(temp);};
                sphericalAverageTestOnePoints(generator, nRandomTriesPerPoints, points);
            }
        }

        System.out.println("END SPHERICAL AVERAGE STUFF TEST");
        System.out.println("============================================");
    }


    public static void main(String args[])
    {
        if (args.length != 1 && args.length != 2)
        {
            System.err.println("Usage: VecMath [<mindim>(default=0)] <maxdim>");
            System.exit(1);
        }

        if (true)
        {
            System.out.println("    testing sqrdTwiceTriangleArea...");
            java.util.Random generator = new java.util.Random(0);
            for (int iTest = 0; (iTest) < (100); ++iTest)
            {
                double M[][] = new double[3][3];
                for (int i = 0; (i) < (3); ++i)
                    random(M[i], generator);
                lerp(M[2], M[1], M[2], 1e-12); // make M[2] very close to M[1]
                if (false)
                {
                    System.out.println("        " + "M" + " = " + Arrays.toStringCompact(M));
                    {System.out.print("        "); System.out.println("sqrdTwiceTriangleArea(M[0],M[1],M[2])" + " = " + (sqrdTwiceTriangleArea(M[0],M[1],M[2])));};
                    {System.out.print("        "); System.out.println("normsqrd(vxv3(vmv(M[1],M[0]),vmv(M[2],M[0])))" + " = " + (normsqrd(vxv3(vmv(M[1],M[0]),vmv(M[2],M[0])))));};
                    {System.out.print("        "); System.out.println("Math.sqrt(sqrdTwiceTriangleArea(M[0],M[1],M[2]))" + " = " + (Math.sqrt(sqrdTwiceTriangleArea(M[0],M[1],M[2]))));};
                    {System.out.print("        "); System.out.println("Math.sqrt(normsqrd(vxv3(vmv(M[1],M[0]),vmv(M[2],M[0]))))" + " = " + (Math.sqrt(normsqrd(vxv3(vmv(M[1],M[0]),vmv(M[2],M[0]))))));};
                    {System.out.print("        "); System.out.println("Math.sqrt(sqrdTwiceTriangleArea(M[0],M[1],M[2])) - Math.sqrt(normsqrd(vxv3(vmv(M[1],M[0]),vmv(M[2],M[0]))))" + " = " + (Math.sqrt(sqrdTwiceTriangleArea(M[0],M[1],M[2])) - Math.sqrt(normsqrd(vxv3(vmv(M[1],M[0]),vmv(M[2],M[0]))))));}
                                                                                   ;
                }
                do { if (!(((((Math.sqrt(sqrdTwiceTriangleArea(M[0],M[1],M[2])) - Math.sqrt(normsqrd(vxv3(vmv(M[1],M[0]),vmv(M[2],M[0])))))-(0.)) <= (1e-15)) && (((0.)-(Math.sqrt(sqrdTwiceTriangleArea(M[0],M[1],M[2])) - Math.sqrt(normsqrd(vxv3(vmv(M[1],M[0]),vmv(M[2],M[0])))))) <= (1e-15))))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+6168 +"): " + "EQ(Math.sqrt(sqrdTwiceTriangleArea(M[0],M[1],M[2])) - Math.sqrt(normsqrd(vxv3(vmv(M[1],M[0]),vmv(M[2],M[0])))), 0., 1e-15)" + ""); } while (false)
                                                                                                ;
            }
            System.out.println("    done testing sqrdTwiceTriangleArea.");
        }

        int mindim = args.length==1 ? 0 : Integer.parseInt(args[0]);
        int maxdim = Integer.parseInt(args[args.length-1]);

        if (true)
        {
            testProcrustes();
        }
        if (true)
        {
            // Test svdcmp
            svdcmpTest(mindim, maxdim);
        }

        for (int dim = mindim; dim <= maxdim; ++dim)
        {
            System.out.println("----------");
            {System.out.print("        "); System.out.println("dim" + " = " + (dim));};
            {
                double M[][] = new double[dim][dim];
                double a[] = new double[dim];
                double b[] = new double[dim];
                double x[] = new double[dim];
                for (int i = 0; (i) < (dim); ++i)
                    random(M[i]);
                random(a);


                mxv(b,M,a);
                invmxv(x,M,b);

                System.out.println("        " + "M" + " =\n" + VecMath.toString(M));
                System.out.println("        " + "a" + " = " + VecMath.toString(a));
                System.out.println("        " + "b" + " = " + VecMath.toString(b));
                System.out.println("        " + "x" + " = " + VecMath.toString(x));

                double origM[][] = copymat(M);
                {System.out.print("        "); System.out.println("det(M)" + " = " + (det(M)));};
                {System.out.print("        "); System.out.println("detUsingLU(M, false)" + " = " + (detUsingLU(M, false)));};
                {System.out.print("        "); System.out.println("detUsingLQ(M, false)" + " = " + (detUsingLQ(M, false)));};
                do { if (!(equalsExactly(M, origM))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+6213 +"): " + "equalsExactly(M, origM)" + ""); } while (false);
                do { if (!(((((det(M))-(detUsingLU(M,false))) <= (1e-6)) && (((detUsingLU(M,false))-(det(M))) <= (1e-6))))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+6214 +"): " + "EQ(det(M), detUsingLU(M,false), 1e-6)" + ""); } while (false);
                do { if (!(((((det(M))-(detUsingLQ(M,false))) <= (1e-6)) && (((detUsingLQ(M,false))-(det(M))) <= (1e-6))))) throw new Error("CHECK failed at "+"com/donhatchsw/util/VecMath.prejava"+"("+6215 +"): " + "EQ(det(M), detUsingLQ(M,false), 1e-6)" + ""); } while (false);
            }

            if (dim >= 1)
            {
                double vectors[][] = new double[dim-1][dim];
                identitymat(vectors);
                System.out.println("        " + "vectors" + " =\n" + VecMath.toString(vectors));
                System.out.println("        " + "crossprod(vectors)" + " = " + VecMath.toString(crossprod(vectors)));
            }
            if (dim == 3) // XXX make this more general when makeRowRotMat more general
            {
                float v[] = new float[dim];
                v[1] = -1;
                System.out.println("        " + "makeRowRotMat(0.f, new float[][]{v})" + " =\n" + VecMath.toString(makeRowRotMat(0.f, new float[][]{v})));
                System.out.println("        " + "makeRowRotMat(1.f, new float[][]{v})" + " =\n" + VecMath.toString(makeRowRotMat(1.f, new float[][]{v})));
            }
            {System.out.print("        "); System.out.println("dim" + " = " + (dim));};
            System.out.println("----------");
        }

        // Test householder stuff
        householderTest();

        if (true)
        {
            // Test spherical average stuff
            // TODO: uncomment assertion in case of negative weights
            sphericalAverageTest(mindim, maxdim);
            if (false)
            {
                System.out.println(""+"PREMATURELY EXITING!");
                System.exit(1);
            }
        }

    } // main

} // class VecMath
