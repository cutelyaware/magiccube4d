// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// 102 # 1 "com/donhatchsw/util/MyMath.prejava"
// 103 # 1 "<built-in>"
// 104 # 1 "<command-line>"
// 105 # 1 "/usr/include/stdc-predef.h" 1 3 4

// 107 # 1 "/usr/include/stdc-predef.h" 3 4
/* Copyright (C) 1991-2019 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




/* This header is separate from features.h so that the compiler can
   include it implicitly at the start of every compilation.  It must
   not itself include <features.h> or any other header that includes
   <features.h> because the implicit include comes before any feature
   test macros that may be defined in a source file before it first
   explicitly includes a system header.  GCC knows the name of this
   header in order to preinclude it.  */

/* glibc's intent is to support the IEC 559 math functionality, real
   and complex.  If the GCC (4.9 and later) predefined macros
   specifying compiler intent are available, use them to determine
   whether the overall intent is to support these features; otherwise,
   presume an older compiler has intent to support these features and
   define these macros by default.  */
// 142 # 52 "/usr/include/stdc-predef.h" 3 4
/* wchar_t uses Unicode 10.0.0.  Version 10.0 of the Unicode Standard is
   synchronized with ISO/IEC 10646:2017, fifth edition, plus
   the following additions from Amendment 1 to the fifth edition:
   - 56 emoji characters
   - 285 hentaigana
   - 3 additional Zanabazar Square characters */
// 149 # 1 "<command-line>" 2
// 150 # 1 "com/donhatchsw/util/MyMath.prejava"

// 152 # 1 "com/donhatchsw/util/MyMath.prejava"
/* vim: set filetype=java: */
// Author: Don Hatch (hatch@hadron.org)
// 155 # 1 "com/donhatchsw/util/macros.h" 1
//
// macros.h
//
// 159 # 14 "com/donhatchsw/util/macros.h"
// NOTE: this causes a,b to be evaluated twice on failure, so is not ideal. might be better to do a block... ?
// 161 # 30 "com/donhatchsw/util/macros.h"
// Note: the additional "(a)==(b)||" is to make it work correctly for infinities...
// and causes the args to be evaluated twice.
// 164 # 67 "com/donhatchsw/util/macros.h"
// XXX ... what a mess
// 166 # 4 "com/donhatchsw/util/MyMath.prejava" 2

package com.donhatchsw.util;

/**
*
* Robust implementations of hyperbolic and inverse hyperbolic trig functions,
* and expm1 and log1p,
* and hypot; all stuff that should be in the standard math library.
* <br>
* For explanations of some of the robust algorithms used, see:
* <a href="http://plunk.org/~hatch/rightway.php">http://plunk.org/~hatch/rightway.php</a>
* <br>
* TODO: more stuff to add: acosf1 (inverse of cosf1? or 1-acos(f)? get it straight, sincm1, asinh1p, sinhc, sinhcm1, asinhc1p... get it all straight.)
* TODO: asinhc is over in Catenary.prejava (not ready for prime time though.. there's a binary search one, and a newton one)
* <br>
* TODO: higher order stuff... is there a methodology? e.g. exp(x) -> exp(x)-1 -> (exp(x)-1)/x -> (exp(x)-1)/x-1 -> ((exp(x)-1.)/x-1.)/(x/2.) -> ((exp(x)-1.)/x-1.)/(x/2.)-1. -> (((exp(x)-1.)/x-1.)/(x/2.)-1.)/(x/3.) -> (((exp(x)-1.)/x-1.)/(x/2.)-1.)/(x/3.)-1. -> ((((exp(x)-1.)/x-1.)/(x/2.)-1.)/(x/3.)-1.)/(x/4.)
* <br>
* TODO: confidence tests actually verifying accuracy of some of these in the problem cases, e.g. my acosh wasn't that good and the new one is great
* <br>
* TODO: implement asinh_difference at least (needed for Catenary)
* TODO: change *_difference functions to *_difference_quotient
* TODO: implement various *_difference_integral functions? I think. Maybe.
*/

public class MyMath
{
    private MyMath() {} // non-instantiatable

    /**
    * exp(x)-1, accurate even when x is small.
    */
   /* This was found in:
    * <a href="http://www.cs.berkeley.edu/~wkahan/Math128/Sumnfp.pdf">
    * http://www.cs.berkeley.edu/~wkahan/Math128/Sumnfp.pdf</a>
    * <br>
    * Achieves "nearly full working relative accuracy despite cancellation
    * no matter how tiny x may be".
    */
    public static double
    expm1(double x)
    {
        double u = Math.exp(x);
        if (u == Double.POSITIVE_INFINITY)
            return Double.POSITIVE_INFINITY;
        if (u == 1.)
            return x;
        if (u-1. == -1.)
            return -1.;
        return (u-1.)*x/Math.log(u);
    }

    /**
    * (exp(x)-1)/x, accurate even when x is small.
    */
    public static double
    expm1_over_x(double x)
    {
        double u = Math.exp(x);
        if (u == Double.POSITIVE_INFINITY)
            return Double.POSITIVE_INFINITY;
        if (u == 1.)
            return 1.;
        if (u-1. == -1.)
            return -1./x;
        return (u-1.)/Math.log(u);
    }

    /**
    *  log(1+x), accurate even when x is small.
    */
    /*
    *  Found in gsl (gnu scientific library),
    *  distributed under GPL version 2,
    *  but I'm sure it's from Kahan too.
    */
    public static double
    log1p(double x)
    {
        if (x == -1.)
            return Double.NEGATIVE_INFINITY; // grr special case since apparently -inf + nan == nan (I'd prefer -inf)
        if (x == Double.POSITIVE_INFINITY)
            return Double.POSITIVE_INFINITY;
        double u = 1.+x;
        if (u == Double.POSITIVE_INFINITY) // grr, special case for max double
            return Math.log(x);
        // yow! see below, lots simpler I think
        return Math.log(u) - ((u-1.)-x)/u; // cancels errors with IEEE arithmetic
    }

    /*
        XXX the following might be preferable...
 from http://www.hursley.ibm.com/majordomo/JSR-DECIMAL/archives/jsr-decimal.archive.0102/Author/article-6.html:

It is not unheard of for math libraries to deliberately add quantities
that might have very different magnitudes to see what sort of roundoff
occurs.  For example, take Kahan's log1p implementation (log1p is the
result of ln(1 + x) -- because of roundoff in a given precision,
having a separate function is more accurate than the obvious way to
compute this function):

log1p(x) {
  if ( (1.0 + x ) == 1.0)
    return x;
  else
    return log(1.0 +x)*x/(1.0 +x);     XXX that doesn't look right to me... should be dividing by something close to x, not close to 1+x. good thing I'm not using this.
    should be:
           log(1+x)*x/(x+1-1), equiv to goldberg's referenced on the stackoverflow question
           and also equiv to kristopherjohnson's.
}

The ( (1.0 + x ) == 1.0) expression computes the sum of x and 1.0
simply to see of x gets rounded away.  In this case, computing the
exact value of (1.0 + x) could seriously effect the performance of
this function when it should be very fast.
    XXX and this, from
        http://kristopherjohnson.net/twiki/pub/Main/MathLibFunctions/alg.html

 * Note: Assuming log() return accurate answer, the following
 *       algorithm can be used to compute log1p(x) to within a few ULP:
 *
 *              u = 1+x;
 *              if(u==1.0) return x ; else
 *                         return log(u)*(x/(u-1.0));
 *
 *       See HP-15C Advanced Functions Handbook, p.193.
 *

    XXX whoa, and lots of other good stuff at:
http://kristopherjohnson.net/twiki/pub/Main/MathLibFunctions/alg.html

* Also see reference to python implementation elsewhere in this file!
* It uses the difference formulation.

* Also see this stackoverflow question which asks for merits of yet two more methods:
*   http://stackoverflow.com/questions/24134816/goldbergs-log1p-vs-gsl-log1p

* Actually I believe they all boil down to essentially two methods,
* as mentioned in the stackoverflow question:
*       goldberg's: x*log(x+1)/(x+1-1)
*       gsl's:      log(x+1) - (x+1-1-x)/(x+1)
*
*       goldberg's: x*log(1+x)/(1+x-1)
*       gsl's:      log(1+x) - (1+x-1-x)/(1+x)
* Q: which is preferable in general: (a*b)/c or a*(b/c)? Intuitively the former I think? Or maybe not.
*
* TODO: clean up this rambling comment.  compare the two methods using gnuplot or whatever, report back here, and maybe answer the stackoverflow question.

    */

    /**
    *  log(1+x)/x, accurate even when x is small.
    */
    public static double
    log1p_over_x(double x)
    {
        double u = 1. + x;
        if (u == 1.)
            return 1.;
        return Math.log(u)/(u-1.);
    }


    /** exp(X+x)-exp(X), accurate even when x is small. */
    public static double
    exp_difference(double X, double x)
    {
        // exp(X+x)-exp(X) = exp(X)*exp(x) - exp(X)
        //                 = exp(X)*(exp(x)-1)
        //                 = exp(X)*expm1(x)
        return expm1(x) * Math.exp(X);
        // XXX TODO: think about whether we need three args.  seems to me we don't? in which case we don't for sinh and cosh either?
    }
    /** log(X+x)-log(X), accurate even when x is small. */
    public static double
    log_difference(double X, double x)
    {
        // log(X+x)-log(X) = log((X+x)/X)
        //                 = log(1+x/X)
        //                 = log1p(x/X)
        // XXX decide whether the following is relevant: http://stackoverflow.com/questions/29827309/compute-logx-y-given-logx-and-logy-without-overflows
        return log1p(x/X);
    }
    /** sqrt(X+x)-sqrt(X), accurate even when x is small. */
    public static double
    sqrt_difference(double X, double x)
    {
        // sqrt(X+x)-sqrt(X) = (sqrt(X+x)-sqrt(X))*(sqrt(X+x)+sqrt(X))/(sqrt(X+x)+sqrt(X))
        //                   = (X+x-X) / (sqrt(X+x) + sqrt(X))
        //                   = x / (sqrt(X+x) + sqrt(X))
        // But only do it if the original subtraction would have significant error,
        // i.e. both terms nonzero and exponents differ by at most 1.
        // (in particular, do *not* do it if X and x are both 0, as that would cause a zero divide)
        double sqrt_Xplusx = Math.sqrt(X+x);
        double sqrt_X = Math.sqrt(X);
        if (sqrt_X*2 <= sqrt_Xplusx) {
          return sqrt_Xplusx - sqrt_X; // no significant cancellation
        } else {
          return x / (sqrt_Xplusx + sqrt_X); // there is significant cancellation... and this implies X and x are not both zero
        }
    }
    /** (X+x)^2-X^2, accurate even when x is small. */
    public static double
    sqr_difference(double X, double x)
    {
        // (X+x)^2 - X^2 = 2*X*x + x^2 = x*(2*X+x)
        return x * (2*X + x);
    }
    /** (X+x)^3-X^3, accurate even when x is small. */
    public static double
    cub_difference(double X, double x)
    {
        // (X+x)^3 - X^3 = 3*X^2*x + 3*X*x^2 + x^3 = x*(3*X^2 + 3*X*x + x^2)
        // XXX are any orderings preferable to others?
        return x * (3*(X*X) + 3*(X*x) + x*x);
    }

    /** cos(T+x)-cos(T), accurate even when x is small. */
    public static double
    cos_difference(double T, double t)
    {
        return -2 * Math.sin(t/2) * Math.sin(T + t/2); // according to wolframalpha
    }
    /** sin(T+t)-sin(T), accurate even when t is small. */
    public static double
    sin_difference(double T, double t)
    {
        return 2 * Math.sin(t/2) * Math.cos(T + t/2); // according to wolframalpha
    }
    /** tan(T+t)-tan(T), accurate even when t is small. */
    public static double
    tan_difference(double T, double t)
    {
        return Math.sin(t) / (Math.cos(T) * Math.cos(T+t)); // according to wolframalpha
    }
    /** cosh(X+x)-cosh(X), accurate even when x is small; X may be infinite. */
    public static double
    cosh_difference(double Xnumerator, double Xdenominator, double x)
    {
        if (false) {
          // TODO: wolframalpha these days says 2*sinh(t/2)*sinh(t/2 + T)  ... but still might benefit from the numerator/denominator thing.  Need to make sure the test detects badness... currently it doesn't seem to
          double X = Xnumerator / Xdenominator;
          return 2*Math.sinh(x/2)*sinh(X + x/2);
        }
        // cosh(X+x)-cosh(X) = (exp(X+x)+exp(-(X+x)))/2 - (exp(X)+exp(-X))/2
        //                   = (exp(X+x)-exp(X))/2 + (exp(-X-x)-exp(-X))/2
        //                   = (exp_difference(X,x) + exp_difference(-X,-x)) / 2
        //                   = expm1(x)*exp(X) + expm1(-x)*exp(-X)
        if (Math.abs(Xnumerator) <= Math.abs(Xdenominator))
        {
            // mostly horizontal case
            double X = Xnumerator/Xdenominator; // stable in this case
            return exp_difference(X, x)*.5 + exp_difference(-X, -x)*.5; // ordered to prevent overflow
        }
        else
        {
            // mostly vertical case. actually maybe not important?? hmm, maybe don't need the three args.
            double X = Xnumerator/Xdenominator; // unstable in this case but not sure it matters XXX think about it
            return exp_difference(X, x)*.5 + exp_difference(-X, -x)*.5; // ordered to prevent overflow
        }
    }
    /** sinh(X+x)-sinh(X), accurate even when x is small; X may be infinite. */
    public static double
    sinh_difference(double Xnumerator, double Xdenominator, double x)
    {
        // sinh(X+x)-sinh(X) = (exp(X+x)-exp(-(X+x)))/2 - (exp(X)-exp(-X))/2
        //                   = (exp(X+x)-exp(X))/2 - (exp(-X-x)-exp(-X))/2
        //                   = (exp_difference(X,x) - exp_difference(-X,-x)) / 2
        //                   = expm1(x)*exp(X) - expm1(-x)*exp(-X)
        if (Math.abs(Xnumerator) <= Math.abs(Xdenominator))
        {
            // mostly horizontal case
            double X = Xnumerator/Xdenominator; // stable in this case
            return exp_difference(X, x)*.5 - exp_difference(-X, -x)*.5; // ordered to prevent overflow
        }
        else
        {
            // mostly vertical case. actually maybe not important?? hmm, maybe don't need the three args.
            double X = Xnumerator/Xdenominator; // unstable in this case but not sure it matters XXX think about it
            return exp_difference(X, x)*.5 - exp_difference(-X, -x)*.5; // ordered to prevent overflow
        }
        // TODO: wolframalpha these days says 2*sinh(t/2)*cosh(t/2 + T), but might still benefit from the numerator/denominator thing.  need to make sure the test detects badness... currently it doesn't seem to.
    }
    /** tanh(X+x)-tanh(X), accurate even when x is small; X may be infinite. */
    public static double
    tanh_difference(double Xnumerator, double Xdenominator, double x)
    {
        double X = Xnumerator / Xdenominator; // seems to work fine
        // tanh(X+x)-tanh(X) = sinh(x)*sech(X)*sech(X+x)  according to wolframalpha
        //                   = sinh(x)/(cosh(X)*cosh(X+x))
        return sinh(x)/(cosh(X)*cosh(X+x));
    }
    /** sinc(T+t)-sinc(T), accurate even when t is small. */
    public static double
    sinc_difference(double T, double t)
    {
        // TODO: does it make sense for T to be infinite?  Maybe there needs to be more fine-grained params in that case?  (Tnumerator, Tdenominator, T mod 2*pi)
        // sinc(T+t)-sinc(T) = sin(T+t)/(T+t) - sin(T)/T
        //                   = (sin(T+t)*T - sin(T)*(T+t)) / ((T+t)*T)
        //                   = (sin(T+t)*T - sin(T)*T - sin(T)*t) / ((T+t)*T)
        //                   = (sin_difference(T,t)*T - t*sin(T)) / ((T+t)*T)
        //                   = (sin_difference(T,t) - t*sinc(T)) / (T+t)
        // XXX TODO: clearly need to check for 0/0
        if (T+t == 0.) // XXX haven't thought about what this means. seems weird if it's asymmetric... ? i.e. different behavior when T+t from when T==0
            return sin_over_x(T+t) - sin_over_x(T);
        return (sin_difference(T,t) - t*sin_over_x(T)) / (T+t);
    }

    /** acos(X+x)-acos(X), accurate even when x is small. */
    public static double
    acos_difference(double X, double x)
    {
        return -asin_difference(X, x);
    }
    /** asin(Y+y)-asin(Y), accurate even when y is small. */
    public static double
    asin_difference(double Y, double y)
    {
        // Draw the picture; it's the arc length between the following two points:
        //   p0 = [sqrt(1-Y^2), Y]
        //   p1 = [sqrt(1-(Y+y)^2), Y+y]
        // So the answer is 2*asin(||p1-p0||/2).
        //   dist = ||p1-p0||
        //        = hypot(sqrt(1-(Y+y)^2)-sqrt(1-Y^2), y)
        //        = hypot(sqrt(1-Y^2-2*Y*y-y^2)-sqrt(1-Y^2), y)
        //        = hypot(sqrt_difference(1-Y^2, -2*Y*y-y^2), y)
        // NOTE: we (non-obviously) correctly return NaN for things like T=.8,t=.2.
        // The test makes a special case for that.
        double temp = sqrt_difference((1+Y)*(1-Y), -y*(2*Y+y)); // let it make the subtle decision
        double dist = Math.hypot(temp, y);
        double answer = 2 * Math.asin(dist/2);
        if (y < 0) answer = -answer;
        return answer;
    }

    // Double.isFinite(double) doesn't exist until java 1.8, so use this instead
    private static boolean
    Double_isFinite(double d)
    {
        return !Double.isNaN(d) && !Double.isInfinite(d);
    }

    /** atan(X+x)-atan(X), accurate even when x is small; X may be infinite. */
    // CBB: make it 2d? i.e. an atan2_difference, maybe?
    public static double
    atan_difference(double Xnumerator, double Xdenominator, double x)
    {
        if (Xdenominator == 0. && Xnumerator != 0. && Double_isFinite(x)) return 0.; // CBB: think about whether can do it without special case
        if (x == 0.) return 0.; // XXX this is true in general, right?  but I think it's a cop-out
        double X = Xnumerator / Xdenominator;

        // Similar to asin_difference, we want the arc length between two points:
        //   p0 = [1,T] normalized
        //      = [1,T] / sqrt(1+T^2)
        //   p1 = [1,T+t] normalized
        //      = [1,T+t] / sqrt(1+(T+t)^2)

        // Strange, the test seems to think it's stable as soon as I express the X part
        // as a sqrt_difference; shouldn't it require both the X and Y parts to be sqrt_difference?
        double dist = Math.hypot(sqrt_difference(1+((X)*(X)), x*(2*X + x)),
                                 sqrt_difference(((X+x)*(X+x))*(1+((X)*(X))), -x*(2*X + x)))
                    / Math.sqrt((1+((X+x)*(X+x)))*(1+((X)*(X))));
        double answer = 2 * Math.asin(dist/2);
        if (x < 0) answer = -answer;
        return answer;
    } // atan_difference

    /** acosh(Y+y)-acosh(Y), accurate even when y is small; Y may be infinite. */
    public static double
    acosh_difference(double Ynumerator, double Ydenominator, double y)
    {
        // wolframalpha says it's:
        //   log((sqrt(y + Y - 1)*sqrt(y + Y + 1) + y + Y)/(Y + sqrt(Y - 1)*sqrt(Y + 1)))
        // and simplify.
        double Y = Ynumerator / Ydenominator; // XXX does this cover everything?
        if (Y == Double.POSITIVE_INFINITY && Double_isFinite(y)) return 0.;
        return Math.log1p((y + sqrt_difference((Y+1)*(Y-1), y*(2*Y+y)))
                        / (Y + Math.sqrt((Y+1)*(Y-1))));
    }

    /** asinh(T+t)-asinh(T), accurate even when t is small; T may be infinite. */
    public static double
    asinh_difference(double Tnumerator, double Tdenominator, double t)
    {
        // asinh(t) = log(t + sqrt(t^2 + 1))
        //          = log1p(t + sqrt(t^2 + 1) - 1)
        //          = log1p(t + (sqrt(t^2+1)-1)*(sqrt(t^2+1)+1)/(sqrt(t^2+1)+1))
        //          = log1p(t + (t^2+1 - 1)/(sqrt(t^2+1)+1))
        //          = log1p(t + t^2 / (sqrt(t^2+1)+1))
        //          = log1p(t * (1 + t / (sqrt(t^2+1)+1) ))

        // asinh(T+t)-asinh(T) = log((T+t) + sqrt((T+t)^2 + 1)) - log(T + sqrt(T^2 + 1))
        //                     = log( ((T+t) + sqrt((T+t)^2 + 1)) / (T + sqrt(T^2 + 1)) )
        //                     = log1p( ((T+t) + sqrt((T+t)^2 + 1)) / (T + sqrt(T^2 + 1)) - 1 )
        //                     = log1p( ((T+t) + sqrt((T+t)^2 + 1) - (T + sqrt(T^2 + 1))) / (T + sqrt(T^2 + 1)) )
        //                     = log1p( (t + sqrt((T+t)^2 + 1) - sqrt(T^2 + 1)) / (T + sqrt(T^2 + 1)) )
        //                     = log1p( (t + (sqrt((T+t)^2 + 1) - sqrt(T^2 + 1))*(sqrt((T+t)^2 + 1) + sqrt(T^2 + 1))/(sqrt((T+t)^2 + 1) + sqrt(T^2 + 1))) / (T + sqrt(T^2 + 1)))
        //                     = log1p( (t + ( ((T+t)^2+1)  - (T^2+1) )/(sqrt((T+t)^2 + 1) + sqrt(T^2 + 1))) / (T + sqrt(T^2 + 1)))
        //                     = log1p( (t + ( 2*T*t + t^2 )/(sqrt((T+t)^2 + 1) + sqrt(T^2 + 1))) / (T + sqrt(T^2 + 1)))
        //                     = log1p( t * (1 + ( 2*T + t )/(sqrt((T+t)^2 + 1) + sqrt(T^2 + 1))) / (T + sqrt(T^2 + 1)))

        double T = Tnumerator / Tdenominator; // fine if it produces +-infinity
        if (Double.isNaN(T))
            return Double.NaN;
        else if (T == Double.NEGATIVE_INFINITY || T == Double.POSITIVE_INFINITY)
        {
            if (t == Double.NEGATIVE_INFINITY || t == Double.POSITIVE_INFINITY)
                return Double.NaN;
            else
                return 0.;
        }

        // XXX hack condition to prevent other blowups when T is tiny and t is big or negative big
        if (T + t == t)
            return MyMath.asinh(T+t) - MyMath.asinh(T);

        // Hmm I think the expression below will blow up if T<0 is huge
        // (T catastrophically cancels with temp in that case),
        // so mirror image the problem in that case.
        if (T < 0.)
        {
            // XXX TODO: redundant code above in the sub-call
            return -asinh_difference(-Tnumerator, Tdenominator, -t);
        }

        double Temp = Math.hypot(T+t, 1.);
        double temp = Math.hypot(T, 1.);
        return log1p( t * (1 + ( 2*T + t )/(Temp + temp)) / (T + temp)); // XXX oh no! blows up if T is huge and negative I think.  I may be overthinking all this though.
    }

    /** atanh(T+t)-atanh(T), accurate even when t is small. */
    public static double
    atanh_difference(double T, double t)
    {
        // The only infinite cases are: atanh(1)==inf, atanh(-1)==-inf
        // So I think the following gets all the cases involving infinity right
        // (it makes the confidence test succeed anyway).
        // TODO: investigate why this is necessary; is log1p screwing up? (both Math and MyMath)
        if (T==1 || T==-1 || T+t==1 || T+t==-1)
        {
            return MyMath.atanh(T+t) - MyMath.atanh(T);
        }

        // Recall atanh(x) = (log(1+x)-log(1-x))/2 = log((1+x)/(1-x))/2
        // atanh(T+t) - atanh(T) = log((1+T+t)/(1-T-t))/2 - Math.log((1+T)/(1-T))/2
        //                       = log( (1+T+t)*(1-T) / ((1-T-t)*(1+T)) ) / 2
        //                       = log( 1 - 2*t/((1+T)*(t+T-1)) ) / 2
        //                       = log1p( -2*t/((1+T)*(t+T-1)) ) / 2
        return Math.log1p( 2*t/((1+T)*(1-(T+t))) ) / 2;
    }

    /** hyperbolic sine function */
    public static double
    sinh(double x)
    {
        // sinh(x) = (e^x - e^-x) / 2
        //         = (e^x - 1)(e^x + 1) / e^x / 2;
        //         = expm1(x) * (expm1(x)+2) / (expm1(x)+1) / 2
        // XXX or:  (expm1(x)-expm1(-x))/2 ... is that more accurate?
        if (x >= 0.)
        {
            double u = expm1(x);
            if (u == Double.POSITIVE_INFINITY)
                return Double.POSITIVE_INFINITY;
            return .5 * u / (u+1) * (u+2); // ordered to avoid overflow when big
        }
        else
        {
            double u = expm1(-x);
            if (u == Double.POSITIVE_INFINITY)
                return Double.NEGATIVE_INFINITY;
            return -.5 * u / (u+1) * (u+2); // ordered to avoid overflow when big
        }
    }

    /** hyperbolic cosine function */
    public static double
    cosh(double x)
    {
        // cosh(x) = (e^x + e^-x) / 2
        // I don't think there are any cancellation issues
        // (though probably coshm1, below, is more useful).
        // We start by taking abs(x), just to make sure we get the exact same
        // result for x and -x.
        // XXX should we be doing coshm1(x) + 1? not sure
        double e_x = Math.exp(Math.abs(x));
        return (e_x + 1./e_x) * .5;
    }

    /** cosh(x)-1, accurate even when x is small. */
    public static double
    coshm1(double x)
    {
        if (true)
        {
            // cosh(x) - 1 = (e^x + e^-x) / 2 - 1
            //             = (e^x - 2 + e^-x) / 2
            //             = (e^2x - 2*e^x + 1) / e^x / 2
            //             = (e^x - 1)^2 / e^x / 2
            //             = expm1(x)^2 / (expm1(x)+1) / 2
            double u = expm1(Math.abs(x));
            if (u == Double.POSITIVE_INFINITY)
                return Double.POSITIVE_INFINITY;
            return .5 * u / (u+1) * u; // ordered to avoid overflow when big
        }
        else
        {
            // Seemingly more straightforward,
            // but actually more expensive since it takes two different expm1's.
            // But... should check to see whether it's more accurate?
            // Some discussion on some web site (mentioned elsewhere in this file)
            // indicates it is.
            // cosh(x) - 1 = (e^x + e^-x) / 2 - 1
            //             = (e^x - 1 + e^-x - 1) / 2
            //             = (e^x - 1)/2 + (e^-x - 1)/2
            //             = (expm1(x) + expm1(-x)) / 2
            return .5*expm1(x) + .5*expm1(-x); // ordered to avoid overflow when big
        }
        // TODO: 2*sinh(.5*x)^2 ? yeah I think so.  inverse of what we do with acosh1p below (but not any more)
    }

    /** acosh(1+x), accurate even when x is small. */
    public static double
    acosh1p(double x)
    {
        // previous version-- not as direct, but interesting because it only
        // refers to x once, so it's easily invertible, leading to a formula
        // for the inverse function coshm1 above
        //return 2 * asinh(Math.sqrt(x/2));

        // acosh(X) = log(X + sqrt((X+1)*(X-1))
        // So acosh1p(x) = acosh(1+x)
        //               = log((1+x) + sqrt((1+x)+1)*((1+x)-1))
        //               = log1p(x + sqrt(x*(x+2))
        return log1p(x + Math.sqrt(x * (x+2.)));
    }


    /** hyperbolic tangent function */
    public static double
    tanh(double x)
    {
        // tanh(x) = sinh(x) / cosh(x)
        //         = (e^x - e^-x) / (e^x + e^-x)
        //         = (e^2x - 1) / (e^2x + 1)
        //         = expm1(2*x) / (expm1(2*x) + 2)
        // Note that overflows prematurely and incorrectly returns NaN
        // at +infinity, but it behaves well at -infinity and negative numbers,
        // so for the positive case just use the mirror image.
        if (x > 0.)
        {
            //return -tanh(-x); // works but unnecessary function call
            double u = expm1(2. * -x);
            return -(u / (u + 2.));
        }
        else
        {
            double u = expm1(2.*x);
            return u / (u + 2.);
        }
    }

    /** inverse hyperboiic sine function */
    public static double
    asinh(double x)
    {
        if (x == Double.NEGATIVE_INFINITY)
            return Double.NEGATIVE_INFINITY;
        if (x == Double.POSITIVE_INFINITY)
            return Double.POSITIVE_INFINITY;
        // To make it better behaved near 0
        // than the straightforward implementation:
        // asinh(x) = log(x + sqrt(x^2 + 1))
        //          = log1p(x + sqrt(x^2 + 1) - 1)
        //          = log1p(x + (sqrt(x^2+1)-1)*(sqrt(x^2+1)+1)/(sqrt(x^2+1)+1))
        //          = log1p(x + (x^2+1 - 1)/(sqrt(x^2+1)+1))
        //          = log1p(x + x^2 / (sqrt(x^2+1)+1))
        //          = log1p(x * (1 + x / (sqrt(x^2+1)+1) ))
        // That fixes it near 0:
        //     gnuplot> plot [-1e-15:1e-15] asinh(x), asinh_smart(x)
        // However, for some reason the formula still isn't symmetric,
        // even though the function is symmetric, and furthermore
        // it behaves rather atrociously for large negative arguments:
        //     gnuplot> plot [-1e9:1e9] asinh(x), asinh_smart(x)
        // (where asinh_smart is the above).
        // (Note that gnuplot's is just as bad, and in fact seems to give up fairly early as well... XXX file a bug against gnuplot!)
        // Therefore we special case negative arguments.
        // XXX TODO: might want to switch to more naive log-based when args very large-- might be better behaved? not sure.
        // See https://code.google.com/p/v8/issues/detail?id=3468 and 3 derived bugs for possibly good ideas.
        // Also it looks like the python math library is well-thought-out
        // and probably gets it right:
        //     http://svn.python.org/projects/python/branches/pep-0384/Modules/_math.c
        // And in fact it explains some stuff!
        if (x >= 0)
            return log1p( x * (1. + x / (hypot(x,1.)+1.)));
        else
            return -log1p(-x * (1. - x / (hypot(x,1.)+1.)));
    }

    /** inverse hyperbolic cosine function */
    public static double
    acosh(double x)
    {
        // Only defined for x >= 1.

        // acosh(x) = log(x + sqrt(x^2 - 1))
        // Use the formula given by Kahan in
        // "Branch Cuts for Complex Elementary Functions",
        // as quoted by Cleve Moler in:
        // http://www.mathworks.com/company/newsletter/clevescorner/sum98cleve.shtml
        //
        // XXX possibly not nearly as good as it could be?
        // see https://code.google.com/p/v8/issues/detail?id=3509
        // it says:
        //      Math.acosh(1+1e-10) -> 0.000014142136208733941
        // the correct answer is 1.4142136208675862d-5.
        // They suggest what fdlibm uses (for x near 1):
        //      log(2x-1/(sqrt(x*x-1)+x))
        // That gives exactly the above answer, but... ?
        // Mine gives:
        //     1.4142136208643407e-05
        // But wolframalpha acosh(1+10^-10) says:
        //     .0000141421356236130993578217
        // HOWEVER... worlframalpha isn't really calculating the same thing.
        // How do I get it to?
        // Well... to start with, in python, let's get a mathematically exact
        // representation of (double)(1+1e-10):
        //      `(1+1e-10 - 1) * (1<<49)`
        //      '56295.0'
        // So that says that (double)(1+1e-10) is exactly 1+56295/2^49.
        // Feeding into wolframalpha:
        //      acosh(1+56295/2^49)
        // It says:
        //      .00001414213620867586 135459
        // Hmph!  So they were right in the bug description :-(
        // Except maybe the last digit?
        //      `.00001414213620867586135459`
        // Nope they were right in the last digit, too.
        // Hmph!  All right I guess I should use their formulation?

        // But WAIT a minute...
        // if acosh1p(u=x-1) is 2 * asinh(Math.sqrt(u/2))
        //    acosh(x) = acosh1p(x-1) = 2*asinh(sqrt((x-1)/2))
        // Yes!  In python:
        //    x = 1+1e-10
        //    from math import *
        //    2*asinh(sqrt((x-1)/2))
        // So: cosh1p(x) = 2*asinh(sqrt(x/2.))
        // So: cosh(x) = cosh1p(x-1) = 2*asinh(sqrt((x-1)/2.))
        // So, could use this, and it's just as accurate I think...
        // However I think it does one more sqrt than their formulation does.

        // OLD-- less good!
        // return 2 * Math.log(Math.sqrt((x+1)*.5) + Math.sqrt((x-1)*.5));

        // NEW-- better!
        // XXX TODO: add confidence test verifying it's very well behaved near 1, as shown above
        return acosh1p(x-1.);
    }

    /** inverse hyperbolic tangent function */
    public static double
    atanh(double x)
    {
        // Only defined for x < 1.

        // atanh(x) = log((1+x)/(1-x))/2
        //          = log((1 - x + 2x) / (1-x)) / 2
        //          = log(1 + 2x/(1-x)) / 2
        //          = log1p(2x/(1-x)) / 2
        // XXX https://code.google.com/p/v8/issues/detail?id=3266#c4  gives: 1/2*log1p(-2*x/(1+x))
        // XXX is that the same?? confused now.
        // XXX their derivation is:
        //      atanh(x) = 1/2*log((1-x)/(1+x))
        //               = 1/2 * log(1-2*x/(1+x))
        //               = 1/2*log1p(-2*x/(1+x))
        // But... is (1-x)/(1+x) equal to 1-2*x/(1+x) ?
        // oh wait!  did I mess up?
        // Oh! I see, mine is right in that it's log((1+x)/(1-x))/2 .
        // I think his is wrong since he's got (1-x)/(1+x) instead of (1+x)/(1-x).
        // (I added a comment about that).
        // Q: he conjectures log1p(x)/2-log1p(-x)/2 is more accurate than .5 * log1p(2.*x/(1.-x)) ... is that true?  I doubt it.
        // gnuplot:
        //      log1p(x) = log(1.+x) - ((1.+x-1.)-x)/(1.+x)
        //      plot [-1e-15:1e-15] log(1.+x), log1p(x)
        //      plot [-4e-305:4e-305] log(1.+x), log1p(x)
        //      atanh_1(x) = .5 * (log1p(x) - log1p(-x))
        //      atanh_2(x) = .5 * log1p(2*x/(1.-x))
        //      plot [-1e-15:1e-15] atanh(x), atanh_1(x)*1.1, atanh_2(x)*1.2
        // Can I argue:
        //      atanh_1 is subtracting two things, so it must be less accurate?
        //      especially when the two things being subtracted are nearly equal and large compared to zero?
        // note atanh is only defined strictly in (-1,1)...
        // Huh!  Here is some evidence for atan_1 being more accurate:
        //      EXACT(x) = sprintf("%.17g",x)
        //      print EXACT(atanh(1e-10)), ' ', EXACT(atanh_1(1e-10)), ' ', EXACT(atanh_2(1e-10))
        //        1.000000082540371e-10 1e-10 9.9999999999999991e-11
        // oh but wait-- are we sure 1e-10 is in fact the right answer???
        // Well, if ask wolframalpha for exactly atanh(1e-10),
        // then we get 1.000 ... (20 0's)...0003333333333 something something...
        // so I guess that's some evidence... but still not conclusive!
        // Q: how do I express (double)(1e-10) to wolframalpha?
        // (and I guess that's a general question about how to express arbitrary doubles)
        //     `1e-10 * (1<<34)`
        //     `1e-10 * (1<<34) - 1`
        // Recall analysis above:
        //                Well... to start with, in python, let's get a mathematically exact
        //                representation of (double)(1+1e-10):
        //                `(1+1e-10 - 1) * (1<<49)`
        //                '56295.0'
        //                So that says that (double)(1+1e-10) is exactly 1+56295/2^49.
        // So how do we get (double)1e-10 exactly?
        // I.e. to exactly 53 bits of precision... or so.
        //     `1e-10 * (1<<34)`
        //         '1.7179869184'
        //     `1e-10 * (1<<33)`
        //         '0.8589934592'
        // Then how many further, to get an integer?
        //     `1e-10 * (1<<33) * (1<<53)`
        //         '7737125245533627.0'
        // Okay that says that 1e-10 * (1<<33) is exactly:
        //      7737125245533627 / (1<<53)
        //      7737125245533627 / 77371252455336267181195264
        // So 1e-10 is exactly:
        //      = 7737125245533627 / 2^86
        //      = 1.00000000000000003643219731549...  (16 zeros)
        // And wolframalpha says:
        //     atanh(7737125245533627 / 2^86) = 1.000...(16 0's)...000364355306e-10
        //                               = 1.0000000000000000364355306e-10
        // which is indeed (double)1e-10 :-(
        // Dammit!  I think that does give evidence that
        // the one we are using is not as good!?  That sucks!
        // Surely I can still make a counterargument?
        // Like, they both suck, atanh_1 *happens* to give a better
        // answer for this one, but atanh_2 gives a better answer
        // for others.
        // Can we actually do an error analysis?
        // Also what are adjacent doubles?
        //       7737125245533626 / 2^86 = 9.99999999999999907185...e-11  (yeah that was my answer)
        //       7737125245533627 / 2^86 = 1.00000000000000003643219731549...e-10
        //       7737125245533628 / 2^86 = 1.0000000000000001656791680...e-10
        // mathematically correct answer = 1.0000000000000000364355306...e-10
        // bleah, so actually they hit it spot-on... *still* I want to argue it was by luck!!
        //     q(x) = sprintf('%.17g %.17g %.17g %.17g', x, atanh(x), atanh_1(x), atanh_2(x))
        // oh fooey, it isn't looking good...
        // atanh_1 always seems to get it spot on; atanh_2 either gets it spot on or is off by 1 ulp
        // (and it can be either too low or too high):
        //     gnuplot> print q(1e-10)
        //         1e-10 1.000000082540371e-10 1e-10 9.9999999999999991e-11
        //     gnuplot> print q(1e-12)
        //         9.9999999999999998e-13 1.0000333894291097e-12 9.9999999999999998e-13 9.9999999999999978e-13
        //     gnuplot> print q(1e-13)
        //         1e-13 9.9975583367475354e-14 1e-13 9.999999999999999e-14
        //     gnuplot> print q(1e-14)
        //         1e-14 9.9920072216262085e-15 1e-14 1.0000000000000002e-14
        // dammit!
        // wait wtf; my atanh_2 seems to systematically wrong?  why??
        //     Q = 1e-10
        //     q = 1e-25
        //     plot [Q-q:Q+q] x, atanh_1(x), atanh_2(x)
        //     q = 1e-15
        //     set samples 100001
        //     plot [Q-q:Q+q] atanh_1(x)-x, atanh_2(x)-x
        // That gives the picture.
        // So I guess atanh_2 really does screw up more often :-( bleah!
        // Well, atanh is:
        //      x + x^3/3 + x^5/5 + x^7/7 + x^9/9 + ...
        // Still wondering about the error analysis
        // and if there's an intuitive explanation.
        // Hmm is it that the two calls' average errors cancel out?
        // No that doesn't explain it, it seems like the *worst* case error will be *more*
        // than the worst case error from atanh_2, won't it?
        // Hmm can I find an example of that??
        // This is actually a pretty wacky example... the function's behavior
        // definitely aliases with the floating point representation,
        // and the proof may involve that.
        // Hmm let's break down what the successful one actually is:
        //      log1p(x) = log(1.+x) - ((1.+x-1.)-x)/(1.+x)
        //      atanh_1(x) = .5 * (log1p(x) - log1p(-x))
        // so that's:
        //      .5 * ((log(1+x) - ((x+1-1-x)/(1.+x)) - (log(1-x) -   (-x+1-1+x)/(1.-x))
        // huh, not helpful.
        return .5 * log1p(2.*x/(1.-x));
    }

    /** 1-cos(x), doesn't lose accuracy for small x */
    public static double
    cosf1(double x)
    {
        double sinHalfX = Math.sin(.5*x);
        return 2.*sinHalfX*sinHalfX;
    }
    /** acos(1-x), doesn't lose accuracy for small x */
    public static double
    acos1m(double x)
    {
        return 2.*Math.asin(Math.sqrt(.5*x));
    }

    /** sin(x)/x, but stable when small; same as sin_over_x(x). TODO: sincm1? */
    public static double
    sinc(double x)
    {
        //
        // It's 1 - x^2/3! + x^4/5! - ...
        // so if |x| is so small that 1-x^2/6 is indistinguishable from 1,
        // then the result will be indistinguishable from 1 too.
        //
        if (1. - x*x*(1/6.) == 1.)
        {
            //System.out.println("Ha! sin(x)/x("+x+") returning 1. instead of "+Math.sin(x)+"/"+x);
            return 1.;
        }
        else if (x == Double.NEGATIVE_INFINITY
              || x == Double.POSITIVE_INFINITY)
            return 0.;
        else
            return Math.sin(x)/x;
    }

    /** sin(x)/x, but stable when small; same as sinc(x). */
    public static double
    sin_over_x(double x)
    {
        return sinc(x);
    }

    /** sinh(x)/x, but stable when small */
    public static double
    sinh_over_x(double x)
    {
        //
        // It's 1 + x^2/3! + x^4/5! + ...
        //
        if (1. + x*x*(1/3.) == 1.)
        {
            //System.out.println("Ha! sinh(x)/x("+x+") returning 1. instead of "+Math.sin(x)+"/"+x);
            return 1.;
        }
        else if (x == Double.NEGATIVE_INFINITY
              || x == Double.POSITIVE_INFINITY)
            return Double.POSITIVE_INFINITY;
        else
            return sinh(x)/x;
    }

    /** asin(x)/x, but stable when small */
    public static double
    asin_over_x(double x)
    {
        // 1 + 1/6*x^2 + 3/40*x^4 + 5/112*x^6 + 35/1152*x^8 + 63/2816*x^10 + 231/13312*x^12 + ...
        if (1. + x*x*(1/3.) == 1.)
        {
            //System.out.println("Ha! asin(x)/x("+x+") returning 1. instead of "+MyMath.asin(x)+"/"+x);
            return 1.;
        }
        else
            return Math.asin(x)/x;
    }

    /** asinh(x)/x, but stable when small */
    public static double
    asinh_over_x(double x)
    {
        //
        // 1 - 1/6*x^2 + 3/40*x^4 - 5/112*x^6 + ...
        //
        if (1. - x*x*(1/6.) == 1.)
        {
            //System.out.println("Ha! asinh(x)/x("+x+") returning 1. instead of "+MyMath.asinh(x)+"/"+x);
            return 1.;
        }
        else if (x == Double.NEGATIVE_INFINITY
              || x == Double.POSITIVE_INFINITY)
            return 0.;
        else
            return sinh(x)/x;
    }

    /** (cosh(x)-1)/x^2, but stable when small */
    public static double
    cosf1_over_xx(double x)
    {
        double temp = sin_over_x(x*.5);
        return .5 * temp * temp;
    }

    /** (cosh(x)-1)/x^2, but stable when small */
    public static double
    coshm1_over_xx(double x)
    {
        double temp = sinh_over_x(x*.5);
        return .5 * temp * temp;
    }

    /** sqrt(x*x + y*y) but overflow/underflow proof. */
    public static double hypot(double x, double y)
    {
        x = Math.abs(x);
        y = Math.abs(y);
        double min, max;
        if (x < y)
        {
            min = x;
            max = y;
        }
        else
        {
            min = y;
            max = x;
        }
        if (min == 0.)
            return max;
        double min_over_max = min/max;
        return max * Math.sqrt(1. + min_over_max*min_over_max);
    }

    /** Lambert W function, that is, functional inverse of x = f(w) = w e^w.
    * http://blogs.mathworks.com/cleve/2013/09/02/the-lambert-w-function/
    * Copyright 2013 The MathWorks, Inc.
    */
    public static double lambertw(double x,
                                  int branch) // 0 means primary or upper, -1 means lower
    {
        if (Double.isNaN(x))
            return Double.NaN;
        double w;
        if (branch == 0)
            w = 1; // start above -1
        else if (branch == -1)
            w = -2; // start below -1
        else
            throw new IllegalArgumentException("MyMath.lambertw called with illegal branch "+branch);

        if (x <= -1./Math.E)
        {
            if (x < -1./Math.E)
                return Double.NaN; // either branch
            else
                return -1.; // so we get this one exact, on either branch; it would be pretty sloppy otherwise
        }
        if (branch == -1)
        {
            if (x > 0.)
                return Double.NaN;
            else if (x == 0.)
                return Double.NEGATIVE_INFINITY;
            // else strictly negative, so has a solution
        }
        else // if branch == 0
        {
            if (x == Double.POSITIVE_INFINITY)
                return Double.POSITIVE_INFINITY;
        }

        double v = Double.POSITIVE_INFINITY * w;
        while (Math.abs((w - v)/w) > 1e-8) // XXX do something different here? not sure
        //while (Math.abs((w - v)/w) > 0.) // XXX do something different here I think
        {
            v = w;
            double e = Math.exp(w);
            double f = w*e - x; // Iterate to make this quantity zero
            w -= f/(e*(w+1.) - (w+2.)*f/(2.*w+2.));
        }
        return w;
    }

    /**
    * Functional inverse of e^x/x.
    * http://www1.american.edu/cas/mathstat/People/kalman/pdffiles/glog.pdf
    * Wolfram Alpha says this -W(-1/x)
    * and empirically, it uses the opposite branch from the one we got.
    * Subtle point: if x is 0 or -0 and branch is -1, we return -infinity.
    * (another possibly valid choice would be -0->-infinity, +0->nan)
    */
    public static double glog(double x,
                              int branch)
    {
        // This is a subtle decision, but on branch -1,
        // I think we want to return -infinity if x is either 0 or -0.
        if (x == 0.)
            x = -0.; // so that we call lambertw on infinity rather than -infinity!

        int otherBranch = -1 - branch;
        return -lambertw(-1./x, -1-branch);
    }


    /* XXX just for unit testing sqr_difference. should probably make private, and access it through more obscure getDeclaredMethod() or make it a special case*/
    public static double sqr(double x) { return x*x; }
    public static double cub(double x) { return x*x*x; }

    private static boolean test_difference_function_common_code(java.lang.reflect.Method method,
                                                                java.lang.reflect.Method mathMethod,
                                                                Object[] methodArgs,
                                                                double T,
                                                                double t) {
        //System.out.println("                in test_difference_function_common_code(T="+T+", t="+t+")");
        boolean suspicious = false;
        //double tol = 1e-12;
        double tol = 1e-9; // was 1e-12, loosened for asin_difference(1, -1e-20) or acosh_difference(1, 1e-20), which have error approx sqrt(2)*1e-10
        // NOTE: The following three initializations aren't logically necessary,
        // but Eclipse warns without them (opensdk doesn't), so doing this to shut it up.
        double answer = 0., fT = 0., fTplust = 0.;
        {
            try
            {
                // In >=1.7 we have varargs and more implicit conversions so can say these (2 args):
                //   answer = (double)method.invoke(null, T, t);
                //   fT = (double)mathMethod.invoke(null, T);
                //   fTplust = (double)mathMethod.invoke(null, T+t);
                // or (3 args)::
                //   answer = (double)method.invoke(null, Tn, Td, t);
                //   fT = (double)mathMethod.invoke(null, Tn/Td);
                //   fTplust = (double)mathMethod.invoke(null, Tn/Td+t);

                // In <=1.4 there's no varargs and limited conversions so have to say:
                answer = ((Double)method.invoke(null, methodArgs)).doubleValue();
                fT = ((Double)mathMethod.invoke(null, new Object[]{Double.valueOf(T)})).doubleValue();
                fTplust = ((Double)mathMethod.invoke(null, new Object[]{Double.valueOf(T+t)})).doubleValue();
            }
            catch (IllegalArgumentException e) { do { if (!(false)) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1024 +"): " + "false" + ""); } while (false); }
            catch (IllegalAccessException e) { do { if (!(false)) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1025 +"): " + "false" + ""); } while (false); }
            catch (java.lang.reflect.InvocationTargetException e) { {System.out.print("        "); System.out.println("e.getCause()" + " = " + (e.getCause()));}; do { if (!(false)) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1026 +"): " + "false" + ""); } while (false); }
        }
        suspicious = (t!=0. && answer==0.); // suspicious that implemented naively   CBB: actually I don't think it's suspicious if this happens if T is infinite
        if (Double.isNaN(fTplust-fT))
        {
            // all bets off. smart version might give a good answer but we can't check it.
            // example of this is asinh where T is infinity and t is finite.
            if (Double.isNaN(answer))
                System.out.print("              good! (both NaN)");
            else
                System.out.print("              ok (naive is NaN, so can't check whether answer="+answer+" looks right");
        }
        else
        {
            do { if (!((answer)==(fTplust-fT)||Math.abs((answer)-(fTplust-fT))<=tol)) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1040 +"): " +"(" + "answer" + ")==(" + "fTplust-fT" + ")+-" + "tol" + "" +" ("+(answer)+" vs. "+(fTplust-fT)+" +- "+(tol)+")" +" (error = "+((answer)-(fTplust-fT))+")" ); } while (false);
            System.out.print("              good!"+(suspicious?" (BUT SUSPICIOUS!)":""));
        }
        //System.out.println("            out test_difference_common_code(T="+T+", t="+t+"), returning suspicious="+suspicious);
        return suspicious;
    }

    private static boolean test_difference_function_2args(String name, java.lang.reflect.Method method, java.lang.reflect.Method mathMethod, double T, double t)
    {
        //System.out.println("            in test_difference_function_2args("+name+", T="+T+", t="+t+")");
        System.out.print("            testing "+name+"("+T+", "+t+"): ");
        System.out.flush();
        boolean suspicious = test_difference_function_common_code(method, mathMethod, new Object[]{Double.valueOf(T), Double.valueOf(t)}, T, t);
        //System.out.println("            out test_difference_function_2args("+name+", T="+T+", t="+t+"), returning suspicious="+suspicious);
        System.out.println(", suspicious="+suspicious);
        return suspicious;
    }
    private static boolean test_difference_function_3args(String name, java.lang.reflect.Method method, java.lang.reflect.Method mathMethod, double Tn, double Td, double t)
    {
        //System.out.println("            in test_difference_function_3args("+name+", T="+Tn+"/"+Td+", t="+t+")");
        System.out.print("            testing "+name+"("+Tn+"/"+Td+", "+t+"): ");
        System.out.flush();
        boolean suspicious = test_difference_function_common_code(method, mathMethod, new Object[]{Double.valueOf(Tn), Double.valueOf(Td), Double.valueOf(t)}, Tn/Td, t);
        //System.out.println("            out test_difference_function_3args("+name+", T="+Tn+"/"+Td+", t="+t+"), returning suspicious="+suspicious);
        System.out.println(", suspicious="+suspicious);
        return suspicious;
    }

    public static void main(String args[])
    {
        System.out.println("    in MyMath.main");

        if (true)
        {
            // Difference tests.
            java.lang.reflect.Method[] methods = MyMath.class.getMethods();
            for (int i = 0; i < methods.length; ++i)
            {
                java.lang.reflect.Method method = methods[i];
                String name = method.getName();
                if (!name.endsWith("_difference"))
                    continue;
                Class<?>[] signature = method.getParameterTypes();
                System.out.println("    Testing "+name+" ("+signature.length+" args)");
                String prefix_function_name = name.substring(0, name.length()-"_difference".length());
                System.out.println("        prefix_function_name = "+prefix_function_name);
                if (false) // hard-coded.  change to true and mess with the condition below, to focus on just one, if desired
                {
                    if (!prefix_function_name.equals("acosh")) {
                        System.out.println("        not doing "+name+" because not acosh");
                        continue;
                    }
                }
                boolean suspicious = false;
                // Find prefix method, in MyMath or Math.
                // Some are in both (namely cosh,sinh,tanh, in java 1.5 and later).
                Class<?> mathClasses[] = {Math.class, MyMath.class};
                int nFound = 0;
                for (int iMathClass = 0; iMathClass < mathClasses.length; ++iMathClass)
                {
                    Class<?> mathClass = mathClasses[iMathClass];
                    java.lang.reflect.Method mathMethod = null;
                    try
                    {
                        mathMethod = mathClass.getMethod(prefix_function_name, double.class);
                    }
                    catch (NoSuchMethodException e)
                    {
                        System.out.println("        no method "+prefix_function_name+" in "+mathClass.getName());
                        continue;
                    }
                    nFound++;
                    System.out.println("        found "+mathMethod.getName()+" in "+mathClass.getName());
                    if (signature.length == 2)
                    {
                        double Ts[] = {-.5, 0., .1, .4, .5, .7, Math.sqrt(.5), .8, .9, 1., 1.1, Math.sqrt(2.)};
                        double ts[] = {-.1, -1e-20, 0., 1e-20, .1, .2};
                        for (int iT = 0; iT < Ts.length; ++iT)
                        for (int it = 0; it < ts.length; ++it)
                        {
                            double T = Ts[iT];
                            double t = ts[it];

                            if (prefix_function_name.equals("asin")
                             || prefix_function_name.equals("acos")) {
                                // Cases the tester doesn't handle well:
                                // when T+t is slightly >1 (and therefore outside asin's domain)
                                // even though the nearest expressible double is 1.
                                // In these cases asin_difference correctly produces NaN,
                                // but test_difference_function_2args incorrectly requires something else to happen.
                                // Examples are:
                                //   T=.8 t=.2
                                //   T=.9 t=.1
                                //   T=1 t=1e-20
                                // The following test is probably not reliable in general, but it does catch those cases.
                                if (T<=1 && T+t==1 && (1-T<t || 1-t<T)) {
                                  System.out.println("            smoke testing "+name+"("+T+", "+t+")");
                                  do { if (!Double.isNaN(asin_difference(T,t))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1137 +"): " + "asin_difference(T,t)" + " is "+(asin_difference(T,t))+", expected NaN"); } while (false);
                                  do { if (!(Double_isFinite(Math.asin(T+t)-Math.asin(T)))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1138 +"): " + "Double_isFinite(Math.asin(T+t)-Math.asin(T))" + ""); } while (false);
                                  continue;
                                }
                            }

                            boolean suspicious1 = test_difference_function_2args(name, method, mathMethod, T, t);
                            if (suspicious1)
                                suspicious = true;
                        }
                    }
                    else if (signature.length == 3)
                    {
                        double Tns[] = {-.5, 0., .3, .5, .7, 1., 1.5, 2.};
                        double Tds[] = {0., .3, .5, .7, 1., 1.5, 2.};
                        double ts[] = {-.1, -1e-20, 0., 1e-20, .1, .2};

                        for (int iTn = 0; iTn < Tns.length; ++iTn)
                        for (int iTd = 0; iTd < Tds.length; ++iTd)
                        for (int it = 0; it < ts.length; ++it)
                        {
                            double Tn = Tns[iTn];
                            double Td = Tds[iTd];
                            double t = ts[it];
                            if (Tn==0. && Td==0.)
                               continue;

                            // I think I disabled the following simply because it gets boring with all the NaNs,
                            // even though it works.
                            // TODO: maybe add 1 to all the T's?  it's not that trivial, need to think about it
                            if (name.startsWith("cosh")
                             && ((Tn>=0&&Td>=0&&Tn<Td) // T < 1.
                              || (Tn+t*Td<Td))) // T+t<1 i.e. Tn/Td+t<1 i.e. Tn+t*Td<Td
                                continue;

                            if (prefix_function_name.equals("acosh")) {
                              // Same issue as for asin and acos, but in this case acosh is undefined
                              // for <1 instead of >1.
                              // The bad example is: T=1 t=-1e-20
                              if (Tn/Td==1 && Tn/Td+t==1 && t<0) {
                                  System.out.println("            smoke testing "+name+"("+Tn+"/"+Td+", "+t+")");
                                  do { if (!Double.isNaN(acosh_difference(Tn,Td, t))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1178 +"): " + "acosh_difference(Tn,Td, t)" + " is "+(acosh_difference(Tn,Td, t))+", expected NaN"); } while (false);
                                  continue;
                              }
                            }

                            boolean suspicious1 = test_difference_function_3args(name, method, mathMethod, Tn, Td, t);
                            if (suspicious1)
                                suspicious = true;
                        }
                    }
                    else
                        do { if (!(false)) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1189 +"): " + "false" + ""); } while (false);
                }
                do { if (!((nFound)>(0))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1191 +"): (" + "nFound" + ")" + ">" + "(" + "0" + ") ("+(nFound)+" vs. "+(0)+")"); } while (false);
                {System.out.print("        "); System.out.println("suspicious" + " = " + (suspicious));};
                if (nFound == 2)
                {
                    System.out.println("found "+prefix_function_name+" in both Math and MyMath");
                    // The following reflects the state of Math and MyMath as of this writing.
                    // If it ever fails, just add the new cases.
                    do { if (!(prefix_function_name.equals("cosh") || prefix_function_name.equals("sinh") || prefix_function_name.equals("tanh"))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1198 +"): " + "prefix_function_name.equals(\"cosh\") || prefix_function_name.equals(\"sinh\") || prefix_function_name.equals(\"tanh\")" + ""); } while (false)

                                                              ;
                }
            }
            if (false)
            {
                System.out.println("WARNING: exiting early!");
                System.exit(1);
            }
        }

        do { if (!((Math.exp(Double.NEGATIVE_INFINITY))==(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1210 +"): (" + "Math.exp(Double.NEGATIVE_INFINITY)" + ")" + "==" + "(" + "0." + ") ("+(Math.exp(Double.NEGATIVE_INFINITY))+" vs. "+(0.)+")"); } while (false);
        do { if (!((Math.exp(-1.))==(1./Math.E))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1211 +"): (" + "Math.exp(-1.)" + ")" + "==" + "(" + "1./Math.E" + ") ("+(Math.exp(-1.))+" vs. "+(1./Math.E)+")"); } while (false);
        do { if (!((Math.exp(0.))==(1.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1212 +"): (" + "Math.exp(0.)" + ")" + "==" + "(" + "1." + ") ("+(Math.exp(0.))+" vs. "+(1.)+")"); } while (false);
        do { if (!((Math.exp(1.))==(Math.E))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1213 +"): (" + "Math.exp(1.)" + ")" + "==" + "(" + "Math.E" + ") ("+(Math.exp(1.))+" vs. "+(Math.E)+")"); } while (false);
        do { if (!((Math.exp(Double.POSITIVE_INFINITY))==(Double.POSITIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1214 +"): (" + "Math.exp(Double.POSITIVE_INFINITY)" + ")" + "==" + "(" + "Double.POSITIVE_INFINITY" + ") ("+(Math.exp(Double.POSITIVE_INFINITY))+" vs. "+(Double.POSITIVE_INFINITY)+")"); } while (false);

        do { if (!Double.isNaN(Math.log(Double.NEGATIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1216 +"): " + "Math.log(Double.NEGATIVE_INFINITY)" + " is "+(Math.log(Double.NEGATIVE_INFINITY))+", expected NaN"); } while (false);
        do { if (!((Math.log(0.))==(Double.NEGATIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1217 +"): (" + "Math.log(0.)" + ")" + "==" + "(" + "Double.NEGATIVE_INFINITY" + ") ("+(Math.log(0.))+" vs. "+(Double.NEGATIVE_INFINITY)+")"); } while (false);
        do { if (!((Math.log(1./Math.E))==(-1.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1218 +"): (" + "Math.log(1./Math.E)" + ")" + "==" + "(" + "-1." + ") ("+(Math.log(1./Math.E))+" vs. "+(-1.)+")"); } while (false);
        do { if (!((Math.log(1.))==(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1219 +"): (" + "Math.log(1.)" + ")" + "==" + "(" + "0." + ") ("+(Math.log(1.))+" vs. "+(0.)+")"); } while (false);
        do { if (!((Math.log(Math.E))==(1.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1220 +"): (" + "Math.log(Math.E)" + ")" + "==" + "(" + "1." + ") ("+(Math.log(Math.E))+" vs. "+(1.)+")"); } while (false);
        do { if (!((Math.log(Double.POSITIVE_INFINITY))==(Double.POSITIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1221 +"): (" + "Math.log(Double.POSITIVE_INFINITY)" + ")" + "==" + "(" + "Double.POSITIVE_INFINITY" + ") ("+(Math.log(Double.POSITIVE_INFINITY))+" vs. "+(Double.POSITIVE_INFINITY)+")"); } while (false);

        do { if (!((MyMath.expm1(Double.NEGATIVE_INFINITY))==(-1.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1223 +"): (" + "MyMath.expm1(Double.NEGATIVE_INFINITY)" + ")" + "==" + "(" + "-1." + ") ("+(MyMath.expm1(Double.NEGATIVE_INFINITY))+" vs. "+(-1.)+")"); } while (false);
        do { if (!((MyMath.expm1(0.))==(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1224 +"): (" + "MyMath.expm1(0.)" + ")" + "==" + "(" + "0." + ") ("+(MyMath.expm1(0.))+" vs. "+(0.)+")"); } while (false);
        do { if (!((MyMath.expm1(Double.POSITIVE_INFINITY))==(Double.POSITIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1225 +"): (" + "MyMath.expm1(Double.POSITIVE_INFINITY)" + ")" + "==" + "(" + "Double.POSITIVE_INFINITY" + ") ("+(MyMath.expm1(Double.POSITIVE_INFINITY))+" vs. "+(Double.POSITIVE_INFINITY)+")"); } while (false);

        do { if (!Double.isNaN(MyMath.log1p(Double.NEGATIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1227 +"): " + "MyMath.log1p(Double.NEGATIVE_INFINITY)" + " is "+(MyMath.log1p(Double.NEGATIVE_INFINITY))+", expected NaN"); } while (false);
        do { if (!((MyMath.log1p(-1.))==(Double.NEGATIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1228 +"): (" + "MyMath.log1p(-1.)" + ")" + "==" + "(" + "Double.NEGATIVE_INFINITY" + ") ("+(MyMath.log1p(-1.))+" vs. "+(Double.NEGATIVE_INFINITY)+")"); } while (false);
        do { if (!((MyMath.log1p(0.))==(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1229 +"): (" + "MyMath.log1p(0.)" + ")" + "==" + "(" + "0." + ") ("+(MyMath.log1p(0.))+" vs. "+(0.)+")"); } while (false);
        do { if (!((MyMath.log1p(Double.POSITIVE_INFINITY))==(Double.POSITIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1230 +"): (" + "MyMath.log1p(Double.POSITIVE_INFINITY)" + ")" + "==" + "(" + "Double.POSITIVE_INFINITY" + ") ("+(MyMath.log1p(Double.POSITIVE_INFINITY))+" vs. "+(Double.POSITIVE_INFINITY)+")"); } while (false);

        do { if (!((MyMath.sinh(Double.NEGATIVE_INFINITY))==(Double.NEGATIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1232 +"): (" + "MyMath.sinh(Double.NEGATIVE_INFINITY)" + ")" + "==" + "(" + "Double.NEGATIVE_INFINITY" + ") ("+(MyMath.sinh(Double.NEGATIVE_INFINITY))+" vs. "+(Double.NEGATIVE_INFINITY)+")"); } while (false);
        do { if (!((MyMath.sinh(-.1))<(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1233 +"): (" + "MyMath.sinh(-.1)" + ")" + "<" + "(" + "0." + ") ("+(MyMath.sinh(-.1))+" vs. "+(0.)+")"); } while (false);
        do { if (!((MyMath.sinh(0.))==(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1234 +"): (" + "MyMath.sinh(0.)" + ")" + "==" + "(" + "0." + ") ("+(MyMath.sinh(0.))+" vs. "+(0.)+")"); } while (false);
        do { if (!((MyMath.sinh(.1))==(-MyMath.sinh(-.1)))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1235 +"): (" + "MyMath.sinh(.1)" + ")" + "==" + "(" + "-MyMath.sinh(-.1)" + ") ("+(MyMath.sinh(.1))+" vs. "+(-MyMath.sinh(-.1))+")"); } while (false);
        do { if (!((MyMath.sinh(Double.POSITIVE_INFINITY))==(Double.POSITIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1236 +"): (" + "MyMath.sinh(Double.POSITIVE_INFINITY)" + ")" + "==" + "(" + "Double.POSITIVE_INFINITY" + ") ("+(MyMath.sinh(Double.POSITIVE_INFINITY))+" vs. "+(Double.POSITIVE_INFINITY)+")"); } while (false);
        do { if (!((sinh_difference(-1.,0., -1.))==(Double.NEGATIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1237 +"): (" + "sinh_difference(-1.,0., -1.)" + ")" + "==" + "(" + "Double.NEGATIVE_INFINITY" + ") ("+(sinh_difference(-1.,0., -1.))+" vs. "+(Double.NEGATIVE_INFINITY)+")"); } while (false);
        do { if (!Double.isNaN(sinh_difference(-1.,0., 0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1238 +"): " + "sinh_difference(-1.,0., 0.)" + " is "+(sinh_difference(-1.,0., 0.))+", expected NaN"); } while (false);
        do { if (!((sinh_difference(-1.,0., 1.))==(Double.POSITIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1239 +"): (" + "sinh_difference(-1.,0., 1.)" + ")" + "==" + "(" + "Double.POSITIVE_INFINITY" + ") ("+(sinh_difference(-1.,0., 1.))+" vs. "+(Double.POSITIVE_INFINITY)+")"); } while (false);
        do { if (!((sinh_difference(1.,0., -1.))==(Double.NEGATIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1240 +"): (" + "sinh_difference(1.,0., -1.)" + ")" + "==" + "(" + "Double.NEGATIVE_INFINITY" + ") ("+(sinh_difference(1.,0., -1.))+" vs. "+(Double.NEGATIVE_INFINITY)+")"); } while (false);
        do { if (!Double.isNaN(sinh_difference(1.,0., 0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1241 +"): " + "sinh_difference(1.,0., 0.)" + " is "+(sinh_difference(1.,0., 0.))+", expected NaN"); } while (false);
        do { if (!((sinh_difference(1.,0., 1.))==(Double.POSITIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1242 +"): (" + "sinh_difference(1.,0., 1.)" + ")" + "==" + "(" + "Double.POSITIVE_INFINITY" + ") ("+(sinh_difference(1.,0., 1.))+" vs. "+(Double.POSITIVE_INFINITY)+")"); } while (false);

        do { if (!((MyMath.cosh(Double.NEGATIVE_INFINITY))==(Double.POSITIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1244 +"): (" + "MyMath.cosh(Double.NEGATIVE_INFINITY)" + ")" + "==" + "(" + "Double.POSITIVE_INFINITY" + ") ("+(MyMath.cosh(Double.NEGATIVE_INFINITY))+" vs. "+(Double.POSITIVE_INFINITY)+")"); } while (false);
        do { if (!((MyMath.cosh(-.1))>(1.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1245 +"): (" + "MyMath.cosh(-.1)" + ")" + ">" + "(" + "1." + ") ("+(MyMath.cosh(-.1))+" vs. "+(1.)+")"); } while (false);
        do { if (!((MyMath.cosh(0.))==(1.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1246 +"): (" + "MyMath.cosh(0.)" + ")" + "==" + "(" + "1." + ") ("+(MyMath.cosh(0.))+" vs. "+(1.)+")"); } while (false);
        do { if (!((MyMath.cosh(.1))==(MyMath.cosh(-.1)))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1247 +"): (" + "MyMath.cosh(.1)" + ")" + "==" + "(" + "MyMath.cosh(-.1)" + ") ("+(MyMath.cosh(.1))+" vs. "+(MyMath.cosh(-.1))+")"); } while (false);
        do { if (!((MyMath.cosh(Double.POSITIVE_INFINITY))==(Double.POSITIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1248 +"): (" + "MyMath.cosh(Double.POSITIVE_INFINITY)" + ")" + "==" + "(" + "Double.POSITIVE_INFINITY" + ") ("+(MyMath.cosh(Double.POSITIVE_INFINITY))+" vs. "+(Double.POSITIVE_INFINITY)+")"); } while (false);
        do { if (!((cosh_difference(-1.,0., -1.))==(Double.POSITIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1249 +"): (" + "cosh_difference(-1.,0., -1.)" + ")" + "==" + "(" + "Double.POSITIVE_INFINITY" + ") ("+(cosh_difference(-1.,0., -1.))+" vs. "+(Double.POSITIVE_INFINITY)+")"); } while (false);
        do { if (!Double.isNaN(cosh_difference(-1.,0., 0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1250 +"): " + "cosh_difference(-1.,0., 0.)" + " is "+(cosh_difference(-1.,0., 0.))+", expected NaN"); } while (false);
        do { if (!((cosh_difference(-1.,0., 1.))==(Double.NEGATIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1251 +"): (" + "cosh_difference(-1.,0., 1.)" + ")" + "==" + "(" + "Double.NEGATIVE_INFINITY" + ") ("+(cosh_difference(-1.,0., 1.))+" vs. "+(Double.NEGATIVE_INFINITY)+")"); } while (false);
        do { if (!((cosh_difference(1.,0., -1.))==(Double.NEGATIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1252 +"): (" + "cosh_difference(1.,0., -1.)" + ")" + "==" + "(" + "Double.NEGATIVE_INFINITY" + ") ("+(cosh_difference(1.,0., -1.))+" vs. "+(Double.NEGATIVE_INFINITY)+")"); } while (false);
        do { if (!Double.isNaN(cosh_difference(1.,0., 0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1253 +"): " + "cosh_difference(1.,0., 0.)" + " is "+(cosh_difference(1.,0., 0.))+", expected NaN"); } while (false);
        do { if (!((cosh_difference(1.,0., 1.))==(Double.POSITIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1254 +"): (" + "cosh_difference(1.,0., 1.)" + ")" + "==" + "(" + "Double.POSITIVE_INFINITY" + ") ("+(cosh_difference(1.,0., 1.))+" vs. "+(Double.POSITIVE_INFINITY)+")"); } while (false);

        do { if (!((MyMath.tanh(Double.NEGATIVE_INFINITY))==(-1.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1256 +"): (" + "MyMath.tanh(Double.NEGATIVE_INFINITY)" + ")" + "==" + "(" + "-1." + ") ("+(MyMath.tanh(Double.NEGATIVE_INFINITY))+" vs. "+(-1.)+")"); } while (false);
        do { if (!((MyMath.tanh(-.1))<(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1257 +"): (" + "MyMath.tanh(-.1)" + ")" + "<" + "(" + "0." + ") ("+(MyMath.tanh(-.1))+" vs. "+(0.)+")"); } while (false);
        do { if (!((MyMath.tanh(0.))==(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1258 +"): (" + "MyMath.tanh(0.)" + ")" + "==" + "(" + "0." + ") ("+(MyMath.tanh(0.))+" vs. "+(0.)+")"); } while (false);
        do { if (!((MyMath.tanh(.1))==(-MyMath.tanh(-.1)))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1259 +"): (" + "MyMath.tanh(.1)" + ")" + "==" + "(" + "-MyMath.tanh(-.1)" + ") ("+(MyMath.tanh(.1))+" vs. "+(-MyMath.tanh(-.1))+")"); } while (false);
        do { if (!((MyMath.tanh(Double.POSITIVE_INFINITY))==(1.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1260 +"): (" + "MyMath.tanh(Double.POSITIVE_INFINITY)" + ")" + "==" + "(" + "1." + ") ("+(MyMath.tanh(Double.POSITIVE_INFINITY))+" vs. "+(1.)+")"); } while (false);
        do { if (!((tanh_difference(-1.,0., 0.))==(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1261 +"): (" + "tanh_difference(-1.,0., 0.)" + ")" + "==" + "(" + "0." + ") ("+(tanh_difference(-1.,0., 0.))+" vs. "+(0.)+")"); } while (false);
        do { if (!((tanh_difference(-1.,0., 1.))==(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1262 +"): (" + "tanh_difference(-1.,0., 1.)" + ")" + "==" + "(" + "0." + ") ("+(tanh_difference(-1.,0., 1.))+" vs. "+(0.)+")"); } while (false);
        do { if (!((tanh_difference(-1.,0., -1.))==(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1263 +"): (" + "tanh_difference(-1.,0., -1.)" + ")" + "==" + "(" + "0." + ") ("+(tanh_difference(-1.,0., -1.))+" vs. "+(0.)+")"); } while (false);
        do { if (!((tanh_difference(0.,1., -1.))<(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1264 +"): (" + "tanh_difference(0.,1., -1.)" + ")" + "<" + "(" + "0." + ") ("+(tanh_difference(0.,1., -1.))+" vs. "+(0.)+")"); } while (false);
        do { if (!((tanh_difference(0.,1., 0.))==(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1265 +"): (" + "tanh_difference(0.,1., 0.)" + ")" + "==" + "(" + "0." + ") ("+(tanh_difference(0.,1., 0.))+" vs. "+(0.)+")"); } while (false);
        do { if (!((tanh_difference(0.,1., 1.))>(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1266 +"): (" + "tanh_difference(0.,1., 1.)" + ")" + ">" + "(" + "0." + ") ("+(tanh_difference(0.,1., 1.))+" vs. "+(0.)+")"); } while (false);
        do { if (!((tanh_difference(1.,0., 0.))==(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1267 +"): (" + "tanh_difference(1.,0., 0.)" + ")" + "==" + "(" + "0." + ") ("+(tanh_difference(1.,0., 0.))+" vs. "+(0.)+")"); } while (false);
        do { if (!((tanh_difference(1.,0., 1.))==(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1268 +"): (" + "tanh_difference(1.,0., 1.)" + ")" + "==" + "(" + "0." + ") ("+(tanh_difference(1.,0., 1.))+" vs. "+(0.)+")"); } while (false);
        do { if (!((tanh_difference(1.,0., -1.))==(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1269 +"): (" + "tanh_difference(1.,0., -1.)" + ")" + "==" + "(" + "0." + ") ("+(tanh_difference(1.,0., -1.))+" vs. "+(0.)+")"); } while (false);

        do { if (!((MyMath.asinh(Double.NEGATIVE_INFINITY))==(Double.NEGATIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1271 +"): (" + "MyMath.asinh(Double.NEGATIVE_INFINITY)" + ")" + "==" + "(" + "Double.NEGATIVE_INFINITY" + ") ("+(MyMath.asinh(Double.NEGATIVE_INFINITY))+" vs. "+(Double.NEGATIVE_INFINITY)+")"); } while (false);
        do { if (!((MyMath.asinh(-.1))<(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1272 +"): (" + "MyMath.asinh(-.1)" + ")" + "<" + "(" + "0." + ") ("+(MyMath.asinh(-.1))+" vs. "+(0.)+")"); } while (false);
        do { if (!((MyMath.asinh(0.))==(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1273 +"): (" + "MyMath.asinh(0.)" + ")" + "==" + "(" + "0." + ") ("+(MyMath.asinh(0.))+" vs. "+(0.)+")"); } while (false);
        do { if (!((MyMath.asinh(.1))==(-MyMath.asinh(-.1)))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1274 +"): (" + "MyMath.asinh(.1)" + ")" + "==" + "(" + "-MyMath.asinh(-.1)" + ") ("+(MyMath.asinh(.1))+" vs. "+(-MyMath.asinh(-.1))+")"); } while (false);
        do { if (!((MyMath.asinh(Double.POSITIVE_INFINITY))==(Double.POSITIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1275 +"): (" + "MyMath.asinh(Double.POSITIVE_INFINITY)" + ")" + "==" + "(" + "Double.POSITIVE_INFINITY" + ") ("+(MyMath.asinh(Double.POSITIVE_INFINITY))+" vs. "+(Double.POSITIVE_INFINITY)+")"); } while (false);
        do { if (!((asinh_difference(-1.,0., 0.))==(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1276 +"): (" + "asinh_difference(-1.,0., 0.)" + ")" + "==" + "(" + "0." + ") ("+(asinh_difference(-1.,0., 0.))+" vs. "+(0.)+")"); } while (false);
        do { if (!((asinh_difference(-1.,0., 1.))==(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1277 +"): (" + "asinh_difference(-1.,0., 1.)" + ")" + "==" + "(" + "0." + ") ("+(asinh_difference(-1.,0., 1.))+" vs. "+(0.)+")"); } while (false);
        do { if (!((asinh_difference(-1.,0., -1.))==(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1278 +"): (" + "asinh_difference(-1.,0., -1.)" + ")" + "==" + "(" + "0." + ") ("+(asinh_difference(-1.,0., -1.))+" vs. "+(0.)+")"); } while (false);
        do { if (!((asinh_difference(1.,0., 0.))==(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1279 +"): (" + "asinh_difference(1.,0., 0.)" + ")" + "==" + "(" + "0." + ") ("+(asinh_difference(1.,0., 0.))+" vs. "+(0.)+")"); } while (false);
        do { if (!((asinh_difference(1.,0., 1.))==(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1280 +"): (" + "asinh_difference(1.,0., 1.)" + ")" + "==" + "(" + "0." + ") ("+(asinh_difference(1.,0., 1.))+" vs. "+(0.)+")"); } while (false);
        do { if (!((asinh_difference(1.,0., -1.))==(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1281 +"): (" + "asinh_difference(1.,0., -1.)" + ")" + "==" + "(" + "0." + ") ("+(asinh_difference(1.,0., -1.))+" vs. "+(0.)+")"); } while (false);

        do { if (!Double.isNaN(MyMath.acosh(Double.NEGATIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1283 +"): " + "MyMath.acosh(Double.NEGATIVE_INFINITY)" + " is "+(MyMath.acosh(Double.NEGATIVE_INFINITY))+", expected NaN"); } while (false);
        do { if (!Double.isNaN(MyMath.acosh(-1.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1284 +"): " + "MyMath.acosh(-1.)" + " is "+(MyMath.acosh(-1.))+", expected NaN"); } while (false);
        do { if (!Double.isNaN(MyMath.acosh(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1285 +"): " + "MyMath.acosh(0.)" + " is "+(MyMath.acosh(0.))+", expected NaN"); } while (false);
        do { if (!Double.isNaN(MyMath.acosh(.9))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1286 +"): " + "MyMath.acosh(.9)" + " is "+(MyMath.acosh(.9))+", expected NaN"); } while (false);
        do { if (!((MyMath.acosh(1.))==(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1287 +"): (" + "MyMath.acosh(1.)" + ")" + "==" + "(" + "0." + ") ("+(MyMath.acosh(1.))+" vs. "+(0.)+")"); } while (false);
        do { if (!((MyMath.acosh(1.1))>(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1288 +"): (" + "MyMath.acosh(1.1)" + ")" + ">" + "(" + "0." + ") ("+(MyMath.acosh(1.1))+" vs. "+(0.)+")"); } while (false);
        do { if (!((MyMath.acosh(Double.POSITIVE_INFINITY))==(Double.POSITIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1289 +"): (" + "MyMath.acosh(Double.POSITIVE_INFINITY)" + ")" + "==" + "(" + "Double.POSITIVE_INFINITY" + ") ("+(MyMath.acosh(Double.POSITIVE_INFINITY))+" vs. "+(Double.POSITIVE_INFINITY)+")"); } while (false);
        do { if (!Double.isNaN(acosh_difference(-1.,0., 0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1290 +"): " + "acosh_difference(-1.,0., 0.)" + " is "+(acosh_difference(-1.,0., 0.))+", expected NaN"); } while (false);
        do { if (!Double.isNaN(acosh_difference(-1.,0., 1.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1291 +"): " + "acosh_difference(-1.,0., 1.)" + " is "+(acosh_difference(-1.,0., 1.))+", expected NaN"); } while (false);
        do { if (!Double.isNaN(acosh_difference(-1.,0., -1.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1292 +"): " + "acosh_difference(-1.,0., -1.)" + " is "+(acosh_difference(-1.,0., -1.))+", expected NaN"); } while (false);
        do { if (!((acosh_difference(1.,0., 0.))==(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1293 +"): (" + "acosh_difference(1.,0., 0.)" + ")" + "==" + "(" + "0." + ") ("+(acosh_difference(1.,0., 0.))+" vs. "+(0.)+")"); } while (false);
        do { if (!((acosh_difference(1.,0., 1.))==(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1294 +"): (" + "acosh_difference(1.,0., 1.)" + ")" + "==" + "(" + "0." + ") ("+(acosh_difference(1.,0., 1.))+" vs. "+(0.)+")"); } while (false);
        do { if (!((acosh_difference(1.,0., -1.))==(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1295 +"): (" + "acosh_difference(1.,0., -1.)" + ")" + "==" + "(" + "0." + ") ("+(acosh_difference(1.,0., -1.))+" vs. "+(0.)+")"); } while (false);

        do { if (!Double.isNaN(MyMath.atanh(Double.NEGATIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1297 +"): " + "MyMath.atanh(Double.NEGATIVE_INFINITY)" + " is "+(MyMath.atanh(Double.NEGATIVE_INFINITY))+", expected NaN"); } while (false);
        do { if (!Double.isNaN(MyMath.atanh(-1.1))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1298 +"): " + "MyMath.atanh(-1.1)" + " is "+(MyMath.atanh(-1.1))+", expected NaN"); } while (false);
        do { if (!((MyMath.atanh(-1.))==(Double.NEGATIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1299 +"): (" + "MyMath.atanh(-1.)" + ")" + "==" + "(" + "Double.NEGATIVE_INFINITY" + ") ("+(MyMath.atanh(-1.))+" vs. "+(Double.NEGATIVE_INFINITY)+")"); } while (false);
        do { if (!((MyMath.atanh(-.1))<(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1300 +"): (" + "MyMath.atanh(-.1)" + ")" + "<" + "(" + "0." + ") ("+(MyMath.atanh(-.1))+" vs. "+(0.)+")"); } while (false);
        do { if (!((MyMath.atanh(0.))==(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1301 +"): (" + "MyMath.atanh(0.)" + ")" + "==" + "(" + "0." + ") ("+(MyMath.atanh(0.))+" vs. "+(0.)+")"); } while (false);
        do { if (!((MyMath.atanh(.1))==(-MyMath.atanh(-.1)))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1302 +"): (" + "MyMath.atanh(.1)" + ")" + "==" + "(" + "-MyMath.atanh(-.1)" + ") ("+(MyMath.atanh(.1))+" vs. "+(-MyMath.atanh(-.1))+")"); } while (false);
        do { if (!((MyMath.atanh(1.))==(Double.POSITIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1303 +"): (" + "MyMath.atanh(1.)" + ")" + "==" + "(" + "Double.POSITIVE_INFINITY" + ") ("+(MyMath.atanh(1.))+" vs. "+(Double.POSITIVE_INFINITY)+")"); } while (false);
        do { if (!Double.isNaN(MyMath.atanh(1.1))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1304 +"): " + "MyMath.atanh(1.1)" + " is "+(MyMath.atanh(1.1))+", expected NaN"); } while (false);
        do { if (!Double.isNaN(MyMath.atanh(Double.POSITIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1305 +"): " + "MyMath.atanh(Double.POSITIVE_INFINITY)" + " is "+(MyMath.atanh(Double.POSITIVE_INFINITY))+", expected NaN"); } while (false);
        do { if (!((atanh_difference(-1., .1))==(Double.POSITIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1306 +"): (" + "atanh_difference(-1., .1)" + ")" + "==" + "(" + "Double.POSITIVE_INFINITY" + ") ("+(atanh_difference(-1., .1))+" vs. "+(Double.POSITIVE_INFINITY)+")"); } while (false);
        do { if (!((atanh_difference(1., -.1))==(Double.NEGATIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1307 +"): (" + "atanh_difference(1., -.1)" + ")" + "==" + "(" + "Double.NEGATIVE_INFINITY" + ") ("+(atanh_difference(1., -.1))+" vs. "+(Double.NEGATIVE_INFINITY)+")"); } while (false);

        do { if (!((Math.atan(Double.NEGATIVE_INFINITY))==(-Math.PI/2))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1309 +"): (" + "Math.atan(Double.NEGATIVE_INFINITY)" + ")" + "==" + "(" + "-Math.PI/2" + ") ("+(Math.atan(Double.NEGATIVE_INFINITY))+" vs. "+(-Math.PI/2)+")"); } while (false);
        do { if (!((Math.atan(-1.))<(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1310 +"): (" + "Math.atan(-1.)" + ")" + "<" + "(" + "0." + ") ("+(Math.atan(-1.))+" vs. "+(0.)+")"); } while (false);
        do { if (!((Math.atan(0.))==(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1311 +"): (" + "Math.atan(0.)" + ")" + "==" + "(" + "0." + ") ("+(Math.atan(0.))+" vs. "+(0.)+")"); } while (false);
        do { if (!((Math.atan(1.))>(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1312 +"): (" + "Math.atan(1.)" + ")" + ">" + "(" + "0." + ") ("+(Math.atan(1.))+" vs. "+(0.)+")"); } while (false);
        do { if (!((Math.atan(Double.POSITIVE_INFINITY))==(Math.PI/2))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1313 +"): (" + "Math.atan(Double.POSITIVE_INFINITY)" + ")" + "==" + "(" + "Math.PI/2" + ") ("+(Math.atan(Double.POSITIVE_INFINITY))+" vs. "+(Math.PI/2)+")"); } while (false);
        do { if (!((atan_difference(-1.,0., -1.))==(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1314 +"): (" + "atan_difference(-1.,0., -1.)" + ")" + "==" + "(" + "0." + ") ("+(atan_difference(-1.,0., -1.))+" vs. "+(0.)+")"); } while (false);
        do { if (!((atan_difference(-1.,0., 0.))==(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1315 +"): (" + "atan_difference(-1.,0., 0.)" + ")" + "==" + "(" + "0." + ") ("+(atan_difference(-1.,0., 0.))+" vs. "+(0.)+")"); } while (false);
        do { if (!((atan_difference(-1.,0., 1.))==(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1316 +"): (" + "atan_difference(-1.,0., 1.)" + ")" + "==" + "(" + "0." + ") ("+(atan_difference(-1.,0., 1.))+" vs. "+(0.)+")"); } while (false);
        do { if (!((atan_difference(1.,0., -1.))==(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1317 +"): (" + "atan_difference(1.,0., -1.)" + ")" + "==" + "(" + "0." + ") ("+(atan_difference(1.,0., -1.))+" vs. "+(0.)+")"); } while (false);
        do { if (!((atan_difference(1.,0., 0.))==(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1318 +"): (" + "atan_difference(1.,0., 0.)" + ")" + "==" + "(" + "0." + ") ("+(atan_difference(1.,0., 0.))+" vs. "+(0.)+")"); } while (false);
        do { if (!((atan_difference(1.,0., 1.))==(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1319 +"): (" + "atan_difference(1.,0., 1.)" + ")" + "==" + "(" + "0." + ") ("+(atan_difference(1.,0., 1.))+" vs. "+(0.)+")"); } while (false);

        do { if (!((MyMath.coshm1(Double.NEGATIVE_INFINITY))==(Double.POSITIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1321 +"): (" + "MyMath.coshm1(Double.NEGATIVE_INFINITY)" + ")" + "==" + "(" + "Double.POSITIVE_INFINITY" + ") ("+(MyMath.coshm1(Double.NEGATIVE_INFINITY))+" vs. "+(Double.POSITIVE_INFINITY)+")"); } while (false);
        do { if (!((MyMath.coshm1(-.1))>(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1322 +"): (" + "MyMath.coshm1(-.1)" + ")" + ">" + "(" + "0." + ") ("+(MyMath.coshm1(-.1))+" vs. "+(0.)+")"); } while (false);
        do { if (!((MyMath.coshm1(0.))==(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1323 +"): (" + "MyMath.coshm1(0.)" + ")" + "==" + "(" + "0." + ") ("+(MyMath.coshm1(0.))+" vs. "+(0.)+")"); } while (false);
        do { if (!((MyMath.coshm1(.1))==(MyMath.coshm1(-.1)))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1324 +"): (" + "MyMath.coshm1(.1)" + ")" + "==" + "(" + "MyMath.coshm1(-.1)" + ") ("+(MyMath.coshm1(.1))+" vs. "+(MyMath.coshm1(-.1))+")"); } while (false);
        do { if (!((MyMath.coshm1(Double.POSITIVE_INFINITY))==(Double.POSITIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1325 +"): (" + "MyMath.coshm1(Double.POSITIVE_INFINITY)" + ")" + "==" + "(" + "Double.POSITIVE_INFINITY" + ") ("+(MyMath.coshm1(Double.POSITIVE_INFINITY))+" vs. "+(Double.POSITIVE_INFINITY)+")"); } while (false);

        do { if (!Double.isNaN(MyMath.acosh1p(Double.NEGATIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1327 +"): " + "MyMath.acosh1p(Double.NEGATIVE_INFINITY)" + " is "+(MyMath.acosh1p(Double.NEGATIVE_INFINITY))+", expected NaN"); } while (false);
        do { if (!Double.isNaN(MyMath.acosh1p(-.1))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1328 +"): " + "MyMath.acosh1p(-.1)" + " is "+(MyMath.acosh1p(-.1))+", expected NaN"); } while (false);
        do { if (!((MyMath.acosh1p(0.))==(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1329 +"): (" + "MyMath.acosh1p(0.)" + ")" + "==" + "(" + "0." + ") ("+(MyMath.acosh1p(0.))+" vs. "+(0.)+")"); } while (false);
        do { if (!((MyMath.acosh1p(.1))>(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1330 +"): (" + "MyMath.acosh1p(.1)" + ")" + ">" + "(" + "0." + ") ("+(MyMath.acosh1p(.1))+" vs. "+(0.)+")"); } while (false);
        do { if (!((MyMath.acosh1p(Double.POSITIVE_INFINITY))==(Double.POSITIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1331 +"): (" + "MyMath.acosh1p(Double.POSITIVE_INFINITY)" + ")" + "==" + "(" + "Double.POSITIVE_INFINITY" + ") ("+(MyMath.acosh1p(Double.POSITIVE_INFINITY))+" vs. "+(Double.POSITIVE_INFINITY)+")"); } while (false);

        do { if (!((MyMath.sin_over_x(Double.NEGATIVE_INFINITY))==(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1333 +"): (" + "MyMath.sin_over_x(Double.NEGATIVE_INFINITY)" + ")" + "==" + "(" + "0." + ") ("+(MyMath.sin_over_x(Double.NEGATIVE_INFINITY))+" vs. "+(0.)+")"); } while (false);
        do { if (!((MyMath.sinh_over_x(Double.NEGATIVE_INFINITY))==(Double.POSITIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1334 +"): (" + "MyMath.sinh_over_x(Double.NEGATIVE_INFINITY)" + ")" + "==" + "(" + "Double.POSITIVE_INFINITY" + ") ("+(MyMath.sinh_over_x(Double.NEGATIVE_INFINITY))+" vs. "+(Double.POSITIVE_INFINITY)+")"); } while (false);
        do { if (!Double.isNaN(MyMath.asin_over_x(Double.NEGATIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1335 +"): " + "MyMath.asin_over_x(Double.NEGATIVE_INFINITY)" + " is "+(MyMath.asin_over_x(Double.NEGATIVE_INFINITY))+", expected NaN"); } while (false);
        do { if (!((MyMath.asinh_over_x(Double.NEGATIVE_INFINITY))==(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1336 +"): (" + "MyMath.asinh_over_x(Double.NEGATIVE_INFINITY)" + ")" + "==" + "(" + "0." + ") ("+(MyMath.asinh_over_x(Double.NEGATIVE_INFINITY))+" vs. "+(0.)+")"); } while (false);
        do { if (!((MyMath.cosf1_over_xx(Double.NEGATIVE_INFINITY))==(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1337 +"): (" + "MyMath.cosf1_over_xx(Double.NEGATIVE_INFINITY)" + ")" + "==" + "(" + "0." + ") ("+(MyMath.cosf1_over_xx(Double.NEGATIVE_INFINITY))+" vs. "+(0.)+")"); } while (false);
        do { if (!((MyMath.coshm1_over_xx(Double.NEGATIVE_INFINITY))==(Double.POSITIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1338 +"): (" + "MyMath.coshm1_over_xx(Double.NEGATIVE_INFINITY)" + ")" + "==" + "(" + "Double.POSITIVE_INFINITY" + ") ("+(MyMath.coshm1_over_xx(Double.NEGATIVE_INFINITY))+" vs. "+(Double.POSITIVE_INFINITY)+")"); } while (false);

        do { if (!((MyMath.sin_over_x(0.))==(1.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1340 +"): (" + "MyMath.sin_over_x(0.)" + ")" + "==" + "(" + "1." + ") ("+(MyMath.sin_over_x(0.))+" vs. "+(1.)+")"); } while (false);
        do { if (!((MyMath.sinh_over_x(0.))==(1.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1341 +"): (" + "MyMath.sinh_over_x(0.)" + ")" + "==" + "(" + "1." + ") ("+(MyMath.sinh_over_x(0.))+" vs. "+(1.)+")"); } while (false);
        do { if (!((MyMath.asin_over_x(0.))==(1.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1342 +"): (" + "MyMath.asin_over_x(0.)" + ")" + "==" + "(" + "1." + ") ("+(MyMath.asin_over_x(0.))+" vs. "+(1.)+")"); } while (false);
        do { if (!((MyMath.asinh_over_x(0.))==(1.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1343 +"): (" + "MyMath.asinh_over_x(0.)" + ")" + "==" + "(" + "1." + ") ("+(MyMath.asinh_over_x(0.))+" vs. "+(1.)+")"); } while (false);
        do { if (!((MyMath.cosf1_over_xx(0.))==(.5))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1344 +"): (" + "MyMath.cosf1_over_xx(0.)" + ")" + "==" + "(" + ".5" + ") ("+(MyMath.cosf1_over_xx(0.))+" vs. "+(.5)+")"); } while (false);
        do { if (!((MyMath.coshm1_over_xx(0.))==(.5))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1345 +"): (" + "MyMath.coshm1_over_xx(0.)" + ")" + "==" + "(" + ".5" + ") ("+(MyMath.coshm1_over_xx(0.))+" vs. "+(.5)+")"); } while (false);

        do { if (!((MyMath.sin_over_x(Double.POSITIVE_INFINITY))==(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1347 +"): (" + "MyMath.sin_over_x(Double.POSITIVE_INFINITY)" + ")" + "==" + "(" + "0." + ") ("+(MyMath.sin_over_x(Double.POSITIVE_INFINITY))+" vs. "+(0.)+")"); } while (false);
        do { if (!((MyMath.sinh_over_x(Double.POSITIVE_INFINITY))==(Double.POSITIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1348 +"): (" + "MyMath.sinh_over_x(Double.POSITIVE_INFINITY)" + ")" + "==" + "(" + "Double.POSITIVE_INFINITY" + ") ("+(MyMath.sinh_over_x(Double.POSITIVE_INFINITY))+" vs. "+(Double.POSITIVE_INFINITY)+")"); } while (false);
        do { if (!Double.isNaN(MyMath.asin_over_x(Double.POSITIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1349 +"): " + "MyMath.asin_over_x(Double.POSITIVE_INFINITY)" + " is "+(MyMath.asin_over_x(Double.POSITIVE_INFINITY))+", expected NaN"); } while (false);
        do { if (!((MyMath.asinh_over_x(Double.POSITIVE_INFINITY))==(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1350 +"): (" + "MyMath.asinh_over_x(Double.POSITIVE_INFINITY)" + ")" + "==" + "(" + "0." + ") ("+(MyMath.asinh_over_x(Double.POSITIVE_INFINITY))+" vs. "+(0.)+")"); } while (false);
        do { if (!((MyMath.cosf1_over_xx(Double.POSITIVE_INFINITY))==(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1351 +"): (" + "MyMath.cosf1_over_xx(Double.POSITIVE_INFINITY)" + ")" + "==" + "(" + "0." + ") ("+(MyMath.cosf1_over_xx(Double.POSITIVE_INFINITY))+" vs. "+(0.)+")"); } while (false);
        do { if (!((MyMath.coshm1_over_xx(Double.POSITIVE_INFINITY))==(Double.POSITIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1352 +"): (" + "MyMath.coshm1_over_xx(Double.POSITIVE_INFINITY)" + ")" + "==" + "(" + "Double.POSITIVE_INFINITY" + ") ("+(MyMath.coshm1_over_xx(Double.POSITIVE_INFINITY))+" vs. "+(Double.POSITIVE_INFINITY)+")"); } while (false);

        // TODO: all of the following is missing testing of all the *_over_x functions
        // TODO: all of the following is missing testing of asinh, probably lots more

        // first and last entries are big enough to overflow all the exp and hyperbolic trig functions
        double xs[] = {-1000, -100, -10, -1, -.1, 0, .1, 1, 10, 100, 1000};
        for (int i = 0; i < xs.length; ++i)
        {
            double x = xs[i];

            System.out.println("    exp("+x+") = "+Math.exp(x)+"");
            System.out.println("    expm1("+x+") = "+MyMath.expm1(x)+"");
            System.out.println("    sinh("+x+") = "+MyMath.sinh(x)+"");
            System.out.println("    cosh("+x+") = "+MyMath.cosh(x)+"");
            System.out.println("    coshm1("+x+") = "+MyMath.coshm1(x)+"");

            do { if (!((MyMath.expm1(x) + 1.)==(Math.exp(x) - 1. + 1.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1369 +"): (" + "MyMath.expm1(x) + 1." + ")" + "==" + "(" + "Math.exp(x) - 1. + 1." + ") ("+(MyMath.expm1(x) + 1.)+" vs. "+(Math.exp(x) - 1. + 1.)+")"); } while (false);
            do { if (!((MyMath.expm1(x) + 1. - 1.)==(Math.exp(x) - 1.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1370 +"): (" + "MyMath.expm1(x) + 1. - 1." + ")" + "==" + "(" + "Math.exp(x) - 1." + ") ("+(MyMath.expm1(x) + 1. - 1.)+" vs. "+(Math.exp(x) - 1.)+")"); } while (false);

            if (x > -1.)
            {
                System.out.println("    log1p("+x+") = "+MyMath.log1p(x)+"");
                // TODO: come up with something more sensible I think? I'm a bit confused.
                do { if (!(((float)MyMath.log1p(x))==((float)Math.log(1.+x)))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1376 +"): (" + "(float)MyMath.log1p(x)" + ")" + "==" + "(" + "(float)Math.log(1.+x)" + ") ("+((float)MyMath.log1p(x))+" vs. "+((float)Math.log(1.+x))+")"); } while (false);
            }

            if (x >= 0.)
            {
                System.out.println("    acosh1p("+x+") = "+MyMath.acosh1p(x)+"");
                // TODO: come up with something more sensible I think? I'm a bit confused.
                do { if (!(((float)MyMath.acosh1p(x))==((float)MyMath.acosh(1.+x)))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1383 +"): (" + "(float)MyMath.acosh1p(x)" + ")" + "==" + "(" + "(float)MyMath.acosh(1.+x)" + ") ("+((float)MyMath.acosh1p(x))+" vs. "+((float)MyMath.acosh(1.+x))+")"); } while (false);
                // TODO: since acosh is defined in terms of acosh1p, that didn't test much, in fact I can deliberately introduce errors in it and they don't get caught :-(
            }

            if (true)
            {
                // hmm, not quite exact, apparently
                // TODO: actually this succeeds now? figure out if I want it
                {System.out.print("        "); System.out.println("MyMath.coshm1(x) + 1." + " = " + (MyMath.coshm1(x) + 1.));};
                {System.out.print("        "); System.out.println("MyMath.cosh(x) - 1. + 1." + " = " + (MyMath.cosh(x) - 1. + 1.));};
                do { if (!((MyMath.coshm1(x) + 1.)==(MyMath.cosh(x) - 1. + 1.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1393 +"): (" + "MyMath.coshm1(x) + 1." + ")" + "==" + "(" + "MyMath.cosh(x) - 1. + 1." + ") ("+(MyMath.coshm1(x) + 1.)+" vs. "+(MyMath.cosh(x) - 1. + 1.)+")"); } while (false);
                {System.out.print("        "); System.out.println("MyMath.coshm1(x) + 1. - 1." + " = " + (MyMath.coshm1(x) + 1. - 1.));};
                {System.out.print("        "); System.out.println("MyMath.cosh(x) - 1." + " = " + (MyMath.cosh(x) - 1.));};
                do { if (!((MyMath.coshm1(x) + 1. - 1.)==(MyMath.cosh(x) - 1.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1396 +"): (" + "MyMath.coshm1(x) + 1. - 1." + ")" + "==" + "(" + "MyMath.cosh(x) - 1." + ") ("+(MyMath.coshm1(x) + 1. - 1.)+" vs. "+(MyMath.cosh(x) - 1.)+")"); } while (false);
            }
            else
            {
                // TODO: come up with something more sensible I think? I'm confused
                do { if (!(((float)MyMath.coshm1(x))==((float)(MyMath.cosh(x) - 1.)))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1401 +"): (" + "(float)MyMath.coshm1(x)" + ")" + "==" + "(" + "(float)(MyMath.cosh(x) - 1.)" + ") ("+((float)MyMath.coshm1(x))+" vs. "+((float)(MyMath.cosh(x) - 1.))+")"); } while (false);
            }

            if (x >= 0.)
            {
                do { if (!((MyMath.sinh(-x))==(-MyMath.sinh(x)))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1406 +"): (" + "MyMath.sinh(-x)" + ")" + "==" + "(" + "-MyMath.sinh(x)" + ") ("+(MyMath.sinh(-x))+" vs. "+(-MyMath.sinh(x))+")"); } while (false);
                do { if (!((MyMath.asinh(-x))==(-MyMath.asinh(x)))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1407 +"): (" + "MyMath.asinh(-x)" + ")" + "==" + "(" + "-MyMath.asinh(x)" + ") ("+(MyMath.asinh(-x))+" vs. "+(-MyMath.asinh(x))+")"); } while (false);
                do { if (!((MyMath.cosh(-x))==(MyMath.cosh(x)))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1408 +"): (" + "MyMath.cosh(-x)" + ")" + "==" + "(" + "MyMath.cosh(x)" + ") ("+(MyMath.cosh(-x))+" vs. "+(MyMath.cosh(x))+")"); } while (false);
            }

            if (i == 0)
            {
                do { if (!((Math.exp(x))==(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1413 +"): (" + "Math.exp(x)" + ")" + "==" + "(" + "0." + ") ("+(Math.exp(x))+" vs. "+(0.)+")"); } while (false);
                do { if (!((MyMath.expm1(x))==(-1.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1414 +"): (" + "MyMath.expm1(x)" + ")" + "==" + "(" + "-1." + ") ("+(MyMath.expm1(x))+" vs. "+(-1.)+")"); } while (false);
                do { if (!((MyMath.sinh(x))==(Double.NEGATIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1415 +"): (" + "MyMath.sinh(x)" + ")" + "==" + "(" + "Double.NEGATIVE_INFINITY" + ") ("+(MyMath.sinh(x))+" vs. "+(Double.NEGATIVE_INFINITY)+")"); } while (false);
                do { if (!((MyMath.cosh(x))==(Double.POSITIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1416 +"): (" + "MyMath.cosh(x)" + ")" + "==" + "(" + "Double.POSITIVE_INFINITY" + ") ("+(MyMath.cosh(x))+" vs. "+(Double.POSITIVE_INFINITY)+")"); } while (false);
            }
            if (i == xs.length-1)
            {
                do { if (!((Math.exp(x))==(Double.POSITIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1420 +"): (" + "Math.exp(x)" + ")" + "==" + "(" + "Double.POSITIVE_INFINITY" + ") ("+(Math.exp(x))+" vs. "+(Double.POSITIVE_INFINITY)+")"); } while (false);
                do { if (!((MyMath.expm1(x))==(Double.POSITIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1421 +"): (" + "MyMath.expm1(x)" + ")" + "==" + "(" + "Double.POSITIVE_INFINITY" + ") ("+(MyMath.expm1(x))+" vs. "+(Double.POSITIVE_INFINITY)+")"); } while (false);
                do { if (!((MyMath.sinh(x))==(Double.POSITIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1422 +"): (" + "MyMath.sinh(x)" + ")" + "==" + "(" + "Double.POSITIVE_INFINITY" + ") ("+(MyMath.sinh(x))+" vs. "+(Double.POSITIVE_INFINITY)+")"); } while (false);
                do { if (!((MyMath.cosh(x))==(Double.POSITIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1423 +"): (" + "MyMath.cosh(x)" + ")" + "==" + "(" + "Double.POSITIVE_INFINITY" + ") ("+(MyMath.cosh(x))+" vs. "+(Double.POSITIVE_INFINITY)+")"); } while (false);
            }

            if (i > 0.)
            {
                do { if (!((Math.exp(xs[i-1]))<(Math.exp(xs[i])))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1428 +"): (" + "Math.exp(xs[i-1])" + ")" + "<" + "(" + "Math.exp(xs[i])" + ") ("+(Math.exp(xs[i-1]))+" vs. "+(Math.exp(xs[i]))+")"); } while (false);
                do { if (!((MyMath.expm1(xs[i-1]))<=(MyMath.expm1(xs[i])))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1429 +"): (" + "MyMath.expm1(xs[i-1])" + ")" + "<=" + "(" + "MyMath.expm1(xs[i])" + ") ("+(MyMath.expm1(xs[i-1]))+" vs. "+(MyMath.expm1(xs[i]))+")"); } while (false); // not strict < for some
                do { if (!((MyMath.sinh(xs[i-1]))<(MyMath.sinh(xs[i])))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1430 +"): (" + "MyMath.sinh(xs[i-1])" + ")" + "<" + "(" + "MyMath.sinh(xs[i])" + ") ("+(MyMath.sinh(xs[i-1]))+" vs. "+(MyMath.sinh(xs[i]))+")"); } while (false);
                if (((xs[i-1]) < 0 ? -(xs[i-1]) : (xs[i-1])) < ((xs[i]) < 0 ? -(xs[i]) : (xs[i])))
                {
                    do { if (!((MyMath.cosh(xs[i-1]))<(MyMath.cosh(xs[i])))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1433 +"): (" + "MyMath.cosh(xs[i-1])" + ")" + "<" + "(" + "MyMath.cosh(xs[i])" + ") ("+(MyMath.cosh(xs[i-1]))+" vs. "+(MyMath.cosh(xs[i]))+")"); } while (false);
                    do { if (!((MyMath.coshm1(xs[i-1]))<(MyMath.coshm1(xs[i])))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1434 +"): (" + "MyMath.coshm1(xs[i-1])" + ")" + "<" + "(" + "MyMath.coshm1(xs[i])" + ") ("+(MyMath.coshm1(xs[i-1]))+" vs. "+(MyMath.coshm1(xs[i]))+")"); } while (false);
                }
                else
                {
                    do { if (!((MyMath.cosh(xs[i-1]))>(MyMath.cosh(xs[i])))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1438 +"): (" + "MyMath.cosh(xs[i-1])" + ")" + ">" + "(" + "MyMath.cosh(xs[i])" + ") ("+(MyMath.cosh(xs[i-1]))+" vs. "+(MyMath.cosh(xs[i]))+")"); } while (false);
                    do { if (!((MyMath.coshm1(xs[i-1]))>(MyMath.coshm1(xs[i])))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1439 +"): (" + "MyMath.coshm1(xs[i-1])" + ")" + ">" + "(" + "MyMath.coshm1(xs[i])" + ") ("+(MyMath.coshm1(xs[i-1]))+" vs. "+(MyMath.coshm1(xs[i]))+")"); } while (false);
                }
            }
        }

        if (true)
        {
            // lambertw tests
            for (double i = -714.; i <= 696.; ++i) // empirically, works to this range
            {
                if (i <= -1.)
                {
                    if (i >= -10 && i <= 10) System.out.println("    lambertw(e^"+i+"*"+i+", -1) = "+MyMath.lambertw(Math.exp(i)*i,-1));
                    do { if (!((MyMath.lambertw(Math.exp(i)*i,-1))==(i))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1452 +"): (" + "MyMath.lambertw(Math.exp(i)*i,-1)" + ")" + "==" + "(" + "i" + ") ("+(MyMath.lambertw(Math.exp(i)*i,-1))+" vs. "+(i)+")"); } while (false); // seems to be exact
                }
                if (i >= -1.)
                {
                    if (i >= -10 && i <= 10) System.out.println("    lambertw(e^"+i+"*"+i+", 0) = "+MyMath.lambertw(Math.exp(i)*i,0));
                    do { if (!((MyMath.lambertw(Math.exp(i)*i,0))==(i))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1457 +"): (" + "MyMath.lambertw(Math.exp(i)*i,0)" + ")" + "==" + "(" + "i" + ") ("+(MyMath.lambertw(Math.exp(i)*i,0))+" vs. "+(i)+")"); } while (false); // seems to be exact
                }
            }
            do { if (!((MyMath.lambertw(Double.POSITIVE_INFINITY, 0))==(Double.POSITIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1460 +"): (" + "MyMath.lambertw(Double.POSITIVE_INFINITY, 0)" + ")" + "==" + "(" + "Double.POSITIVE_INFINITY" + ") ("+(MyMath.lambertw(Double.POSITIVE_INFINITY, 0))+" vs. "+(Double.POSITIVE_INFINITY)+")"); } while (false);
            do { if (!Double.isNaN(MyMath.lambertw(Double.POSITIVE_INFINITY, -1))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1461 +"): " + "MyMath.lambertw(Double.POSITIVE_INFINITY, -1)" + " is "+(MyMath.lambertw(Double.POSITIVE_INFINITY, -1))+", expected NaN"); } while (false);

            // wolframalpha says the inverse function of e^x/x is -W(-1/x)
            // and we have to figure out which branch it is.
            // then:
            //     x = -W(-1/y)
            // and empirically, it's the lower branch. Hmm.  (wolframalpha didn't indicate that)
            // XXX hmm, -14 and -13 (not as much) are slow! interesting! should investigate!
            // that's
            //     -14: lambert(-5.9394908507397704E-8)
            //     -13: -1.7387149284469648E-7
            //     -12: -5.120176961106842E-7
            //     -11: -1.5183364354768781E-6
            System.out.println(""+"========");
            for (double i = -100.; i <= 100.; ++i)
            {
                int branch = i<1 ? -1 : 0;
                if (i >= -20 && i <= 20) System.out.println("    MyMath.glog(Math.exp("+i+")/"+i+"="+(Math.exp(i)/i)+","+branch+") = "+MyMath.glog(Math.exp(i)/i,branch));
                do { if (!((MyMath.glog(Math.exp(i)/i,branch))==(i))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1479 +"): (" + "MyMath.glog(Math.exp(i)/i,branch)" + ")" + "==" + "(" + "i" + ") ("+(MyMath.glog(Math.exp(i)/i,branch))+" vs. "+(i)+")"); } while (false);

                if (i < 0.)
                {
                    do { if (!((MyMath.glog(i, -1))<(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1483 +"): (" + "MyMath.glog(i, -1)" + ")" + "<" + "(" + "0." + ") ("+(MyMath.glog(i, -1))+" vs. "+(0.)+")"); } while (false);
                    do { if (!Double.isNaN(MyMath.glog(i, 0))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1484 +"): " + "MyMath.glog(i, 0)" + " is "+(MyMath.glog(i, 0))+", expected NaN"); } while (false);
                }
                else if (i == 0)
                {
                    // subtle: it's implemented so that both -0 and 0 produce NEGATIVE_INFINITY on branch -1.
                    do { if (!((MyMath.glog(i, -1))==(Double.NEGATIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1489 +"): (" + "MyMath.glog(i, -1)" + ")" + "==" + "(" + "Double.NEGATIVE_INFINITY" + ") ("+(MyMath.glog(i, -1))+" vs. "+(Double.NEGATIVE_INFINITY)+")"); } while (false);
                    do { if (!((MyMath.glog(-i, -1))==(Double.NEGATIVE_INFINITY))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1490 +"): (" + "MyMath.glog(-i, -1)" + ")" + "==" + "(" + "Double.NEGATIVE_INFINITY" + ") ("+(MyMath.glog(-i, -1))+" vs. "+(Double.NEGATIVE_INFINITY)+")"); } while (false);
                    do { if (!Double.isNaN(MyMath.glog(i, 0))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1491 +"): " + "MyMath.glog(i, 0)" + " is "+(MyMath.glog(i, 0))+", expected NaN"); } while (false);
                    do { if (!Double.isNaN(MyMath.glog(-i, 0))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1492 +"): " + "MyMath.glog(-i, 0)" + " is "+(MyMath.glog(-i, 0))+", expected NaN"); } while (false);
                }
                else if (i < Math.E)
                {
                    do { if (!Double.isNaN(MyMath.glog(i, -1))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1496 +"): " + "MyMath.glog(i, -1)" + " is "+(MyMath.glog(i, -1))+", expected NaN"); } while (false);
                    do { if (!Double.isNaN(MyMath.glog(i, 0))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1497 +"): " + "MyMath.glog(i, 0)" + " is "+(MyMath.glog(i, 0))+", expected NaN"); } while (false);
                }
                else if (i == Math.E)
                {
                    do { if (!((MyMath.glog(i, -1))==(1.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1501 +"): (" + "MyMath.glog(i, -1)" + ")" + "==" + "(" + "1." + ") ("+(MyMath.glog(i, -1))+" vs. "+(1.)+")"); } while (false);
                    do { if (!((MyMath.glog(i, 0))==(1.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1502 +"): (" + "MyMath.glog(i, 0)" + ")" + "==" + "(" + "1." + ") ("+(MyMath.glog(i, 0))+" vs. "+(1.)+")"); } while (false);
                }
                else if (i > Math.E)
                {
                    do { if (!((MyMath.glog(i, -1))<(1.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1506 +"): (" + "MyMath.glog(i, -1)" + ")" + "<" + "(" + "1." + ") ("+(MyMath.glog(i, -1))+" vs. "+(1.)+")"); } while (false);
                    do { if (!((MyMath.glog(i, 0))>(1.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/MyMath.prejava"+"("+1507 +"): (" + "MyMath.glog(i, 0)" + ")" + ">" + "(" + "1." + ") ("+(MyMath.glog(i, 0))+" vs. "+(1.)+")"); } while (false);
                }
            }
        } // lambertw and glog tests

        System.out.println("      MyMath functions all good!");
        System.out.println("    out MyMath.main");
    }
} // class MyMath
