// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// 102 # 1 "com/donhatchsw/util/CSG.prejava"
// 103 # 1 "<built-in>"
// 104 # 1 "<command-line>"
// 105 # 1 "/usr/include/stdc-predef.h" 1 3 4

// 107 # 1 "/usr/include/stdc-predef.h" 3 4
/* Copyright (C) 1991-2019 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




/* This header is separate from features.h so that the compiler can
   include it implicitly at the start of every compilation.  It must
   not itself include <features.h> or any other header that includes
   <features.h> because the implicit include comes before any feature
   test macros that may be defined in a source file before it first
   explicitly includes a system header.  GCC knows the name of this
   header in order to preinclude it.  */

/* glibc's intent is to support the IEC 559 math functionality, real
   and complex.  If the GCC (4.9 and later) predefined macros
   specifying compiler intent are available, use them to determine
   whether the overall intent is to support these features; otherwise,
   presume an older compiler has intent to support these features and
   define these macros by default.  */
// 142 # 52 "/usr/include/stdc-predef.h" 3 4
/* wchar_t uses Unicode 10.0.0.  Version 10.0 of the Unicode Standard is
   synchronized with ISO/IEC 10646:2017, fifth edition, plus
   the following additions from Amendment 1 to the fifth edition:
   - 56 emoji characters
   - 285 hentaigana
   - 3 additional Zanabazar Square characters */
// 149 # 1 "<command-line>" 2
// 150 # 1 "com/donhatchsw/util/CSG.prejava"

// 152 # 1 "com/donhatchsw/util/CSG.prejava"
/* vim: set filetype=java: */
/*
* Copyright (c) 2005,2006 Don Hatch Software
*/

//
// CSG.prejava
//
// Contains functions for doing boolean operations (union, intersection, diff)
// on polytopes (i.e. polygons or polyhedra or ...).
//
// Depends on:
//      VecMath.prejava
//      SortStuff.prejava
//
/*
    Bugs to fix:
        - fix signs like I said I would (what did I say? I can't recall)
        Was:
            -dim=1: A&A arrayIndexOutOfBounds: -1, in SortStuff.swap
            -dim=1: A-A arrayIndexOutOfBounds, same
            -dim=1: A|A arrayIndexOutOfBounds, same

            -dim=2: A&A CHECK failed at CSG.prejava(1240): Arrays.indexOf(slicee.p.contributingHyperplanes, hyperplane) == -1
            -dim=2: A-A same assertion failure
            -dim=2: A|A same assertion failure
        Then was:
            -dim=1: A&A gives bogus bombed-out structure
            -dim=2: A&A Assumption failed at CSG.prejava(2392): n == list.length
            and similarly for the other tests listed above
        Now:
            -dim=2: A&A CHECK failed at com/donhatchsw/util/CSG.prejava(251): (facet.dim)==(dim-1) (1 vs. 0)
            -dim=2: (A-B)u(B-A) assertion failed at com/donhatchsw/util/CSG.prejava(247): (facet.dim)==(dim-1) (1 vs. 0)
        Bleah, looking it over again, it seems like the algorithm
        can't handle A&A-- it computes the boundary of the intersection
        of A&B as bd(A)&B union A&bd(B), which is null...
        need a fundamental insight to fix this.

    To consider:
        - Should try to explain what the signs mean.  Some things
          to maybe mention...
            - note, the sum of signed vertices on an edge
              is actually the directed length of the edge
            - going back over an edge (or face) in the opposite
              direction means erasing it
            - for a proper edge, the sum of all vert's signs must be 0
              (otherwise it's a ray or something)
            - for a closed loop or surface, the boundary must have
              no boundary, i.e. the sum of the boundary of the boundary
              must be zero.
            - intersection is really min, union is really max,
              complement is really 1-.  The allowed polytopes
              are those that are constant density outside
              a bounded region; that constant density
              is called "initialDensity".
              The most common ones are finite and cofinite (i.e.
              those that are density 1 on a finite region and 0 elsewhere,
              and vice-versa.)
              (Might also allow more some day, but not at the moment.)
            - hmm, assuming the a.e. constant density restriction,
              this means all but top level polytopes
              must have initial density 0.
            - interesting, if we have a varying-positive-density
              polytope and we want the density-1 version,
              just intersect (i.e. min) it with 1.

        - does initialDensity have a meaning for vertices? (should it be 1? -1?)
        - make params X,Y instead of A,B? (since A,B are typical
              arguments; this might make debugging less confusing)
              But then I'll have to think of an alternative
              for alpha,beta that is not confusing...
              yamma, zigga? yalpha, zeta?
              ha, my humor is above everyone's head.
*/

package com.donhatchsw.util;

// 230 # 1 "com/donhatchsw/util/macros.h" 1
//
// macros.h
//
// 234 # 14 "com/donhatchsw/util/macros.h"
// NOTE: this causes a,b to be evaluated twice on failure, so is not ideal. might be better to do a block... ?
// 236 # 30 "com/donhatchsw/util/macros.h"
// Note: the additional "(a)==(b)||" is to make it work correctly for infinities...
// and causes the args to be evaluated twice.
// 239 # 67 "com/donhatchsw/util/macros.h"
// XXX ... what a mess
// 241 # 79 "com/donhatchsw/util/CSG.prejava" 2


/**
*  Contains functions for doing n-dimensional Constructive Solid Geometry (CSG),
*  that is, boolean operations (union, intersection, diff)
*  on polytopes (i.e polygons or polyhedra or ...).
*  <p>
*  The objects that the boolean operators operate on
*  are {@link CSG.Polytope} and {@link CSG.SPolytope} (signed polytope).
*  The simplest way to create a CSG.Polytope
*  is probably by using the {@link PolyCSG} class.
*  Some primitive CSG.SPolytopes can also be made using
*  {@link #makePolygon makePolygon}(),
*  {@link #makeSimplex makeSimplex}(),
*  and {@link #makeHypercube makeHypercube}().
*  You can also create any (star) regular or wythoff polytope,
*  or a product of them, from a string,
*  using {@link #makeRegularStarPolytopeProductFromString makeRegularStarPolytopeProductFromString}().
*  <p>
*  Caveats: not at all robust about coincident or coplanar elements;
*  really only works reliably if everything is in general position.
*  <p>
*  Depends on classes:
*  <ul>
*       <li> Arrays </li>
*       <li> VecMath </li>
*       <li> SortStuff </li>
*       <li> FuzzyPointHashTable </li>
*  </ul>
*/
public final class CSG
{
    private CSG() {} // uninstantiatable
    //
    // Debugging setting...
    // I just set this appropriately and recompile.
    // XXX note, not final so that it can be changed in main.
    // XXX this should maybe be a compile-time option,
    // XXX since making it final gets rid of a lot of code.
    //
    //public static int verboseLevel = 2; // 3 = show gory details (XXX which are really gory and I should probably do away with)
    //public static int verboseLevel = 1; // 3 = show gory details (XXX which are really gory and I should probably do away with)
    //public static int verboseLevel = 0; // 3 = show gory details (XXX which are really gory and I should probably do away with)
    public static int verboseLevel = -1; // 3 = show gory details (XXX which are really gory and I should probably do away with)

    //
    // Data structures...
    //

        private static long nIds = 0; // so we can give a unique integer id to everything ever created
        private static Object nIdsLock = new Object(); // for synchronization
        private static java.util.Random randomGenerator = new java.util.Random(0);

        /**
        *  A hyperplane is the set of all
        *  points p such that (p dot normal) = offset.
        *  The closed halfspace it bounds is the set of all points p
        *  such that (p dot normal) <= offset.
        */
        public static class Hyperplane
        {
            public long id;
            public double normal[];
            public double offset;
            public double spanningPoints[][]; // optional; avoids recalculation of points (and resulting roundoff error) when points was the original representation.  XXX this idea seems to be lacking... e.g. if there are more than dim(plane)+1 points on the polygon, then we have to omit some.  think about this :-( )
            /** Creates a Hyperplane from a plane equation. */
            public Hyperplane(double normal[], double offset)
            {
                synchronized(nIdsLock)
                {
                    this.id = nIds++;
                }
                this.normal = normal;
                this.offset = offset;
                this.spanningPoints = null;
            } // Hyperplane from plane equation
            /** Creates a Hyperplane from a set of dim spanning points. */
            public Hyperplane(double spanningPoints[][])
            {
                synchronized(nIdsLock)
                {
                    this.id = nIds++;
                }
                this.spanningPoints = spanningPoints;

                do { if (!(false)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+164 +"): " + "false" + ""); } while (false); // XXX implement me! normal should be cross product of points vectors
                this.offset = VecMath.dot(this.normal,
                                          this.spanningPoints[0]);
            } // Hyperplane from spanning points

            public String toString()
            {
                return VecMath.toString(normal) + " " + offset;
            }
        } // class Hyperplane

        /**
        *  Unsigned (unoriented) polytope,
        *  defined by its boundary.
        *  <p>
        *  Note, the "dim" member wasn't stored here originally since
        *  it can be inferred as (dim of planes[0].normal) - (# of planes),
        *  except when (# of planes) == 0, in which case we can still infer
        *  it (recursively) as (dim of facets)+1, unless there
        *  are no facets... This was giving me a headache,
        *  so I'm just storing it explicitly here.
        *  <p>
        *  Similarly for "fullDim", only more so.
        */
        public static class Polytope
        {
            public long id;
            public int dim; // dimension of the polytope
            public int fullDim; // dimension of the space it lives in
            public SPolytope facets[];
            public Hyperplane contributingHyperplanes[]; // the hyperplanes whose intersection is the space of this Polytope, in sorted order. // XXX sigh, should probably be a HashableSortedArray so we don't have to keep creating and destorying them every time we want to look it up... but that means this definition is getting more and more obscured
            private Object aux; // user data; creator can set this if desired. access is through getAux/setAux/pushAux/popAux; this member is actually the top of the aux stack.
            private PushedAuxNext pushedAuxNext; // rest of aux stack (other than aux itself which is the top element)
            private static boolean XXXuseNewPushPopAux = false; // XXX true seems to be causing a bug: exception in mc4d "{4,3,3} 2":  CHECK failed at com/donhatchsw/util/CSG.prejava(349): this.pushedAuxNext != null
            private double _coords[]; // if vertex, null otherwise.  XXX should probably calculate only on demand, but then need a way to differentiate between dirty and nonexistent (for example, this is needed in getBBox below). XXX ctually not currently calculated at all.
            private double _bbox[/*2*/][]; // bounding box of all vertices, so it can be finite even if the polytope is infinite (co-finite).  calculated Lazily via getBBox(), cleared to null if any vertex coord changes.
            private Polytope[/*dim+1*/][] _allElements; // sorted lists of vertices, edges, ..., ridges, facets, calculated lazily via getAllElements()
            private int[/*dim+1*/][][/*dim+1*/][] _allIncidences; // calculated lazily via getAllIncidences

            public Polytope(int dim,
                            int fullDim,
                            SPolytope facets[],
                            Hyperplane contributingHyperplanes[],
                            Object aux)
            {
                if (verboseLevel >= 3)
                    System.out.println("in Polytope ctor");
                synchronized(nIdsLock)
                {
                    this.id = nIds++;
                }
                this.dim = dim;
                this.fullDim = fullDim;
                this.facets = facets;
                this.contributingHyperplanes = contributingHyperplanes;
                this.aux = aux;
                this.pushedAuxNext = null;
                this._coords = null;
                this._bbox = null;
                this._allElements = null;

                if (verboseLevel >= 3)
                {
                    System.out.print("    making "+dimToPrefix(dim)+this.id+": [");
                    if (facets == null)
                        System.out.println("(null)");
                    else
                        for (int iFacet = 0; (iFacet) < (facets.length); ++iFacet)
                        {
                            System.out.print(" "
                                           + signToString(facets[iFacet].sign)
                                           + dimToPrefix(facets[iFacet].p.dim)
                                           + facets[iFacet].p.id);
                        }
                    System.out.println(" ]");
                }

                if (facets != null) // XXX maybe shouldn't be allowed, but makeHyperCube does it
                {
                    int nFacets = facets.length;
                    for (int iFacet = 0; (iFacet) < (nFacets); ++iFacet)
                    {
                        Polytope facet = facets[iFacet].p;
                        do { if (!((facet.fullDim)==(fullDim))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+247 +"): (" + "facet.fullDim" + ")" + "==" + "(" + "fullDim" + ") ("+(facet.fullDim)+" vs. "+(fullDim)+")"); } while (false);
                        do { if (!((facet.dim)==(dim-1))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+248 +"): (" + "facet.dim" + ")" + "==" + "(" + "dim-1" + ") ("+(facet.dim)+" vs. "+(dim-1)+")"); } while (false);
                    }
                }

                if (verboseLevel >= 3)
                    System.out.println("out Polytope ctor");
            }

            // Note this just copies the pointer,
            // so don't give it a scratch buffer that you will overwrite!
            // (should take a const double[]).
            public void setCoords(double coords[])
            {
                do { if (!((dim)==(0))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+261 +"): (" + "dim" + ")" + "==" + "(" + "0" + ") ("+(dim)+" vs. "+(0)+")"); } while (false); // must be a vertex
                _coords = coords;
                do { if (!((_bbox)==(null))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+263 +"): (" + "_bbox" + ")" + "==" + "(" + "null" + ") ("+(_bbox)+" vs. "+(null)+")"); } while (false); // danger: there's no such check for all the parent polytopes that may refer to this one!
            }

            // Returns a pointer to coords.
            // this must be 0-dimensional (a vertex) in some number of dimensions.
            // Calculates it lazily if not already calculated.
            // It is illegal to modify the contents
            // (should return const double[]).
            public double[] getCoords()
            {
                do { if (!((dim)==(0))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+273 +"): (" + "dim" + ")" + "==" + "(" + "0" + ") ("+(dim)+" vs. "+(0)+")"); } while (false); // must be a vertex
                if (_coords == null)
                {
                    _coords = intersectHyperplanes(contributingHyperplanes);
                }
                do { if (!(_coords != null)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+278 +"): " + "_coords != null" + ""); } while (false); // XXX not absolutely sure if I'm preventing this
                return _coords;
            } // getCoords

            //
            // When this is called, it is assumed
            // that the coords and connectivity
            // will not henceforth change.
            // XXX well I'm not completely firm on that, but if they do change, the _bbox will have to be marked dirty, probably by setting it to null.  Note that makeHypercube does this!
            //
            public double[/*2*/][] getBBox()
            {
                if (_bbox == null)
                {
                    // XXX should maybe say "if it's a vertex", i.e. if contributingHyperplanes.length == contributingHyperplanes[0].normal.length
                    if (dim == 0)
                    {
                        double coords[] = getCoords();
                        _bbox = new double[/*2*/][] {coords, coords};
                    }
                    else
                    {
                        _bbox = new double[2][fullDim];
                        VecMath.fillvec(_bbox[0], Double.POSITIVE_INFINITY);
                        VecMath.fillvec(_bbox[1], Double.NEGATIVE_INFINITY);
                        for (int iFacet = 0; (iFacet) < (facets.length); ++iFacet)
                        {
                            double facetBBox[][] = facets[iFacet].p.getBBox();
                            for (int iDim = 0; (iDim) < (_bbox[0].length); ++iDim)
                            {
                                _bbox[0][iDim] = ((_bbox[0][iDim])<=(facetBBox[0][iDim])?(_bbox[0][iDim]):(facetBBox[0][iDim]));
                                _bbox[1][iDim] = ((_bbox[1][iDim])>=(facetBBox[1][iDim])?(_bbox[1][iDim]):(facetBBox[1][iDim]));
                            }
                        }
                    }
                }
                return _bbox;
            } // getBBox

            // For pushAux/popAux/getAux/setAux
            private class PushedAuxNext
            {
                public Object thisAux;
                public PushedAuxNext next;
                public Object XXXsavedAux; // XXX GET RID OF THIS when debugged
                public PushedAuxNext(Object thisAux, PushedAuxNext next)
                {
                    this.thisAux = thisAux;
                    this.next = next;
                    this.XXXsavedAux = null;
                }
                public PushedAuxNext(Object thisAux, Object savedAux)
                {
                    this.thisAux = thisAux;
                    this.next = null;
                    this.XXXsavedAux = savedAux;
                }
            }
            /** Pushes the new aux value onto a stack of aux values; popAux can be used to pop it back off later. */
            public void pushAux(Object newAux)
            {
                if (XXXuseNewPushPopAux)
                {
                    this.pushedAuxNext = new PushedAuxNext(this.aux, this.pushedAuxNext);
                    this.aux = newAux;
                }
                else
                {
                    aux = new PushedAuxNext(newAux, aux);
                }
            }
            /** Pops the top aux value off the stack and returns it. */
            public Object popAux()
            {
                if (XXXuseNewPushPopAux)
                {
                    do { if (!(this.pushedAuxNext != null)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+354 +"): " + "this.pushedAuxNext != null" + ""); } while (false); // CBB: could throw something useful
                    Object answer = this.aux;
                    this.aux = this.pushedAuxNext.thisAux;
                    this.pushedAuxNext = this.pushedAuxNext.next;
                    return answer;
                }
                else
                {
                    do { if (!(aux instanceof PushedAuxNext)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+362 +"): " + "aux instanceof PushedAuxNext" + ""); } while (false); // XXX throw something useful
                    PushedAuxNext pushedAuxNext = (PushedAuxNext)aux;
                    aux = pushedAuxNext.XXXsavedAux;
                    return pushedAuxNext.thisAux;
                }
            }
            /** Returns the value at the top of the aux stack. */
            public Object getAux()
            {
                if (XXXuseNewPushPopAux)
                    return this.aux;
                else
                {
      // CBB: this instanceof is probably slow.  Would be more efficient to have aux and auxStack be two separate variables.
      if (aux instanceof PushedAuxNext)
   return ((PushedAuxNext)aux).thisAux;
      else
   return aux;
                }
            }
            /** Replaces the value at the top of the aux stack with the new value. */
            public void setAux(Object newAux)
            {
                if (XXXuseNewPushPopAux)
                {
                    this.aux = newAux;
                }
                else
                {
      if (aux instanceof PushedAuxNext)
   ((PushedAuxNext)aux).thisAux = newAux;
      else
   aux = newAux;
                }
            }

            /**
            * Get a list of all verts, edges, faces, ..., ridges, facets, self
            * of this polytope.
            * getAllElements()[iDim] is the list of iDim-dimensional sub-polytopes.
            */
            public Polytope[/*dim+1*/][] getAllElements()
            {
                if (_allElements == null)
                {
                    // don't use pushAux because it's slightly more heavyweight than we need, and this can be a bottleneck function I think
                    class VisitedAux
                    {
                        public Object savedAux;
                        public VisitedAux(Object savedAux)
                        {
                            this.savedAux = savedAux;
                        }
                    }

                    // workaround 3 from https://programming.guide/java/generic-array-creation.html
                    @SuppressWarnings("serial") class ArrayList_Polytope extends java.util.ArrayList<Polytope> {}
                    ArrayList_Polytope lists[] = new ArrayList_Polytope[dim+1];
                    {
                        for (int iDim = 0; (iDim) < (dim+1); ++iDim)
                            lists[iDim] = new ArrayList_Polytope();
                        java.util.ArrayList<Polytope> flatList = new java.util.ArrayList<Polytope>();

                        this.aux = new VisitedAux(this.aux); // mark it visited when queued
                        flatList.add(this);
                        for (int flatIndex = 0; (flatIndex) < (flatList.size()); ++flatIndex) // while flatList.size() is increasing!
                        {
                            Polytope elt = flatList.get(flatIndex);
                            lists[elt.dim].add(elt);
                            for (int iFacet = 0; (iFacet) < (elt.facets.length); ++iFacet)
                            {
                                Polytope facet = elt.facets[iFacet].p;
                                if (!(facet.aux instanceof VisitedAux)) // save even when elt.aux is null
                                {
                                    facet.aux = new VisitedAux(facet.aux); // mark it visited when queued
                                    flatList.add(facet);
                                }
                            }
                        }
                    }

                    _allElements = new Polytope[dim+1][];
                    for (int iDim = 0; (iDim) < (dim+1); ++iDim)
                    {
                        _allElements[iDim] = new Polytope[lists[iDim].size()];
                        lists[iDim].toArray(_allElements[iDim]);
                        if (true)
                        {
                            // Make it come out in a deterministic order,
                            // depending on the original creation order
                            // (so it won't change if I re-implement
                            // any of the above differently)
                            // even though this is not the order in which
                            // the facets appeared in the facets list :-(
                            SortStuff.sort(_allElements[iDim],
                                           new SortStuff.Comparator() {
                                               @Override public int compare(Object _a, Object _b)
                                               {
                                                   Polytope a = (Polytope)_a;
                                                   Polytope b = (Polytope)_b;
                                                   return a.id < b.id ? -1 :
                                                          a.id > b.id ? 1 : 0;
                                               }
                                           });
                        }
                        for (int iElt = 0; (iElt) < (_allElements[iDim].length); ++iElt)
                        {
                            Polytope elt = _allElements[iDim][iElt];
                            elt.aux = ((VisitedAux)elt.aux).savedAux;
                        }
                    }
                } // if _allElements == null
                return _allElements;
            } // getAllElements()

            /**
            * Get a list of all the incidences between elements
            * occurring inside this polytope.
            *     getAllIncidences()[iDim][iElt][jDim]
            * is the list of all indices (into getAllElements()[jDim])
            * of jDim-dimensional elements
            * that are incident on iDim-dimensional element
            *     getAllElements()[iDim][iElt].
            * The result of this function gets cached,
            * so it is not time-consuming to call it multiple times.
            *
            * TODO:
            *     Should also return the back-indices...
            *     could make getAllIncidences()[iDim][iElt][jDim][index]
            *     be a pair {jElt,backIndex}
            *     such that getAllElements()[jDim][jElt][iDim][backIndex]
            *                                                 = {iElt,index}.
            * That would be useful, for example,
            * for mapping from an {iFacet,iRidgeThisFacet}
            * pair to its twin {jFacet,jRidgeThisFacet}
            * that refers to the same ridge (with opposite sign).
            *
            * Have to think about whether it is useful in general though,
            * or only for ridges... if only ridges, maybe it would be
            * a big waste of space.
            *
            * XXX If I do this, take a look at orientFacetsConsistently,
            * XXX it could use it.
            */
            public int[/*dim+1*/][][/*dim+1*/][] getAllIncidences()
            {
                if (_allIncidences == null)
                {
                    Polytope allElts[][] = getAllElements();

                    //
                    // We don't know how many incidences each element
                    // has beforehand.  We could do this by starting
                    // with a gzillion ArraysLists and then converting to arrays
                    // at the end... but there are a gzillion of them.
                    // So instead, we do it in two passes--
                    // a counting pass, then allocate arrays
                    // of the right size, then a filling pass.
                    //

                    int counts[][][] = new int[allElts.length][][];
                    for (int iDim = 0; (iDim) < (dim+1); ++iDim)
                    {
                        counts[iDim] = new int[allElts[iDim].length][];
                        for (int iElt = 0; (iElt) < (allElts[iDim].length); ++iElt)
                            counts[iDim][iElt] = new int[dim+1]; // zeros
                    }


                    // Mark each element temporarily with its index in allElts,
                    // so we don't have to do time consuming searches...
                    // We don't use pushAux because it's slightly more heavyweight than we need, and this can be a bottleneck function I think
                    class GlobalIndexAux
                    {
                        public int globalIndex;
                        public Object savedAux;
                        public GlobalIndexAux(int globalIndex, Object savedAux)
                        {
                            this.globalIndex = globalIndex;
                            this.savedAux = savedAux;
                        }
                    }
                    for (int iDim = 0; (iDim) < (dim+1); ++iDim)
                    for (int iElt = 0; (iElt) < (allElts[iDim].length); ++iElt)
                    {
                        Polytope elt = allElts[iDim][iElt];
                        elt.aux = new GlobalIndexAux(iElt, elt.aux);
                    }

                    for (int iPass = 0; (iPass) < (2); ++iPass) // iPass=0: count, iPass=1: fill
                    {
                        for (int iDim = 0; (iDim) < (dim+1); ++iDim)
                        for (int iElt = 0; (iElt) < (allElts[iDim].length); ++iElt)
                        {
                            Polytope elt = allElts[iDim][iElt];
                            Polytope allEltsOfElt[][] = elt.getAllElements();
                            for (int jDim = 0; (jDim) < (elt.dim+1); ++jDim)
                            for (int jEltLocal = 0; (jEltLocal) < (allEltsOfElt[jDim].length); ++jEltLocal)
                            {
                                Polytope eltElt = allEltsOfElt[jDim][jEltLocal];
                                int jEltGlobal = ((GlobalIndexAux)eltElt.aux).globalIndex;
                                if (false)
                                    System.out.println("    elt "+dimToPrefix(iDim)+elt.id
                                             +"("+iDim+")"
                                             +" has eltElt "+dimToPrefix(jDim)+eltElt.id
                                             +"("+jEltGlobal+")"
                                             );
                                if (iPass == 1) // if it's the filling pass
                                    _allIncidences[jDim][jEltGlobal][iDim][counts[jDim][jEltGlobal][iDim]] = iElt;
                                counts[jDim][jEltGlobal][iDim]++;
                                if (jDim != iDim)
                                {
                                    if (iPass == 1) // if it's the filling pass
                                        _allIncidences[iDim][iElt][jDim][counts[iDim][iElt][jDim]] = jEltGlobal;
                                    counts[iDim][iElt][jDim]++;
                                }
                            }
                        }
                        if (iPass == 0)
                        {
                            // Got the counts,
                            // do the allocations.
                            _allIncidences = new int[counts.length][][][];
                            for (int iDim = 0; (iDim) < (dim+1); ++iDim)
                            {
                                _allIncidences[iDim] = new int[counts[iDim].length][][];
                                for (int iElt = 0; (iElt) < (allElts[iDim].length); ++iElt)
                                {
                                    _allIncidences[iDim][iElt] = new int[counts[iDim][iElt].length][];
                                    for (int jDim = 0; (jDim) < (dim+1); ++jDim)
                                    {
                                        _allIncidences[iDim][iElt][jDim] = new int[counts[iDim][iElt][jDim]];
                                        counts[iDim][iElt][jDim] = 0; // reset for use again during filling
                                    }
                                }
                            }
                        }
                    } // for iPass = 0 then 1

                    // restore old auxs...
                    for (int iDim = 0; (iDim) < (dim+1); ++iDim)
                    for (int iElt = 0; (iElt) < (allElts[iDim].length); ++iElt)
                    {
                        Polytope elt = allElts[iDim][iElt];
                        elt.aux = ((GlobalIndexAux)elt.aux).savedAux;
                    }

                    if (false)
                    {
                        System.out.println("All incidences:");
                        System.out.println("        " + "_allIncidences" + " = " + Arrays.toStringCompact(_allIncidences));
                        for (int iDim = 0; (iDim) < (_allIncidences.length); ++iDim)
                        {
                            for (int iElt = 0; (iElt) < (_allIncidences[iDim].length); ++iElt)
                            {
                                Polytope elt = allElts[iDim][iElt];
                                System.out.println("    "+dimToPrefix(iDim)+elt.id+":");
                                for (int jDim = 0; (jDim) < (_allIncidences[iDim][iElt].length); ++jDim)
                                {
                                    System.out.print("    ");
                                    for (int jElt = 0; (jElt) < (_allIncidences[iDim][iElt][jDim].length); ++jElt)
                                    {
                                        Polytope inc = allElts[jDim][_allIncidences[iDim][iElt][jDim][jElt]];
                                        System.out.print(" "+dimToPrefix(jDim)+inc.id);
                                    }
                                    System.out.println("    ");
                                }
                            }
                            System.out.println();
                        }
                    }
                }
                return _allIncidences;
            } // getAllIncidences

            public String toString(String indentString,
                                   boolean showAux,
                                   boolean showGoryDetails,
                                   java.util.HashSet<Object> printedAlready)
            {
                String nl = System.getProperty("line.separator");
                if (printedAlready == null)
                    printedAlready = new java.util.HashSet<Object>();

                StringBuffer sb = new StringBuffer();
                if (showGoryDetails)
                {
                    sb.append("Polytope "+id+" {" + nl);
                    if (printedAlready.contains(this))
                    {
                        sb.append(indentString + "    (printed already)" + nl);
                    }
                    else
                    {
                        printedAlready.add(this);

                        if (showAux)
                            sb.append(indentString + "    (aux="+aux+")");
                        sb.append(indentString + "    "+facets.length+" facet"+(facets.length==1?"":"s")+": {" + nl);
                        for (int iFacet = 0; (iFacet) < (facets.length); ++iFacet)
                        {
                            sb.append(indentString + "        " + facets[iFacet].toString(indentString+"        ", showAux, showGoryDetails, printedAlready) + nl);
                        }
                        sb.append(indentString + "    }" + nl);

                        sb.append(indentString + "    "+contributingHyperplanes.length+" contributing hyperplane"+(contributingHyperplanes.length==1?"":"s")+": {" + nl);
                        for (int iHyperplane = 0; (iHyperplane) < (contributingHyperplanes.length); ++iHyperplane)
                        {
                            sb.append(indentString + "        " + contributingHyperplanes[iHyperplane] + nl);
                        }
                        sb.append(indentString + "    }" + nl);

                        sb.append(indentString + "    _coords = " + VecMath.toString(_coords) + nl);
                        sb.append(indentString + "    _bbox = " + VecMath.toString(_bbox) + nl);
                    }
                    sb.append(indentString + "}");
                }
                else
                {
                    sb.append(dimToPrefix(dim));
                    sb.append(id);

                    if (showAux)
                    {
                        sb.append(" (aux="+aux+")");
                    }

                    //sb.append("[");
                    if (printedAlready.contains(this))
                    {
                        if (true)
                            sb.append(" (see above)");
                    }
                    else
                    {
                        printedAlready.add(this);
                        for (int iHyperplane = 0; (iHyperplane) < (contributingHyperplanes.length); ++iHyperplane)
                        {
                            sb.append("  (" + contributingHyperplanes[iHyperplane] + ")");
                        }
                        if (dim == 0)
                        {
                            if (_coords != null)
                            {
                                sb.append("  :  " + VecMath.toString(_coords));
                                // XXX Should probably do the below anyway,
                                // XXX and also keep track
                                // XXX of whether coords have been
                                // XXX computed or set explicitly
                            }
                            else
                            {
                                // don't call getCoords(), since that will set _coords and we don't want to change anything
                                sb.append("  ->  " + VecMath.toString(intersectHyperplanes(contributingHyperplanes)));
                            }
                        }
                        for (int iFacet = 0; (iFacet) < (facets.length); ++iFacet)
                        {
                            sb.append(nl + indentString + "    ");
                            do { if (!(facets[iFacet] != null)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+721 +"): " + "facets[iFacet] != null" + ""); } while (false);
                            sb.append(facets[iFacet].toString(indentString+"    ", showAux, false, printedAlready));
                            if (iFacet+1 < facets.length)
                                sb.append(" ");
                        }
                    }
                    //sb.append("]");
                }
                return sb.toString();
            } // Polytope.toString
            public String toString(String indentString,
                                   boolean showAux,
                                   boolean showGoryDetails)
            {
                return toString(indentString,
                                showAux,
                                showGoryDetails,
                                null);
            }
            public String toString(String indentString,
                                   boolean showAux)
            {
                return toString(indentString,
                                showAux,
                                false);
            }
            public String toString(String indentString)
            {
                return toString(indentString,
                                false);
            }
            public String toString(boolean showAux)
            {
                return toString("",
                                showAux);
            }
            public String toString()
            {
                return toString("",
                                false);
            }

            /** Parses a polytope from a string the "pcalc" program's format. */
            // XXX should really do this from a reader, then fromString... could just hook up a StringReader and go
            // XXX this is private because it does NOT initialize the hyperplanes, the caller does.
            // XXX this should just be gotten rid of.
            private static Polytope fromStringInPcalcFormat(String s)
            {
                //System.out.println("scanning...");
                //System.out.flush();
                Polytope answer = null;
                {
                    int fullDim = -1;
                    Polytope facets[] = null;

                    String lines[] = s.trim().split("\\s*\n\\s*");

                    int iLine = 0;
                    for (int iDim = 0; ; iDim++)
                    {
                        if (iLine >= lines.length)
                            break;
                        String line = lines[iLine++];
                        // scan "%d %d-cel%*[^:]:", &nCells, &shouldBeIDim
                        java.util.regex.Matcher matcher = java.util.regex.Pattern.compile("(\\d+) (\\d+)-cell[^:]*:").matcher(line);
                        if (!matcher.matches())
                            throw new IllegalArgumentException("Polytope.fromStringInPcalcFormat: expected number of "+iDim+"-cells, got \""+line+"\"!");
                        int nCells = Integer.parseInt(matcher.group(1));
                        int shouldBeIDim = Integer.parseInt(matcher.group(2));

                        if (shouldBeIDim != iDim)
                            throw new IllegalArgumentException("Polytope.fromStringInPcalcFormat: expected "+iDim+"-cells, got "+shouldBeIDim+"-cells!");
                        if (nCells == 0)
                            continue;
                        Polytope cells[] = new Polytope[nCells];

                        for (int iCell = 0; (iCell) < (nCells); ++iCell)
                        {
                            if (iLine >= lines.length)
                                throw new IllegalArgumentException("Polytope.fromStringInPcalcFormat: premature end-of-string expecting "+iDim+"-cell "+iCell+"!");
                            line = lines[iLine++];
                            // Read the index and colon.  This is for human-readability
                            // and sanity checking.
                            // scan "%d:", &shouldBeICell
                            matcher = java.util.regex.Pattern.compile("(\\d+):(.*)").matcher(line);
                            if (!matcher.matches())
                                throw new IllegalArgumentException("Polytope.fromStringInPcalcFormat: expected "+iDim+"-cell "+iCell+", got \""+line+"\"!");
                            int shouldBeICell = Integer.parseInt(matcher.group(1));
                            String rest = matcher.group(2);

                            if (shouldBeICell != iCell)
                                throw new IllegalArgumentException("Polytope.fromStringInPcalcFormat: expected "+iDim+"-cell "+iCell+", got "+shouldBeICell+"!");
                            String tokens[] = rest.trim().split("\\s+");
                            if (iDim == 0)
                            {
                                //
                                // Read vertex coords from tokens on this line.
                                //
                                if (fullDim == -1)
                                    fullDim = tokens.length;
                                else
                                    if (tokens.length != fullDim)
                                    {
                                        throw new IllegalArgumentException("Polytope.fromStringInPcalcFormat: inconsistent vertex dimensions "+fullDim+", "+tokens.length+"!");
                                    }
                                double coords[] = new double[fullDim];
                                for (int iCoord = 0; (iCoord) < (fullDim); ++iCoord)
                                    coords[iCoord] = Double.valueOf(tokens[iCoord]).doubleValue();
                                cells[iCell] = new Polytope(iDim,
                                                            fullDim,
                                                            new SPolytope[0],
                                                            new Hyperplane[0], // contributing hyperplanes will get filled out later
                                                            null); // no aux
                                cells[iCell].setCoords(coords);
                            }
                            else
                            {
                                //
                                // Read signed facet indices from tokens on this line.
                                //
                                SPolytope mySignedFacets[] = new SPolytope[tokens.length];
                                for (int iToken = 0; (iToken) < (tokens.length); ++iToken)
                                {
                                    String token = tokens[iToken];
                                    int sign = 0;
                                    if (token.startsWith("-"))
                                        sign = -1;
                                    else if (token.startsWith("+"))
                                        sign = 1;
                                    else if (token.startsWith("!"))
                                        sign = 0;
                                    else
                                        throw new IllegalArgumentException("Polytope.fromStringInPcalcFormat: bad facet specification "+token+" in "+iDim+"-cell "+iCell+"!");
                                    token = token.substring(1);
                                    int iFacet = Integer.parseInt(token);
                                    if (iFacet < 0 || iFacet >= facets.length)
                                        throw new IllegalArgumentException("Polytope.fromStringInPcalcFormat: out-of-range facet specification "+token+" in "+iDim+"-cell "+iCell+"! (there are only "+facets.length+" possible facets)");
                                    mySignedFacets[iToken] = new SPolytope(0,sign,
                                                                           facets[iFacet]);
                                }
                                cells[iCell] = new Polytope(iDim,
                                                            fullDim,
                                                            mySignedFacets,
                                                            new Hyperplane[0], // contributing hyperplanes will get filled out later
                                                            null); // no aux
                            }
                        }

                        facets = cells;
                    }
                    if (facets == null || facets.length == 0)
                        throw new IllegalArgumentException("Polytope.fromStringInPcalcFormat: premature end-of-string or something");
                    answer = facets[0];
                }

                // Now we have to go through
                // and set the planes defining every element,
                // starting with the facets.
                if (answer.dim != answer.fullDim)
                    throw new IllegalArgumentException("Polytope.fromStringInPcalcFormat: dimension "+answer.dim+" does not match dimension of vertices "+answer.fullDim+"!");

                answer.contributingHyperplanes = new Hyperplane[0];
                for (int iFacet = 0; (iFacet) < (answer.facets.length); ++iFacet)
                {
                    SPolytope facet = answer.facets[iFacet];
                    double normal[] = new double[answer.fullDim];
                    areaNormal(normal, facet); // get area normal of facet
                    VecMath.normalize(normal,normal);
                    Polytope someVertexOnFacet = facet.p;
                    while (someVertexOnFacet.dim > 0)
                        someVertexOnFacet = someVertexOnFacet.facets[0].p;
                    double offset = VecMath.dot(normal, someVertexOnFacet.getCoords());
                    if (offset < 0.)
                    {
                        VecMath.vxs(normal, normal, -1.);
                        offset *= -1.;
                    }
                    Hyperplane hyperplane = new Hyperplane(normal, offset);
                    Hyperplane hyperplanes[] = {hyperplane};

                    //
                    // Add this hyperplane as a contributing
                    // hyperplane to every cell of this facet
                    // (including this facet itself).
                    //
                    Polytope allElements[][] = facet.p.getAllElements();
                    for (int i = 0; (i) < (allElements.length); ++i)
                    for (int j = 0; (j) < (allElements[i].length); ++j)
                    {
                        Polytope e = allElements[i][j];
                        e.contributingHyperplanes = unionOfHyperplanesAndSort(e.contributingHyperplanes, hyperplanes);
                    }
                }

                //System.out.println("done.");
                //System.out.flush();
                return answer;
            } // fromStringInPcalcFormat
        } // class Polytope

        /**
        *  Signed (oriented) polytope.
        *  <br>
        *  InitialDensity is the "density at (-inf,-inf,...)",
        *  which is 0 for finite polytopes and 1 for cofinite ones
        *  (the concept simply breaks down for polytopes
        *  that are neither finite nor cofinite).
        *  <p>
        *  Representing both finite and cofinite polytopes
        *  in this way eases our job in implementing CSG:
        *  we need only implement intersection;
        *  then the other operations are expressible trivially:
        *  <pre>
        *       union(A,B) = -intersect(-A,-B)
        *       diff(A,B)  = intersect(A,-B)
        *  </pre>
        */
        public static class SPolytope
        {
            public long id;
            public int initialDensity; // 0 or 1
            public int sign; // +1 or -1
            public Polytope p;
            public SPolytope(int initialDensity,
                             int sign,
                             Polytope p)
            {
                synchronized(nIdsLock)
                {
                    this.id = nIds++;
                }
                this.initialDensity = initialDensity;
                this.sign = sign;
                this.p = p;
            }

            public String toString(String indentString,
                                   boolean showAux,
                                   boolean showGoryDetails,
                                   java.util.HashSet<Object> printedAlready) // stores both SPolytype,SPolytope and Polytope,Polytope, I believe
            {
                String nl = System.getProperty("line.separator");
                if (printedAlready == null)
                    printedAlready = new java.util.HashSet<Object>();

                StringBuffer sb = new StringBuffer();
                if (showGoryDetails)
                {
                    sb.append("SPolytope "+id+" {" + nl);
                    if (printedAlready.contains(this))
                    {
                        sb.append(indentString + "    (printed already)" + nl);
                    }
                    else
                    {
                        printedAlready.add(this);

                        sb.append(indentString + "    initialDensity = " + initialDensity + nl);
                        sb.append(indentString + "    sign = " + sign + nl);
                        sb.append(indentString + "    p = " + p.toString(indentString+"    ", showAux, showGoryDetails, printedAlready) + nl);
                    }
                    sb.append(indentString + "}");
                }
                else
                {
                    if (initialDensity != 0)
                        sb.append(initialDensity);
                    sb.append(signToString(sign));
                    if (p != null)
                        sb.append(p.toString(indentString, showAux, showGoryDetails, printedAlready));
                    else
                        sb.append("null");
                }
                return sb.toString();
            } // SPolytope.toString
            public String toString(String indentString,
                                   boolean showAux,
                                   boolean showGoryDetails)
            {
                return toString(indentString,
                                showAux,
                                showGoryDetails,
                                null);
            }
            public String toString(String indentString,
                                   boolean showAux)
            {
                return toString(indentString, showAux, false);
            }
            public String toString(String indentString)
            {
                return toString(indentString, false);
            }
            public String toString(boolean showAux)
            {
                return toString("", showAux);
            }
            public String toString()
            {
                return toString("", false);
            }

            /** Parses a signed polytope from a string the "pcalc" program's format. */
            public static SPolytope fromStringInPcalcFormat(String s)
            {
                SPolytope answer = new SPolytope(0,1,Polytope.fromStringInPcalcFormat(s));
                bootstrapHyperplanes(answer);
                // XXX bleah, figure out whether the bootstrap function should do the following... note that bootstrapHyperplanes already called orientDeep twice :-(
                //PRINT(volume(answer));
                double vol = volume(answer);
                if (vol < 0)
                {
                    answer.sign *= -1;
                    // XXX should do the push-down-sign thing? yes

                    orientDeepFunctional(answer);
                    orientDeepCosmetic(answer);

                    // XXX really only want push-down-sign thing
                    // XXX and it's not even implemented!!! grrr
                }
                //PRINT(volume(answer));
                return answer;
            } // fromStringInPcalcFormat

        } // class SPolytope



    //
    // Some primitive SPolytopes...
    //
        /** Makes a point in zero dimensions. */
        public static SPolytope makePoint()
        {
            return new SPolytope(/*initialDensity=*/0,/*sign=*/1,
                                 new Polytope(/*dim=*/0,
                                              /*fullDim=*/0,
                                              /*facets=*/new SPolytope[0],
                                              /*contributingHyperplanes=*/new Hyperplane[0],
                                              /*aux=*/null));
        } // makePoint

        /** Makes a polygon from the given vertices in n dimensions. */
        public static SPolytope makePolygon(double verts[][])
        {
            int dim = 2;
            int fullDim = verts[0].length;
            do { if (!((fullDim)==(2))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+1069 +"): (" + "fullDim" + ")" + "==" + "(" + "2" + ") ("+(fullDim)+" vs. "+(2)+")"); } while (false); // XXX could try to do it in higher dimensions; would require getting a hyperplane basis for the othogonal complement space, I think
            int nVerts = verts.length;

            //
            // Create the hyperplanes...
            //
            Hyperplane hyperplanes[] = new Hyperplane[nVerts];
            {
                // scratch for loop... note edgeNormal can't be reused
                /// since the hyperplane stores a pointer to it.
                double edgeBackwards[] = new double[fullDim];
                for (int i = 0; (i) < (nVerts); ++i)
                {
                    VecMath.vmv(edgeBackwards, verts[i], verts[(i+1)%nVerts]);
                    double edgeNormal[] = VecMath.xv2(edgeBackwards);
                    hyperplanes[i] = new Hyperplane(edgeNormal,
                                                    VecMath.dot(edgeNormal,
                                                                verts[i]));
                }
            }
            //
            // Create a polytope for each vertex...
            //
            Polytope vertPolytopes[] = new Polytope[nVerts];
            {
                for (int i = 0; (i) < (nVerts); ++i)
                {
                    Hyperplane subHyperplanes[] = {hyperplanes[i],
                                                   hyperplanes[(i-1+nVerts)%nVerts]};
                    vertPolytopes[i] = new Polytope(0,
                                                    fullDim,
                                                    new SPolytope[0],
                                                    subHyperplanes,
                                                    null); // no aux
                }
            }
            //
            // Create a polytope for each edge...
            //
            SPolytope edgeSPolytopes[] = new SPolytope[nVerts];
            {
                for (int i = 0; (i) < (nVerts); ++i)
                {
                    Hyperplane subHyperplanes[] = {hyperplanes[i]};
                    SPolytope vertsThisEdge[] = {
                        new SPolytope(0,-1,vertPolytopes[i]),
                        new SPolytope(0,1, vertPolytopes[(i+1)%nVerts]),
                    };
                    edgeSPolytopes[i] = new SPolytope(0,1,
                                         new Polytope(1,
                                                      fullDim,
                                                      vertsThisEdge,
                                                      subHyperplanes,
                                                      null)); // no aux
                }
            }
            SPolytope faceSPolytope = new SPolytope(0,1,
                                          new Polytope(2,
                                                       fullDim,
                                                       edgeSPolytopes,
                                                       new Hyperplane[0],
                                                       null)); // no aux
            return faceSPolytope;
        } // makePolygon


        /**
        * Makes a regular (n/d)-gon of edge length 2, centered at the origin,
        * with a side pointing in the -Y axis direction.
        * (That makes it so that, when used as the right-hand-side
        * of a product, the result will appear face-first if -W means "first").
        */
        public static SPolytope makeRegularPolygon(int n, int d)
        {
            double verts[][] = new double[n][2];
            double R = 1./Math.sin(Math.PI*d/n); // circumradius
            for (int i = 0; (i) < (n); ++i)
            {
                double ang = -Math.PI*.5 + 2*Math.PI*d/n*(i+.5); // so a face points in the -Y axis dir
                verts[i][0] = R * Math.cos(ang);
                verts[i][1] = R * Math.sin(ang);
            }
            return makePolygon(verts);
        } // makeRegularPolygon

        /** Makes an n-dimensional simplex with edge length 2, centered at the origin. */
        public static SPolytope makeSimplex(int nDims)
        {
            do { if (!(nDims >= 0)) throw new Error("Assumption failed at "+"com/donhatchsw/util/CSG.prejava"+"("+1157 +"): " + "nDims >= 0" + ""); } while (false);
            if (nDims == 0) return makePoint();
            return makeRegularPolytope(VecMath.fillvec(nDims-1, 3));
        } // makeSimplex

        /** Makes an n-dimensional hypercube of in-radius 1, centered at the origin. */
        public static SPolytope makeHypercube(int nDims)
        {
            do { if (!(nDims >= 0)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+1165 +"): " + "nDims >= 0" + ""); } while (false);
            if (nDims == 0) return makePoint();
            int schlafli[] = VecMath.fillvec(nDims-1, 3);
            if (nDims-1 > 0)
                schlafli[0] = 4;
            return makeRegularPolytope(schlafli);
        } // makeHypercube(unit inRadius, centered at origin)

        /** Makes an n-dimensional hypercube with given center and in-radius. */
        public static SPolytope makeHypercube(double center[],
                                              double inRadius)
        {
            SPolytope answer = makeHypercube(center.length);
            Polytope verts[] = answer.p.getAllElements()[0];
            for (int iVert = 0; (iVert) < (verts.length); ++iVert)
            {
                // NOTE we are doing something highly illegal here,
                // and it invalidates every bounding box of every element of every dimension!
                // So we'll set them all to null, below.
                VecMath.vpsxv(verts[iVert].getCoords(),
                              center,
                              inRadius,
                              verts[iVert].getCoords());
            }
            for (int iFacet = 0; (iFacet) < (answer.p.facets.length); ++iFacet)
            {
                Hyperplane contributingHyperplanes[] = answer.p.facets[iFacet].p.contributingHyperplanes;
                do { if (!((contributingHyperplanes.length)==(1))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+1192 +"): (" + "contributingHyperplanes.length" + ")" + "==" + "(" + "1" + ") ("+(contributingHyperplanes.length)+" vs. "+(1)+")"); } while (false);
                Hyperplane hyperplane = contributingHyperplanes[0];
                do { if (!((hyperplane.offset)==(1))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+1194 +"): (" + "hyperplane.offset" + ")" + "==" + "(" + "1" + ") ("+(hyperplane.offset)+" vs. "+(1)+")"); } while (false);
                hyperplane.offset = VecMath.dot(hyperplane.normal, center) + inRadius;
            }
            {
              // invalidate all the bounding boxes, of every dimension.
              Polytope[][] allElements = answer.p.getAllElements();
              for (int i = 0; i < allElements.length; ++i) {
                for (int j = 0; j < allElements[i].length; ++j) {
                    allElements[i][j]._bbox = null;
                }
              }
            }
            return answer;
        } // makeHypercube


        /**
        * Makes a regular polytope of edge length 2, centered at the origin,
        * from its schlafli symbol.
        * The orientation is facet-first along the negative last coordinate
        * axis.
        */
        public static SPolytope makeRegularPolytope(int schlafli[/*nDims-1*/])
        {
            return makeRegularStarPolytope(schlafli, null, null);
        } // makeRegularPolytope

        // Calculate the characteristic simplex edge lengths
        // for the characteristic simplex of a {p,q,r,...,z}
        // with edge length 2.
        // The result is:
        //      x[0] = 1 = dist from vertex center to edge center
        //      x[1] = dist from edge center to face center
        //      x[2] = dist from face center to cell center
        //      ...
        //      x[nDims-3] = dist from peak center to ridge center
        //      x[nDims-2] = dist from ridge center to facet center
        //      x[nDims-1] = dist from facet center to whole thing center
        private static void calcCharacteristicSimplexEdgeLengthsSquared(
                        int nDims,
                        int schlafli[/*nDims-1*/],
                        int schlafliDenoms[/*nDims-1*/],
                        double lengthsSquared[/*nDims*/]) // return
        {
            if (nDims == 0)
                return;
            calcCharacteristicSimplexEdgeLengthsSquared(nDims-1, schlafli, schlafliDenoms, lengthsSquared);
            if (nDims == 1)
            {
                lengthsSquared[nDims-1] = 1;
                return;
            }
            if (nDims == 2)
            {
                //double edgeLength = 1./Math.tan(Math.PI*schlafliDenoms[nDims-2]/schlafli[nDims-2]);
                //lengthsSquared[nDims] = edgeLength*edgeLength;
                lengthsSquared[nDims-1]= cotSquaredPiTimes(schlafliDenoms[nDims-2],schlafli[nDims-2]);
                return;
            }
            do { if (!(nDims >= 3)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+1253 +"): " + "nDims >= 3" + ""); } while (false);

            // We want x[n] such that,
            // if consider the hypersphere centered at {x[0]..x[n]}
            // passing through the origin,
            // if we project everything away from the center
            // onto the tangent hyperplane at the origin,
            // then the right triangle formed by the three projected points:
            //          projected {x[0]..    x[n-1],0}  (i.e. projected facet center)
            //          projected {x[0]..  x[n-2],0,0}  (i.e. projected ridge center)
            //          projected {x[0]..x[n-3],0,0,0}  (i.e. projected peak center)
            // has angle pi/schlafli[nDims-1] at the projected peak center.
            // 
            // Hmm, I think it will be easier if we think in the translated coord space
            // in which the sphere center is at the origin.
            // We want x[n] such that,
            // if we consider the hypersphere centered at the origin
            // and passing through the vertex -x[0]..-x[n],
            // if we project everything away from the center onto the tangent hyperplane
            // at -x[0]..-x[n], then the right triangle formed by the three projected points:
            //          projected {0,0,...,                0,-x[n]}  (i.e. projected facet center)
            //          projected {0,0,...,        0,-x[n-1],-x[n]}  (i.e. projected ridge center)
            //          projected {0,0,...,0,-x[n-2],-x[n-1],-x[n]}  (i.e. projected peak center)
            // has angle pi/schlafli[nDims-1] at the projected peak center.
            //    sphere center = 0
            //    sphere radius = ||x0..xn||
            //    projected facet center = LERP(sphere center, facet center,  (sphere radius)^2 / ||sphere center - facet center||^2)
            //                           = (facet center) * (sphere radius)^2/||facet center||^2
            //                           = (...0,0,-x[n]) * (sphere radius)^2 / (x[n]^2)
            //    projected ridge center = (...0,-x[n-1],-x[n]) * (sphere radius)^2 / (x[n-1]^2 + x[n]^2)
            //    projected peak center = (...-x[n-2],-x[n-1],-x[n]) * (sphere radius)^2 / (x[n-2]^2 + x[n-1]^2 + x[n]^2)
            //
            // So we want x[n] that makes that right triangle
            // have angle pi/schlafli[nDims-2] at the projected peak center.
            // Note that in all three points, all but the last 3 coords is zero...
            // so we get a similar triangle if we omit all but the last 3 coords
            // and divide by (sphere radius)^2... and negate.
            // So really it all boils down to the 3d case, if we define:
            //         q = schlafli[n-2]
            //        x0 = x[n-2]
            //        x1 = x[n-1]
            //        x2 = x[n]
            //     facet = (0,0,x2) / x2^2
            //     ridge = (0,x1,x2) / (x1^2 + x2^2)
            //      peak = (x0,x1,x2) / (x0^2 + x1^2 + x2^2)
            // So we want x2 such that the following holds (all equivalent):
            //     ||ridge-peak||/||facet-peak|| = cos(pi/q)
            //     ||facet-ridge||/||facet-peak|| = sin(pi/q)
            //     ||facet-ridge||/||ridge-peak|| = tan(pi/q)
            // If q is very big then the angle pi/q will be very small and so
            // sin(pi/q) is the best formulation to use.
            // The other extreme is when q is just barely bigger than 2,
            // in which case pi/q is close to 90 degrees and so cos(pi/q) is the best to use.
            // But I wonder if there is a formula that is accurate for both,
            // that uses both the sin and cos (or uses the sin of the half-angle,
            // which is also accurate for angles in 0..90).
            // I'll just use the sin version for now.
            //
            // Feeding this into mathematica
            // (making my own norm so it doesn't get overly complicated
            // with abses)
            /*
                    facet = {0,0,x2} / (x2^2)
                    ridge = {0,x1,x2} / (x1^2 + x2^2)
                    peak  = {x0,x1,x2} / (x0^2 + x1^2 + x2^2)
                    norm[{a_,b_,c_}] = Sqrt[a^2+b^2+c^2]
                    Solve[norm[facet-ridge]/norm[facet-peak] == S, x2] // Simplify

                    Solve[norm[ridge-peak]/norm[facet-peak] == C, x2]
                    Solve[norm[facet-ridge]/norm[ridge-peak] == T, x2]
            */
            // Ha, got it!
            //      +- sqrt( -(-1+S^2)*x1^2*(x0^2+x1^2) / (-x1^2 + S^2*(x0^2+x1^2) ))
            // But it can probably be simplified...
            // S = sin(pi/q)
            double SS = sinSquaredPiTimes(schlafliDenoms[nDims-2],schlafli[nDims-2]);
            double x0sqrd = lengthsSquared[nDims-3];
            double x1sqrd = lengthsSquared[nDims-2];
            double x2sqrd = (1-SS)*x1sqrd*(x0sqrd+x1sqrd) / (-x1sqrd + SS*(x0sqrd+x1sqrd));
            lengthsSquared[nDims-1] = x2sqrd;
            // XXX this comes out negative for {4/5} for example... should see if I care. {4/9} is okay though
        } // calcCharacteristicSimplexEdgeLengthsSquared

        // greatest common divisor
        private static int gcd(int a, int b)
        {
            return b==0 ? a : gcd(b, a%b);
        }

        // sin(pi*n/d) squared, but do it without trig if it's a nice angle
        private static double sinSquaredPiTimes(int n, int d)
        {
            do { if (!(d != 0)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+1345 +"): " + "d != 0" + ""); } while (false);
            int sign = 1;
            if (n < 0)
            {
                n *= -1;
                sign *= -1;
            }
            if (d < 0)
            {
                d *= -1;
                sign *= -1;
            }
            int gcd = gcd(n,d);
            n /= gcd;
            d /= gcd;
            n %= 2*d;
            // so now 0 <= n/d < 2, i.e. in [0..360] degrees
            if (n > d)
            {
                n = 2*d - n;
                sign *= -1;
            }
            // so now 0 <= n/d <= 1, i.e. in [0..180] degrees
            if (2*n > d)
            {
                n = d - n;
            }
            // so now 0 <= n/d <= 1/2, i.e. in [0..90] degrees
            if (4*n > d)
                return sign*(1 - cosSquaredPiTimes(n, d));
            // so now 0 <= n/d <= 1/4, i.e. in [0..45] degrees
            do { if (!(0 <= n && 4*n <= d)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+1376 +"): " + "0 <= n && 4*n <= d" + ""); } while (false);
            //System.out.println("    "+n+"/"+d+"");
            if (true)
            {
                // http://mathworld.wolfram.com/TrigonometryAngles.html
                if (n==0) // 0 degrees
                    return sign * 0;
                if (n==1 && d==12) // 15 degrees
                    return sign * ((2.-Math.sqrt(3.))/4.);
                if (n==1 && d==10) // 18 degrees
                    return sign * ((3.-Math.sqrt(5.))/8.);
                if (n==1 && d==8) // 22.5 degrees
                    return sign * ((2.-Math.sqrt(2.))/4.);
                if (n==1 && d==6) // 30 degrees
                    return sign * (1./4.);
                if (n==1 && d==5) // 36 degrees
                    return sign * ((5.-Math.sqrt(5.))/8.);
                if (n==1 && d==4) // 45 degrees
                    return sign * (1./2.);
            }
            //System.out.println("    "+n+"/"+d+" !!!");
            double s = Math.sin(Math.PI*n/d);
            return sign*s*s;
        } // sinSquaredPiTimes

        // cos(pi*n/d) squared, but do it without trig if it's a nice angle
        private static double cosSquaredPiTimes(int n, int d)
        {
            // cos(pi*n/d) = sin(pi/2 - pi*n/d)
            //             = sin(pi * (1/2 - n/d))
            //             = sin(pi * (1/2 - n/d))
            //             = sin(pi * (d-2*n)/(2*d))
            return sinSquaredPiTimes(d-2*n, 2*d);
        }

        // tan(pi*n/d) squared, but do it without trig if it's a nice angle
        private static double tanSquaredPiTimes(int n, int d)
        {
            double s = sinSquaredPiTimes(n, d);
            return s / (1 - s);
        }
        // cot(pi*n/d) squared, but do it without trig if it's a nice angle
        private static double cotSquaredPiTimes(int n, int d)
        {
            double s = sinSquaredPiTimes(n, d);
            return (1 - s) / s;
        }

        private static String flagToString(Polytope flag[])
        {
            StringBuffer sb = new StringBuffer();
            sb.append("(");
            for (int i = 0; (i) < (flag.length); ++i)
            {
                sb.append(" "+dimToPrefix(flag[i].dim)+flag[i].id);
            }
            sb.append(" )");
            return sb.toString();
        } // flagToString

        /**
        * Creates a Wythoff polytope from a given polytope.
        * Returns a Wythoff-operator'ed p
        * corresponding to the Coxeter-Dynkin symbol
        * where a 1 in the symbol is a circled node,
        * a 0 in the symbol is a non-circled node,
        * and values between 0 and 1 (or greater than 1)
        * can be used to linearly interpolate.
        * In the general case, there is one facet for
        * each element of any dimension in the original,
        * but there may be fewer for specific cases
        * (namely when only one node is circled).
        * <p>
        * Assumptions:
        * <pre>
        *    p is regular
        *    p is centered at the origin
        *          XXX not sure whether this is really assumed; if it is, it should be fixed.
        *    p is full-dimensional
        </pre>
        * Starts by creating the topology of the full omnitruncated polytope
        * and then squashes out degeneracies.
        */
        public static SPolytope makeWythoffPolytope(SPolytope sp,
                                                    double wythoff[])
        {
            long baseId = nIds; // snapshot
            //System.out.println("in makeWythoffPolytope");
            //PRINTARRAY(wythoff);
            Polytope p = sp.p;
            do { if (!(wythoff != null)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+1466 +"): " + "wythoff != null" + ""); } while (false);
            do { if (!((wythoff.length)==(p.dim))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+1467 +"): (" + "wythoff.length" + ")" + "==" + "(" + "p.dim" + ") ("+(wythoff.length)+" vs. "+(p.dim)+")"); } while (false);

            //
            // The vertices of the omni correspond to the flags of p.
            // So enumerate all the flags...
            //
            java.util.ArrayList<Polytope[]> flags = new java.util.ArrayList<Polytope[]>();
            {
                java.util.ArrayList<Polytope[]> partialFlags = new java.util.ArrayList<Polytope[]>();
                partialFlags.add(new Polytope[]{p});
                for (int iPartialFlag = 0; (iPartialFlag) < (partialFlags.size()); ++iPartialFlag) // while growing
                {
                    Polytope partialFlag[] = partialFlags.get(iPartialFlag);
                    //System.out.println("    Looking at partial flag "+flagToString(partialFlag));
                    Polytope elt = partialFlag[partialFlag.length-1];
                    for (int iFacet = 0; (iFacet) < (elt.facets.length); ++iFacet)
                    {
                        Polytope facet = elt.facets[iFacet].p;
                        Polytope superPartialFlag[] = (Polytope[])Arrays.append(partialFlag, facet);
                        if (superPartialFlag.length == p.dim+1)
                        {

                            Polytope flag[] = (Polytope[])Arrays.subarray(superPartialFlag,1,superPartialFlag.length-1); // omit the cell itself
                            //System.out.println("        Adding flag "+flagToString(flag));
                            flags.add(flag);
                        }
                        else
                            partialFlags.add(superPartialFlag);
                    }
                }
            }

            //
            // The vertex of the omni corresponding to a given flag
            // of the original is some weighted sum of the flag
            // element centers.  What are the weights?
            // Well, those element centers form a simplex,
            // and we want the distance from the weighted sum to
            // each of the sides of the simplex to be the corresponding
            // wythoff coefficient.
            // So if normal_i is the inward normal towards element i
            // of the flag, we want
            // I.e. we want a row vector w = [w0 w1 w2]
            // such that:
            //              [   vert    ]
            // [w0 w1 w2] * [edge center] * (normal_i column vector) = wythoff_i
            //              [face center]
            // for each normal_i.
            // Note that normal_i is simply the i'th column
            // of the inverse of the flag mat, normalized.
            // Oh, except wythoff is listed backwards.
            //
            // We are assuming the original is regular,
            // which means we'll get the same weights no matter
            // which flag we use.
            //
            double originalCG[] = new double[p.fullDim];
            cgOfVerts(originalCG, p);
            double weights[] = new double[p.dim];
            {
                int nDims = p.dim;
                do { if (!((p.fullDim)==(nDims))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+1528 +"): (" + "p.fullDim" + ")" + "==" + "(" + "nDims" + ") ("+(p.fullDim)+" vs. "+(nDims)+")"); } while (false);
                double flagMat[][] = new double[nDims][nDims];
                Polytope[] flag = flags.get(0); // some flag
                for (int iDim = 0; (iDim) < (nDims); ++iDim)
                {
                    cgOfVerts(flagMat[iDim], flag[iDim]);
                    VecMath.vmv(flagMat[iDim],flagMat[iDim],originalCG);
                }
                double inwardNormalsMat[][] = VecMath.transpose(
                                              VecMath.invertmat(flagMat));
                for (int iDim = 0; (iDim) < (nDims); ++iDim)
                    VecMath.normalize(inwardNormalsMat[iDim], inwardNormalsMat[iDim]);
                double M[][] = VecMath.mxm(flagMat,
                                           VecMath.transpose(inwardNormalsMat));
                double wythoffBackwards[] = (double[])Arrays.reverse(wythoff);
                VecMath.vxinvm(weights, wythoffBackwards, M);
            }
            //PRINTVEC(originalCG);
            //PRINTVEC(wythoff);
            //PRINTVEC(weights);

            //
            // The elements of the omni correspond to chains
            // of elements in p ordered by inclusion,
            // where a single-element chain in p is a facet of the omni,
            // and a maximal chain (i.e. a flag) of p is a vertex of the omni,
            // and the null set chain is the whole omni.
            //
            // TODO: is the following what com.donhatchsw.util.SpecializedHashMap is for?
            java.util.HashMap<HashableSortedArray<Polytope>,Polytope> omniEltsHashTable = new java.util.HashMap<HashableSortedArray<Polytope>,Polytope>();

            for (int iFlag = 0; (iFlag) < (flags.size()); ++iFlag)
            {
                Polytope flag[] = flags.get(iFlag);
                Polytope omniVert = new Polytope(0,p.fullDim,new SPolytope[0],new Hyperplane[0],null);
                double coords[] = new double[p.fullDim];
                VecMath.copyvec(coords, originalCG); // start here
                double eltCenter[] = new double[p.fullDim]; // scratch
                for (int iDim = 0; iDim < flag.length; ++iDim)
                {
                    cgOfVerts(eltCenter, flag[iDim]);
                    VecMath.vmv(eltCenter, eltCenter, originalCG); // make it relative
                    VecMath.vpsxv(coords,
                                  coords,
                                  weights[iDim],
                                  eltCenter);
                }
                omniVert.setCoords(coords);
                omniEltsHashTable.put(new HashableSortedArray<Polytope>(flag), omniVert);
            }

            java.util.ArrayList<Polytope[]> subFlags = flags;
            flags = null;
            for (int iSubFlag = 0; (iSubFlag) < (subFlags.size()); ++iSubFlag) // while growing
            {
                Polytope subFlag[] = subFlags.get(iSubFlag);
                //System.out.println("    Looking at subFlag "+flagToString(subFlag));
                Polytope subFlagOmniElt = omniEltsHashTable.get(new HashableSortedArray<Polytope>(subFlag));
                for (int i = 0; (i) < (subFlag.length); ++i)
                {
                    Polytope subSubFlag[] = (Polytope[])Arrays.delete(subFlag, i);
                    Polytope subSubFlagOmniElt = omniEltsHashTable.get(new HashableSortedArray<Polytope>(subSubFlag));
                    if (subSubFlagOmniElt == null)
                    {
                        subSubFlagOmniElt = new Polytope(p.dim-subSubFlag.length,p.fullDim,new SPolytope[0],new Hyperplane[0],null);
                        omniEltsHashTable.put(new HashableSortedArray<Polytope>(subSubFlag), subSubFlagOmniElt);
                        subFlags.add(subSubFlag);
                    }
                    // make subFlagOmniElt a facet of subSubFlagOmniElt
                    subSubFlagOmniElt.facets = (SPolytope[])Arrays.append(subSubFlagOmniElt.facets, new SPolytope(0,1,subFlagOmniElt));
                }
            }

            // The omni itself is the omni elt corresponding to the empty set.
            SPolytope somni = new SPolytope(0,1,omniEltsHashTable.get(new HashableSortedArray<Polytope>(new Polytope[]{})));

            //
            // Get rid of degeneracies:
            //     For each zero-length edge, remove the edge and merge the vertices.
            //     Then for each face with only two edges, remove the face and merge the edges.
            //     Then for each cell with only two faces, remove the cell and merge the faces.
            //     ...
            //
            if (true)
            {
                java.util.HashMap<Polytope,Polytope> deadList = new java.util.HashMap<Polytope,Polytope>();
                Polytope allElements[][] = somni.p.getAllElements();
                MergeFind mergeFind = new MergeFind((int)(nIds-baseId));
                Polytope bulletinBoard[] = new Polytope[(int)(nIds-baseId)];
                boolean mergedSomething = false;
                for (int iDim = 0; (iDim) < (somni.p.dim); ++iDim)
                {
                    for (int jElt = 0; (jElt) < (allElements[iDim+1].length); ++jElt)
                    {
                        Polytope elt = allElements[iDim+1][jElt];
                        if (iDim == 0)
                        {
                            //
                            // elt is an edge;
                            // if its two endpoints are coincident,
                            // remove the edge and merge the two
                            // vertices.
                            //
                            do { if (!((elt.facets.length)==(2))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+1631 +"): (" + "elt.facets.length" + ")" + "==" + "(" + "2" + ") ("+(elt.facets.length)+" vs. "+(2)+")"); } while (false);
                            //PRINTVEC(elt.facets[0].p.getCoords());
                            //PRINTVEC(elt.facets[1].p.getCoords());
                            if (VecMath.distsqrd(elt.facets[0].p.getCoords(),
                                                 elt.facets[1].p.getCoords()) <= 1e-6*1e-6) // XXX not completely sure this is right, maybe should be a param
                            {
                                mergedSomething = true;
                                //System.out.println("    MERGING!");
                                // The two vertices are coincident;
                                // merge them
                                mergeFind.merge((int)(elt.facets[0].p.id-baseId),
                                                (int)(elt.facets[1].p.id-baseId));
                                bulletinBoard[(int)(elt.facets[0].p.id-baseId)] = elt.facets[0].p;
                                bulletinBoard[(int)(elt.facets[1].p.id-baseId)] = elt.facets[1].p;
                                // kill this edge
                                deadList.put(elt,elt);
                            }
                            else
                            {
                                //System.out.println("    not merging!");
                            }
                        }
                        else
                        {
                            //
                            // Elt is a polygon or higher.
                            // Compress out the dead facets from
                            // elt's facets list.
                            // There will be 0, or 2, or >=3 facets left.
                            // If there are exactly 2, merge them.
                            // If there were 0 or 2, kill elt.
                            //
                            int nLivingFacets = 0;
                            for (int kFacet = 0; (kFacet) < (elt.facets.length); ++kFacet)
                            {
                                if (deadList.get(elt.facets[kFacet].p) == null)
                                    elt.facets[nLivingFacets++] = elt.facets[kFacet];
                            }
                            do { if (!(nLivingFacets == 0 || nLivingFacets == 2 || nLivingFacets >= 3)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+1669 +"): " + "nLivingFacets == 0 || nLivingFacets == 2 || nLivingFacets >= 3" + ""); } while (false)

                                                     ;
                            if (nLivingFacets == 2)
                            {
                                mergedSomething = true;
                                //System.out.println("    MERGING!");
                                // merge them
                                mergeFind.merge((int)(elt.facets[0].p.id-baseId),
                                                (int)(elt.facets[1].p.id-baseId));
                                bulletinBoard[(int)(elt.facets[0].p.id-baseId)] = elt.facets[0].p;
                                bulletinBoard[(int)(elt.facets[1].p.id-baseId)] = elt.facets[1].p;
                            }
                            else
                            {
                                //System.out.println("    not merging!");
                            }
                            if (nLivingFacets <= 2)
                            {
                                //System.out.println("    KILLING ELT!");
                                // kill elt
                                deadList.put(elt, elt);
                            }
                            else
                            {
                                //System.out.println("    not killing elt!");
                                elt.facets = (SPolytope[])Arrays.subarray(elt.facets, 0, nLivingFacets);
                            }
                        }
                    }
                    // Go through the iDim-dimensional elements' facet lists
                    // again and replace any merged facets
                    // with the merged group leader; then all but the leader
                    // will die
                    for (int jElt = 0; (jElt) < (allElements[iDim+1].length); ++jElt)
                    {
                        Polytope elt = allElements[iDim+1][jElt];
                        for (int kFacet = 0; (kFacet) < (elt.facets.length); ++kFacet)
                        {
                            int key = (int)(elt.facets[kFacet].p.id - baseId);
                            int leader = mergeFind.find(key);
                            if (leader != key)
                                elt.facets[kFacet].p = bulletinBoard[leader];
                        }
                    }
                }


                if (mergedSomething)
                {
                    //System.out.println("CLEARING ALLELEMENTS");
                    // We called allElements (which triggers
                    // all elements to populate their _allElements lists)
                    // and then changed stuff,
                    // so all the element lists are bogus now.
                    // Clear them.
                    for (int iDim = 0; (iDim) < (sp.p.dim+1); ++iDim)
                        for (int jElt = 0; (jElt) < (allElements[iDim].length); ++jElt)
                            allElements[iDim][jElt]._allElements = null;
                }

                // If completely dead (which happens if all the wythoff
                // coeffs were zero), set somni.p to the single merged vertex.
                // Note this is a funny case; somni.p.dim ends up 0
                // but somni.p.fullDim ends up the original dimension.
                if (deadList.get(somni.p) != null)
                    somni.p = bulletinBoard[mergeFind.find((int)(allElements[0][0].id-baseId))];
            }

            //
            // Make the hyperplanes, and orient and everything.
            //
            bootstrapHyperplanes(somni);

            //System.out.println("out makeWythoffPolytope");
            return somni;
        } // makeWythoffPolytope

        private static boolean isLegalSchlafli(int schlafli[/*nDims-1*/],
                                               int schlafliDenoms[/*nDims-1*/])
        {
            do { if (!(schlafliDenoms != null)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+1750 +"): " + "schlafliDenoms != null" + ""); } while (false);
            do { if (!((schlafli.length)==(schlafliDenoms.length))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+1751 +"): (" + "schlafli.length" + ")" + "==" + "(" + "schlafliDenoms.length" + ") ("+(schlafli.length)+" vs. "+(schlafliDenoms.length)+")"); } while (false);
            if (schlafliDenoms == null)
                schlafliDenoms = VecMath.fillvec(schlafli.length, 1);
            // copy them so we can canonicalize them...
            schlafli = VecMath.copyvec(schlafli);
            schlafliDenoms = VecMath.copyvec(schlafliDenoms);
            for (int j = 0; (j) < (schlafli.length); ++j)
            {
                int n = schlafli[j];
                int d = schlafliDenoms[j];
                if (n == 0) return false;
                if (n < 0) n *= -1;
                if (d < 0) d *= -1;
                int gcd = gcd(n,d);
                n /= gcd; d /= gcd; // if n/d is legal then (k*n)/(k*d) is legal
                d %= n; // if n/d is legal then n/(k*n+d) is legal
                if (2*d > n)
                    d = n-d; // if n/d is legal then n/(n-d) is legal
                if (d == 0) return false;
                schlafli[j] = n;
                schlafliDenoms[j] = d;
            }
            int nDims = schlafli.length+1;
            if (nDims == 1)
                return true; // {}
            if (nDims == 2)
            {
                // polygon {n/d}
                // XXX note currently 4/5 assert-fails for some reason even though I think it should probably be legal-- I think it has to do with negative char simplex edge lengths
                return true;
            }

            if (arrayIsAll(schlafli, 0, schlafli.length, 3))
            {
                // {3,3,...,3} -- simplex
                if (!arrayIsAll(schlafliDenoms, 0, schlafliDenoms.length, 1))
                    return false; // XXX should allow other denominators I think
                return true;
            }
            if (schlafli[0]==4 && arrayIsAll(schlafli, 1, schlafli.length-1, 3))
            {
                // {4,3,...,3} -- hypercube
                if (!arrayIsAll(schlafliDenoms, 0, schlafliDenoms.length, 1))
                    return false; // XXX should allow other denominators I think
                return true;
            }
            if (arrayIsAll(schlafli, 0, schlafli.length-1, 3) && schlafli[schlafli.length-1] == 4)
            {
                // {3,...,3,4} -- cross
                if (!arrayIsAll(schlafliDenoms, 0, schlafliDenoms.length, 1))
                    return false; // XXX should allow other denominators I think
                return true;
            }
            // Finite number of special cases
            int specialCases[][][] = {
                {{3}, {5}}, // icosahedron
                {{5}, {3}}, // dodecahedron
                {{5,2},{5}}, // small stellated dodecahedron
                {{5,2},{3}}, // great stellated dodecahedron
                {{5}, {5,2}}, // great dodecahedron
                {{3}, {5,2}}, // great icosahedron
                {{3}, {4}, {3}}, // 24-cell
                {{5}, {3}, {3}}, // 120-cell
                {{3}, {3}, {5}}, // 600-cell
                {{5,2},{5}, {3}},
                {{3}, {5}, {5,2}},
                {{5}, {5,2},{5}},
                {{5,2},{3}, {5}},
                {{5}, {3}, {5,2}},
                {{5,2},{5}, {5,2}},
                {{3}, {5,2},{5}},
                {{5}, {5,2},{3}},
                {{5,2},{3}, {3}},
                {{3}, {3}, {5,2}},
            };

            for (int i = 0; (i) < (specialCases.length); ++i)
            {
                if (schlafli.length != specialCases[i].length)
                    continue;
                int j;
                for (j = 0; (j) < (schlafli.length); ++j)
                {
                    int n = schlafli[j];
                    int d = schlafliDenoms[j];
                    if (n != specialCases[i][j][0])
                        break; // doesn't match this special case
                    if (d != (specialCases[i][j].length==2 ? specialCases[i][j][1] : 1))
                        break; // doesn't match this special case
                }
                if (j == schlafli.length)
                    return true; // matched this special case
            }
            return false;
        } // isLegalSchlafli
        public static SPolytope makeRegularStarPolytope(int schlafli[/*nDims-1*/],
                                                        int schlafliDenoms[/*nDims-1*/],
                                                        double wythoffCoeffs[/*nDims*/])
        {
            boolean verbose = false; // can set to true to debug
            if (verbose) System.out.println("    in makeRegularStarPolytope");
            if (verbose) System.out.println("      schlafli="+Arrays.toStringCompact(schlafli));
            if (verbose) System.out.println("      schlafliDenoms="+Arrays.toStringCompact(schlafliDenoms));
            if (verbose) System.out.println("      wythoffCoeffs="+Arrays.toStringCompact(wythoffCoeffs));

            if (schlafliDenoms == null)
                schlafliDenoms = VecMath.fillvec(schlafli.length, 1);
            if (schlafli.length != schlafliDenoms.length)
                throw new IllegalArgumentException("Schlafli numerators "+Arrays.toStringCompact(schlafli)+" does not match schlafli denominators "+Arrays.toStringCompact(schlafliDenoms)+"");

            if (schlafli.length == 3
             && schlafli[0] == 5
             && schlafli[1] == 0
             && schlafli[2] == 3)
            {
                // Hack to smuggle a grand antiprism: {5,0,3}
                return makeGrandAntiprism();
            }

            if (schlafli.length == 2
             && schlafli[0] == 7
             && schlafli[1] == 0)
            {
                // Hack to smuggle a Frucht: {7,0}
                return makeFruchtPolyhedron(false);
            }
            if (schlafli.length == 2
             && schlafli[0] == 77
             && schlafli[1] == 0)
            {
                // Hack to smuggle a not-Frucht: {77,0}
                return makeFruchtPolyhedron(true);
            }

            if (schlafli.length == 3
             && schlafli[0] == 7
             && schlafli[1] == 0
             && schlafli[2] == 0)
            {
                // Hack to smuggle a fruity polychoron: {7,0,0}
                return makeFruityPolychoron();
            }

            if (!isLegalSchlafli(schlafli, schlafliDenoms))
            {
                // hack together a visible representation of it real quick
                String s = "{";
                for (int i = 0; (i) < (schlafli.length); ++i)
                {
                    s += schlafli[i];
                    if (schlafliDenoms[i] != 1)
                        s += "/"+schlafliDenoms[i];
                    if (i+1 < schlafli.length)
                        s += ",";
                }
                s += "}";
                throw new IllegalArgumentException("Schlafli symbol "+s+" is not a regular polytope! Nice try though!");
            }
            int nDims = schlafli.length+1;
            if (nDims==2 && schlafli[0] >= 7)
            {
                // {p} -- polygon. The usual code would work
                // but it's rather inaccurate, so calculate the vertices directly.
                return makeRegularPolygon(schlafli[0], schlafliDenoms[0]);
            }

            //
            // Figure out the edge lengths
            // of the characteristic simplex.
            //
            double characteristicSimplexEdgeLengthsSquared[] = new double[nDims];
            calcCharacteristicSimplexEdgeLengthsSquared(nDims,
                                                        schlafli,
                                                        schlafliDenoms,
                                                        characteristicSimplexEdgeLengthsSquared);
            if (verbose) System.out.println("        " + "characteristicSimplexEdgeLengthsSquared" + " = " + Arrays.toStringCompact(characteristicSimplexEdgeLengthsSquared));

            //
            // Actually make a characteristic simplex.
            // It will be scaled so that the polytope's edge length is 1.
            //
            double characteristicSimplex[][] = new double[nDims+1][nDims];
            if (nDims > 0)
            {
                double initialVertex[] = characteristicSimplex[0];
                for (int jDim = 0; (jDim) < (nDims); ++jDim)
                    initialVertex[jDim] = -Math.sqrt(characteristicSimplexEdgeLengthsSquared[jDim]);
                for (int iDim = 0; (iDim) < (nDims+1); ++iDim)
                for (int jDim = 0; (jDim) < (nDims); ++jDim)
                    characteristicSimplex[iDim][jDim] = (jDim>=iDim ? initialVertex[jDim] : 0.);
            }
            if (verbose) System.out.println("        " + "characteristicSimplex" + " =\n" + VecMath.toString(characteristicSimplex));

            double circumRadius = Math.sqrt(VecMath.sum(characteristicSimplexEdgeLengthsSquared));
            if (verbose) {System.out.print("        "); System.out.println("circumRadius" + " = " + (circumRadius));};
            if (verbose) {System.out.print("        "); System.out.println("VecMath.norm(characteristicSimplex[0])" + " = " + (VecMath.norm(characteristicSimplex[0])));};


            //
            // Make the initial flag.
            // It will be a spherical simplex,
            // consisting of all the vertices of the characteristic simplex
            // except the origin, projected onto the unit sphere.
            // I.e. its vertices will be the projected-to-sphere centers
            // of an incident vertex, edge, face, cell, ..., peak, ridge, facet.
            // XXX hmm, I'm not sure about this normalizing everything to
            // XXX sphere thing...  e.g. for cube, shouldn't everything
            // be in exact arithmetic?
            // 
            double initialFlag[][] = new double[nDims][nDims];
            for (int iDim = 0; (iDim) < (nDims); ++iDim)
                VecMath.normalize(initialFlag[iDim], characteristicSimplex[iDim]);
            if (verbose) System.out.println("        " + "initialFlag" + " =\n" + VecMath.toString(initialFlag));

            //
            // Figure out the flag normals.
            //
            double initialFlagNormals[][] = VecMath.transpose(
                                            VecMath.invertmat(initialFlag));
            for (int iDim = 0; (iDim) < (nDims); ++iDim)
                VecMath.normalize(initialFlagNormals[iDim], initialFlagNormals[iDim]); // XXX not really necessary, could generate the reflections without this!
            if (verbose) System.out.println("        " + "initialFlagNormals" + " =\n" + VecMath.toString(initialFlagNormals));

            //
            // The generators for the symmetry group
            // are the reflections in each of the flag normal directions.
            //
            double gens[][][] = new double[nDims][nDims][nDims];
            for (int iDim = 0; (iDim) < (nDims); ++iDim)
            {
                double normal[] = initialFlagNormals[iDim];
                // gens[iDim] = I - 2 normal^T normal
                VecMath.identitymat(gens[iDim]);
                for (int jDim = 0; (jDim) < (nDims); ++jDim)
                for (int kDim = 0; (kDim) < (nDims); ++kDim)
                    gens[iDim][jDim][kDim] -= 2 * normal[jDim]
                                                * normal[kDim];
            }

            //
            // Reflect the initial flag in all possible ways
            // using the generators repeatedly.
            //
            java.util.ArrayList<double[][]> flagList = new java.util.ArrayList<double[][]>();
            {
                FuzzyPointHashTable<double[][]> flagHashTable = new FuzzyPointHashTable<double[][]>(1e-9,
                                                                                                    1e-8,
                                                                                                    1./512);
                flagList.add(initialFlag);
                flagHashTable.put(VecMath.flatten(initialFlag), initialFlag);

                double scratchFlag[][] = new double[nDims][nDims];
                double scratchFlagFlattened[] = new double[nDims*nDims];
                for (int iFlag = 0; (iFlag) < (flagList.size()); ++iFlag) // while it's growing
                {
                    double flag[][] = flagList.get(iFlag);
                    for (int iGen = 0; (iGen) < (nDims); ++iGen)
                    {
                        VecMath.mxm(scratchFlag,
                                    flag, gens[iGen]);
                        // don't let it drift...
                        for (int iDim = 0; (iDim) < (nDims); ++iDim)
                            VecMath.normalize(flag[iDim], flag[iDim]);

                        VecMath.flatten(scratchFlagFlattened, scratchFlag);
                        if (flagHashTable.put(scratchFlagFlattened,
                                              scratchFlag) == null)
                        {
                            //
                            // It wasn't already there... we found a new flag.
                            //
                            flagList.add(VecMath.copymat(scratchFlag));

                            // The hash table now owns the scratch flag
                            // and flattened, so we have to make another
                            scratchFlag = new double[nDims][nDims];
                            scratchFlagFlattened = new double[nDims*nDims];
                        }
                    }
                    //CHECK(flagList.size() < 1000*1000); // XXX not right, but for now
                    //CHECK(flagList.size() < 100); // XXX not right, but for now
                }
            }
            if (verbose) {System.out.print("        "); System.out.println("flagList.size()" + " = " + (flagList.size()));};

            //
            // Enumerate all the polytope elements.
            // We assume any two elements of the same dimension
            // and same projected-onto-sphere center are the same.
            // (I think this is safe for regular polytopes,
            // but wouldn't be safe in general, e.g. for uniform
            // polytopes some of whose faces pass through the origin).
            //
            Polytope wholeThing = new Polytope(nDims,nDims,new SPolytope[0],new Hyperplane[0],null);
            if (verbose) {System.out.print("        "); System.out.println("wholeThing.id" + " = " + (wholeThing.id));};
            {
                // workaround 3 from https://programming.guide/java/generic-array-creation.html
                @SuppressWarnings("serial") class ArrayList_Polytope extends java.util.ArrayList<Polytope> {}
                ArrayList_Polytope elementLists[] = new ArrayList_Polytope[nDims+1];
                // workaround 3 from https://programming.guide/java/generic-array-creation.html
                class FuzzyPointHashTable_Integer extends FuzzyPointHashTable<Integer> { public FuzzyPointHashTable_Integer(double a, double b, double c) { super(a,b,c); } };
                FuzzyPointHashTable_Integer elementHashTables[] = new FuzzyPointHashTable_Integer[nDims+1];

                for (int iDim = 0; (iDim) < (nDims+1); ++iDim)
                {
                    elementLists[iDim] = new ArrayList_Polytope();
                    elementHashTables[iDim] = new FuzzyPointHashTable_Integer(1e-9,
                                                                              1e-8,
                                                                              1./512);
                }
                // The whole one, which isn't mentioned explicitly
                // in the flags.  Don't need to put it in the hash table
                // because it's not going to collide with anyone.
                elementLists[nDims].add(wholeThing);

                //System.out.println("    starting something I think might be time consuming...");
                Polytope flagElements[] = new Polytope[nDims+1];
                for (int iFlag = 0; (iFlag) < (flagList.size()); ++iFlag)
                {
                    double flag[][] = flagList.get(iFlag);
                    for (int iDim = 0; (iDim) < (nDims); ++iDim)
                    {
                        int index;
                        {
                            Integer got = elementHashTables[iDim].get(flag[iDim]);
                            if (got != null)
                                index = got.intValue();
                            else
                            {
                                index = elementLists[iDim].size();
                                elementHashTables[iDim].put(flag[iDim], Integer.valueOf(index));
                                Polytope elt = new Polytope(iDim,nDims,new SPolytope[0],new Hyperplane[0],null);
                                if (iDim == 0)
                                {
                                    double coords[] = VecMath.vxs(flag[iDim],circumRadius);
                                    // Integerize if it's really close...
                                    for (int jDim = 0; (jDim) < (nDims); ++jDim)
                                    {
                                        double roundedCoord = Math.round(coords[jDim]);
                                        double off = coords[jDim]-roundedCoord;
                                        if (1.+off*off == 1.)
                                            coords[jDim] = roundedCoord;
                                    }
                                    elt.setCoords(coords);
                                }
                                elementLists[iDim].add(elt);
                            }
                        }
                        flagElements[iDim] = elementLists[iDim].get(index);
                    }
                    //
                    // For each iDim, make the iDim-dimensional element
                    // a facet of the (iDim+1)-dimensional element,
                    // if it isn't already.
                    //
                    for (int iDim = 0; (iDim) < (nDims); ++iDim)
                    {
                        Polytope littleGuy = flagElements[iDim];
                        Polytope bigGuy = iDim+1==nDims ? wholeThing
                                                        : flagElements[iDim+1];

                        // XXX shouldn't search or build the facets like this, it's O(n^2), argh! need hash table and vectors, or two passes counting first.
                        // XXX although, this doesn't seem to be the bottleneck, for the 120-cell at least, which is surprising
                        {
                            int iFacet;
                            for (iFacet = 0; (iFacet) < (bigGuy.facets.length); ++iFacet)
                                if (bigGuy.facets[iFacet].p == littleGuy)
                                    break;
                            if (iFacet == bigGuy.facets.length)
                            {
                                //System.out.println("    adding "+iDim+"-elt "+littleGuy.id+" to "+(iDim+1)+"-elt "+bigGuy.id+"");
                                bigGuy.facets = (SPolytope[])Arrays.append(bigGuy.facets, new SPolytope(0,1,littleGuy)); // XXX shouldn't build the array like this, it's O(n^2), argh!
                            }
                        }
                    }
                }
                //System.out.println("    ending something I think might be time consuming.");
                int elementCounts[] = new int[nDims+1];
                for (int iDim = 0; (iDim) < (nDims+1); ++iDim)
                    elementCounts[iDim] = elementLists[iDim].size();
                if (verbose) System.out.println("        " + "elementCounts" + " = " + Arrays.toStringCompact(elementCounts));
            }

            SPolytope sWholeThing = new SPolytope(0,1,wholeThing);
            if (wythoffCoeffs != null)
            {
                // makeWythoffPolytope doesn't need the hyperplanes,
                // it just looks at the vertices and bootstraps its own hyperplanes
                sWholeThing = makeWythoffPolytope(sWholeThing, wythoffCoeffs);
            }
            else
                bootstrapHyperplanes(sWholeThing);
            if (verbose) System.out.println("    out makeRegularStarPolytope");
            return sWholeThing;
        } // makeRegularStarPolytope

        // XXX argh, this is lame
        private static void bootstrapHyperplanes(SPolytope sp)
        {
            for (int iStupidTimes = 0; (iStupidTimes) < (2); ++iStupidTimes) // XXX this is stupid, the first time the normal calculation will be wrong, but it will fill the arrays which orientDeep needs
            {
                {
                    // XXX clear the hyperplanes, oh my god this is lame
                    Polytope allElements[][] = sp.p.getAllElements();
                    for (int i = 0; (i) < (allElements.length); ++i)
                    for (int j = 0; (j) < (allElements[i].length); ++j)
                        allElements[i][j].contributingHyperplanes = new Hyperplane[0];
                }

                // Now we have to go through
                // and set the planes defining every element,
                // starting with the facets.
                // XXX duplicate code in fromStringInPcalcFormat, should make a function
                sp.p.contributingHyperplanes = new Hyperplane[0];
                for (int iFacet = 0; (iFacet) < (sp.p.facets.length); ++iFacet)
                {
                    SPolytope facet = sp.p.facets[iFacet];
                    double normal[] = new double[sp.p.fullDim];
                    areaNormal(normal, facet); // get area normal of facet
                    VecMath.normalize(normal,normal);
                    Polytope someVertexOnFacet = facet.p;
                    while (someVertexOnFacet.dim > 0)
                        someVertexOnFacet = someVertexOnFacet.facets[0].p;
                    double offset = VecMath.dot(normal, someVertexOnFacet.getCoords());
                    if (offset < 0.)
                    {
                        VecMath.vxs(normal, normal, -1.);
                        offset *= -1.;
                    }
                    Hyperplane hyperplane = new Hyperplane(normal, offset);
                    Hyperplane hyperplanes[] = {hyperplane};

                    //
                    // Add this hyperplane as a contributing
                    // hyperplane to every cell of this facet
                    // (including this facet itself).
                    //
                    Polytope allElements[][] = facet.p.getAllElements();
                    for (int i = 0; (i) < (allElements.length); ++i)
                    for (int j = 0; (j) < (allElements[i].length); ++j)
                    {
                        Polytope e = allElements[i][j];
                        e.contributingHyperplanes = unionOfHyperplanesAndSort(e.contributingHyperplanes, hyperplanes);
                    }
                }
                orientDeepFunctional(sp);
                orientDeepCosmetic(sp);
            }
        } // bootstrapHyperplanes

        // Tell whether array[i0]..array[i0+n-1] is all x's.
        private static boolean arrayIsAll(int array[], int i0, int n, int x)
        {
            for (int i = 0; i < n; ++i)
                if (array[i0+i] != x)
                    return false;
            return true;
        } // isAll

        /** Makes a product of regular (star) polytopes. */
        public static SPolytope makeRegularStarPolytopeProduct(int schlaflis[][],
                                                               int schlafliDenomss[][],
                                                               double wythoffs[][])
        {
            int nFactors = schlaflis.length;
            do { if (!(schlafliDenomss == null || schlafliDenomss.length == nFactors)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+2216 +"): " + "schlafliDenomss == null || schlafliDenomss.length == nFactors" + ""); } while (false)
                                                     ;
            SPolytope product = null; // placeholder representing a vertex in 0 dimensions
            for (int iFactor = 0; (iFactor) < (nFactors); ++iFactor)
            {
                SPolytope factor = makeRegularStarPolytope(schlaflis[iFactor],
                                                           schlafliDenomss==null?null:schlafliDenomss[iFactor],
                                                           wythoffs==null?null:wythoffs[iFactor]);
                if (product == null)
                    product = factor;
                else
                    product = cross(product, factor);
            }
            // could actually initialize product to the following (a vertex) instead of null,
            // but that would just waste some time on the first cross product
            if (product == null)
                return new SPolytope(0,1,new Polytope(0,0,new SPolytope[0],new Hyperplane[0],null));
            return product;
        } // makeRegularStarPolytopeProduct

        /**
        * Yet another layer, which allows us to make some pyramids and maybe other things.
        * See discussion of joins in https://en.wikipedia.org/wiki/Schl%C3%A4fli_symbol#Prismatic_polytopes .
        */
        public static SPolytope makeRegularStarPolytopeProductJoinFromString(String s)
        {
            if (!s.contains("v"))
            {
                if (s.trim().equals("()"))
                    return makeHypercube(0); // a point
                // punt, just so I don't have to think about what zero terms means here
                return makeRegularStarPolytopeProductFromString(s);
            }
            String termStrings[] = s.trim().split("v");
            SPolytope join = null;
            for (int i = 0; i < termStrings.length; ++i)
            {
                // We handle "()" (a point) here because:
                // - it's too messy to do it inside makeRegularStarPolytopeProductFromString
                // - products don't need it anyway (they can just throw away any "()"
                //   that occurs as a factor).
                SPolytope term = termStrings[i].trim().equals("()") ? makeHypercube(0) // a point
                                                                    : makeRegularStarPolytopeProductFromString(termStrings[i]);
                if (join == null)
                    join = term;
                else
                    join = join(join, term);
            }
            return join;
        } // makeRegularStarPolytopeProductJoinFromString

        /**
        * Makes a product of regular (star) polytopes from a string specification,
        * for example <code>"{4,3}x{}x{5,3,3}xGrand_Antiprismx{3}x {3, 3,3,3,3 }x{} x {5/2,5} "</code>.
        * '*' can be used in place of 'x' as well.
        * There is also a join operator 'v' (see discussion of products and joins in
        * https://en.wikipedia.org/wiki/Schl%C3%A4fli_symbol#Prismatic_polytopes).
        * {2} or 2 can be used in place of {}.
        * <p>
        * Also instead of {5,3,3}, any of the following will do:
        * <pre>
        *       5,3,3                    (the braces are optional)
        *       (1)5(0)3(0)3(0)
        *       (1)-5-(0)-3-(0)-3-(0)    (dashes are optional, you can insert them for readability)
        *       (1)-5-(0)--(0)--(0)      (3's in the schlafli symbol may be omitted)
        *       (1)5(0)(0)(0)
        *       5,,                      (since the 3's may be omitted)
        * </pre>
        * You can put different things inside the parens to get
        * different wythoff variants.  Just don't make them all zero.
        * <p>
        * This is really just a convenience function that calls
        * {@link #makeRegularStarPolytopeProductSchlaflisAndWythoffsFromString makeRegularStarPolytopeProductSchlaflisAndWythoffsFromString}(s)
        * and then calls {@link #makeRegularStarPolytopeProduct makeRegularStarPolytopeProduct}() on the result.
        */
        public static SPolytope makeRegularStarPolytopeProductFromString(String s)
        {
            Object[][] schlaflisAndWythoffs = makeRegularStarPolytopeProductSchlaflisAndWythoffsFromString(s);
            int[][] schlaflis = (int[][])schlaflisAndWythoffs[0];
            int[][] schlafliDenoms = (int[][])schlaflisAndWythoffs[1];
            double[][] wythoffs = (double[][])schlaflisAndWythoffs[2];
            return makeRegularStarPolytopeProduct(schlaflis,
                                                  schlafliDenoms,
                                                  wythoffs);
        } // makeRegularStarPolytopeProductFromString

        /**
        * Parses a star polytope product string specification
        * into schlafli symbols (numerators and denominators)
        * and respective wythoff symbols.
        * <p>
        * For examples, see the doc for
        * {@link #makeRegularStarPolytopeProductFromString makeRegularStarPolytopeProductFromString}(s),
        * which works by calling this and then calling
        * {@link #makeRegularStarPolytopeProduct makeRegularStarPolytopeProduct} on the result.
        */
        public static Object[][] makeRegularStarPolytopeProductSchlaflisAndWythoffsFromString(String s)
        {
            // Oh ARGH. the thing we call, makeRegularStarPolytopeProduct, isn't general enough.
            // So we smuggle in grand antiprism as {5,0,3}.
            // Can't use negative numbers because '-' means something else
            // so the parsing would get confused.
            s = s.replaceAll("[Gg]rand.[Aa]nti[Pp]rism", "{5,0,3}");

            // Similarly for frucht, smuggle it in as {7,0},
            // and not-frucht as 77,0.
            s = s.replaceAll("[Nn]ot-?[Ff]rucht", "{77,0}");
            s = s.replaceAll("[Ff]rucht", "{7,0}");

            // Similarly for fruity, smuggle it in as {7,0,0}.
            s = s.replaceAll("[Ff]ruity", "{7,0,0}");

            String factors[] = s.trim().split("[x*]");

            // Discard any factors that are "()", since they are awkward
            // and they don't contribute to the product.
            // CBB: and what if nothing's left?  Pretty sure I'm not handling that right.
            {
                int nNontrivialFactors = 0;
                for (int i = 0; i < factors.length; ++i)
                {
                    if (!factors[i].trim().equals("()"))
                    {
                        factors[nNontrivialFactors++] = factors[i];
                    }
                }
                if (nNontrivialFactors != factors.length)
                {
                    factors = (String[])Arrays.subarray(factors, 0, nNontrivialFactors);
                }
            }

            int schlaflis[][] = new int[factors.length][];
            int schlafliDenomss[][] = new int[factors.length][];
            double wythoffs[][] = new double [factors.length][];
            for (int iFactor = 0; (iFactor) < (factors.length); ++iFactor)
            {
                String factor = factors[iFactor].trim();
                if (factor.startsWith("{")
                 && factor.endsWith("}"))
                {
                    factor = factor.substring(1, factor.length()-1); // trim off { and }
                    factor = factor.trim(); // and any white space inside
                }
                if (factor.indexOf("{") != -1
                 || factor.indexOf("}") != -1)
                    throw new IllegalArgumentException("makeRegularStartPolytopeProductFromString: bad schlafli symbol \""+s+"\"");

                // XXX Formerly, we only did this if factor.indexOf("(") != -1.
                // XXX Now we do it all the time, so that there are no special cases.  Should look over the logic down inside makeRegularStarPolytopeProduct to make sure we're not suffering somehow because we are passing down wythoff coeffs unnecessarily.
                {
                    // Extract wythoff stuff
                    if (factor.endsWith(","))
                        factor += "3"; // so that we get the right number of (0)'s
                    factor = factor.replaceAll(",", "(0)");
                    if (!factor.startsWith("("))
                        factor = "(1)"+factor;
                    if (!factor.endsWith(")"))
                        factor += "(0)";
                    factor = factor.replaceAll("\\)-*\\(", ")3("); // 3's in the input schlafli symbol are implicit; make them explicit

                    String foo = factor;

                    factor = factor.replaceAll("-",""); // XXX seems unscientific
                    factor = factor.replaceAll("\\([^)]+\\)", ","); // done with the (w), change back to comma
                    if (factor.startsWith(","))
                        factor = factor.substring(1);
                    if (factor.endsWith(","))
                        factor = factor.substring(0,factor.length()-1);

                    //PRINT(foo);
                    //PRINT(factor);

                    // Now we can destroy foo if we like
                    double wythoff[] = new double[0];
                    while (foo.indexOf("(") != -1)
                    {
                        int open = foo.indexOf("(");
                        int close = foo.indexOf(")", open+1);
                        String coeffString = foo.substring(open+1, close);
                        //PRINT(coeffString);
                        // XXX need to catch
                        double coeff = Double.valueOf(coeffString).doubleValue();
                        wythoff = Arrays.append(wythoff, coeff);
                        foo = foo.substring(close+1);
                    }
                    wythoffs[iFactor] = wythoff;
                }

                String fractions[] = factor.split(",");
                if (factor.equals(""))
                    fractions = new String[0]; // to be safe (I don't trust split)
                schlaflis[iFactor] = new int[fractions.length];
                schlafliDenomss[iFactor] = new int[fractions.length];
                for (int iFraction = 0; (iFraction) < (fractions.length); ++iFraction)
                {
                    String fraction = fractions[iFraction].trim();
                    String n_and_d[] = fraction.split("/");
                    if (n_and_d.length == 2)
                    {
                        schlaflis[iFactor][iFraction] = Integer.parseInt(n_and_d[0]);
                        schlafliDenomss[iFactor][iFraction] = Integer.parseInt(n_and_d[1]);
                    }
                    else if (n_and_d.length == 1)
                    {
                        schlaflis[iFactor][iFraction] = Integer.parseInt(n_and_d[0]);
                        schlafliDenomss[iFactor][iFraction] = 1;
                    }
                    else
                        throw new IllegalArgumentException("makeRegularStartPolytopeProductFromString: bad schlafli symbol \""+s+"\"");
                }
                // Special case: {2/1} -> {}.
                // Maybe should really just remove any 2 from any of the lists,
                // but that would take a bit more work
                // and this is the only case that people really use anyway
                // (e.g. so they can express a pentagonal prism as 5x2).
                if (schlaflis[iFactor].length == 1
                 && schlaflis[iFactor][0] == 2)
                {
                    schlaflis[iFactor] = new int[0];
                    schlafliDenomss[iFactor] = new int[0];
                }
            } // FOR (iFactor, factors.length)
            //PRINTARRAY(s);
            //PRINTARRAY(schlaflis);
            //PRINTARRAY(schlafliDenomss);
            //PRINTARRAY(wythoffs);
            return new Object[][]{schlaflis, schlafliDenomss, wythoffs};
        } // makeRegularStarPolytopeProductSchlaflisAndWythoffsFromString


        public static SPolytope makeFruityPolychoron()
        {
          // Make the simplest asymmetric tetravalent polychoron.
          double[][] normalAndOffsetPairs = new double[][] {
            {-1,0,0,0,1},
            {1,0,0,0,1},
            {-.25,-1,0,-.25,.25},
            {-.25,1,0,-.25,.25},
            {.25,0,-1,-.25,.25},
            {.25,0,1,-.25,.25},
            ///* 6 */ {0,0,0,-1,1},  // omit the one towards the center (not that it matters, the bounding hypercube bounds it anyway)
            {1,1,1,1,2.75}, // truncate one vertex incident on the cube
          };
          // XXX make a function out of this?  hmm.
          SPolytope answer = makeHypercube(4); // unit in-radius
          SPolytope[] returnBelow = new SPolytope[1];
          for (int i = 0; i < normalAndOffsetPairs.length; ++i) {
              double[] normal = (double[])Arrays.subarray(normalAndOffsetPairs[i], 0, 4);
              double offset = normalAndOffsetPairs[i][4] * .25;
              Hyperplane hyperplane = new Hyperplane(normal, offset);
              slice(answer,
                    hyperplane,
                    /*aux=*/null,
                    returnBelow, /*returnBelowIndex=*/0,
                    /*returnBelowCapFacet=*/null, /*returnAboveCapFacetIndex=*/-1,
                    /*returnAboveCapFacet=*/null, /*returnAboveCapFacetIndex=*/-1,
                    /*returnAbove=*/null, /*returnAboveIndex=*/-1);
              answer = returnBelow[0];
          }
          // TODO: optimize, like for makeFruchtPolyhedron.
          return answer;
        }

        public static SPolytope makeFruchtPolyhedron(boolean notFruchtFlag)
        {
            // Make a polyhedron based on the Frucht graph--
            // that is, the simplest asymmmetric trivalent graph:
            //  *-----*
            //  |\    |\1
            //  | \ 6 *-*
            //  |  \ /  |
            //  |   *   |
            //  | 5 | 4 |
            //  |   *   |
            //  |  / \  |
            //  *-* 7 *-*
            //  3\|   |/2
            //    *---*
            double[][] normalAndOffsetPairs;
            if (false) {
              // connectivity nicely visible from front:  "frucht 3(10)"
              normalAndOffsetPairs = new double[][] {
                /* 0 */ {0,0,-1, .5},
                /* 1 */ {1,1,1, 1.5},
                /* 2 */ {1,-1,1, 1.5},
                /* 3 */ {-1,-1,1, 1.5},
                /* 4 */ {1,0,1, .75},
                /* 5 */ {-1,0,1, .75},
                /* 6 */ {0,1,1, 1},
                /* 7 */ {0,-1,1, 1},
              };
              System.out.println("NOTE: nonFruchtFlag not supported here"); // TODO: support it
            }
            if (false) {
              // (roughly) regular triangular prism with three vertices truncated with regular tris:  "frucht 3(4)"
              // actually regular tris aren't very good; they make the truncation planes too close to parallel
              // with the prism bases.  and it doesn't take too much heightening to fix that.
              double sin30 = Math.sin(30*Math.PI/180);
              double cos30 = Math.cos(30*Math.PI/180);
              double sqrt2 = Math.sqrt(2);
              normalAndOffsetPairs = new double[][] {
                /* 0 */ {0,0,-1, 1.5},
                /* 1 */ {cos30,2.5,-1+sin30, 7},
                /* 2 */ {cos30,-2.5,-1+sin30, 7},
                /* 3 */ {-cos30,-2.5,-1+sin30, 7},
                /* 4 */ {cos30,0,sin30, 1.5},
                /* 5 */ {-cos30,0,sin30, 1.5},
                /* 6 */ {0,1,0, 2},
                /* 7 */ {0,-1,0, 2},
              };
              System.out.println("NOTE: nonFruchtFlag not supported here"); // TODO: support it
            }
            if (true) {
              // heightening the truncating tris a bit.  "frucht 3(4)".
              // I think this ends up looking best.
              double sin30 = Math.sin(30*Math.PI/180);
              double cos30 = Math.cos(30*Math.PI/180);
              double sqrt2 = Math.sqrt(2);
              normalAndOffsetPairs = new double[][] {
                /* 0 */ {0,0,-1, 1.5},
                /* 1 */ {cos30,1.5,-1+sin30, 4.2},
                /* 2 */ {cos30,-1.5,-1+sin30, 4.2},
                /* 3 */ {-cos30,-1.5,-1+sin30, 4.2},
                /* 4 */ {cos30,0,sin30, 1.5},
                /* 5 */ {-cos30,0,sin30, 1.5},
                /* 6 */ {0,1,0, 2},
                /* 7 */ {0,-1,0, 2},
              };
              if (notFruchtFlag) {
                // fudge plane 2 to get non-frucht.
                // Instead of pointing right-down-back, point right-down
                normalAndOffsetPairs[2] = new double[]
                  /* 2 */ {cos30,-1.5,.5, 4}
                ;
              }
            }


            // XXX make a function out of this?  hmm.
            SPolytope answer = makeHypercube(3); // unit in-radius
            SPolytope[] returnBelow = new SPolytope[1];
            for (int i = 0; i < normalAndOffsetPairs.length; ++i) {
                double[] normal = (double[])Arrays.subarray(normalAndOffsetPairs[i], 0, 3);
                double offsetFudge = .24; // .25 is too big for not-frucht; .24 works fine for both
                double offset = normalAndOffsetPairs[i][3] * offsetFudge;
                Hyperplane hyperplane = new Hyperplane(normal, offset);
                slice(answer,
                      hyperplane,
                      /*aux=*/null,
                      returnBelow, /*returnBelowIndex=*/0,
                      /*returnBelowCapFacet=*/null, /*returnAboveCapFacetIndex=*/-1,
                      /*returnAboveCapFacet=*/null, /*returnAboveCapFacetIndex=*/-1,
                      /*returnAbove=*/null, /*returnAboveIndex=*/-1);
                answer = returnBelow[0];
            }

            if (true) {
                // this is awesome!  works with any of the above as a start, I think.
                // "frucht 3(4)" or "frucht 5(7)" or "frucht 7(10)" or "frucht 9(13)"
                // TODO: this apparently works best with only the first or third version above.  should make it better so that it always relaxes to the same thing.  I bet that will happen if I actually re-polytope-ize after each iteration (currently it doesn't actually re-planarize each face on each iteration, so maybe it gets happy in situations it shouldn't be and then gets a rude awakening only at the end when polytope-ized)
                int localVerboseLevel = 0;
                if (localVerboseLevel >= 1) System.out.println(""+"================================");
                if (localVerboseLevel >= 1) System.out.println(""+"ATTEMPTING TO REGULARIZE "+(notFruchtFlag?"NOT-FRUCHT":"FRUCHT")+"");
                // Try to regularize.
                // Goal is to make all the faces as close to regular polygons as possible, right?
                // So, repeatedly:
                // 1. for each face, find best fit regular, superimpose, say that's where the vertex wants to be.
                //    so each vertex has 3 goals.  Move it to the average of the 3 goals.
                // 2. Faces are no longer planar.  But find best fit plane through each.
                Polytope[][] allElements = answer.p.getAllElements();
                int[/*4*/][][/*4*/][] allIncidences = answer.p.getAllIncidences();
                int[] counts = counts(answer.p);
                do { if (!((counts.length)==(4))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+2589 +"): (" + "counts.length" + ")" + "==" + "(" + "4" + ") ("+(counts.length)+" vs. "+(4)+")"); } while (false);
                int nVerts = counts[0];
                int nEdges = counts[1];
                int nFaces = counts[2];
                int nCells = counts[3];
                do { if (!((nVerts)==(12))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+2594 +"): (" + "nVerts" + ")" + "==" + "(" + "12" + ") ("+(nVerts)+" vs. "+(12)+")"); } while (false);
                do { if (!((nEdges)==(18))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+2595 +"): (" + "nEdges" + ")" + "==" + "(" + "18" + ") ("+(nEdges)+" vs. "+(18)+")"); } while (false);
                do { if (!((nFaces)==(8))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+2596 +"): (" + "nFaces" + ")" + "==" + "(" + "8" + ") ("+(nFaces)+" vs. "+(8)+")"); } while (false);
                do { if (!((nCells)==(1))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+2597 +"): (" + "nCells" + ")" + "==" + "(" + "1" + ") ("+(nCells)+" vs. "+(1)+")"); } while (false);
                Polytope[] verts = allElements[0];

                double[][] scratchVertCoords = new double[nVerts][3];
                for (int iVert = 0; iVert < nVerts; ++iVert) {
                  VecMath.copyvec(scratchVertCoords[iVert], verts[iVert].getCoords());
                }
                //PRINTMAT(scratchVertCoords);

                // *ordered* verts around each face.
                // This is O(n^2) but whatever.
                int[][] f2v = new int[nFaces][];
                for (int iFace = 0; iFace < nFaces; ++iFace) {
                  //System.out.println("iFace = "+iFace);
                  //System.out.println("    verts on this face are "+Arrays.toStringCompact(allIncidences[2][iFace][0]));
                  do { if (!((allIncidences[2][iFace][0].length)==(allIncidences[2][iFace][1].length))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+2612 +"): (" + "allIncidences[2][iFace][0].length" + ")" + "==" + "(" + "allIncidences[2][iFace][1].length" + ") ("+(allIncidences[2][iFace][0].length)+" vs. "+(allIncidences[2][iFace][1].length)+")"); } while (false);
                  f2v[iFace] = new int[allIncidences[2][iFace][0].length];
                  int iFirstEdgeThisFace = allIncidences[2][iFace][1][0];
                  f2v[iFace][0] = allIncidences[1][iFirstEdgeThisFace][0][0];
                  f2v[iFace][1] = allIncidences[1][iFirstEdgeThisFace][0][1];
                  //System.out.println("    first two verts are "+f2v[iFace][0]+", "+f2v[iFace][1]);
                  int nextVertexOnFace = -1;
                  for (int iVertThisFace = 2; iVertThisFace < f2v[iFace].length; ++iVertThisFace) {
                    //System.out.println("    iVertThisFace = "+iVertThisFace);
                    // find the next vertex on this face: that is, the vertex that's adjacent to the previous, but is not equal to the previous-previous
                    for (int i = 0; i < f2v[iFace].length; ++i) {
                      int iVert = allIncidences[2][iFace][0][i];
                      //System.out.println("        iVert="+iVert+"?");
                      if (iVert == f2v[iFace][iVertThisFace-2]) continue;
                      if (iVert == f2v[iFace][iVertThisFace-1]) continue;
                      //System.out.println("            maybe...");
                      // is iVert adjacent to f2v[iFace][iVertThisFace-1]?
                      boolean foundThatItsAdjacent = false;
                      for (int j = 0; j < allIncidences[0][iVert][1].length; ++j) {
                        int iEdge = allIncidences[0][iVert][1][j];
                        if (allIncidences[1][iEdge][0][0] == f2v[iFace][iVertThisFace-1] || allIncidences[1][iEdge][0][1] == f2v[iFace][iVertThisFace-1]) {
                          foundThatItsAdjacent = true;
                        }
                      }
                      if (foundThatItsAdjacent) {
                        nextVertexOnFace = iVert;
                        break;
                      }
                    }
                    do { if (!(nextVertexOnFace != -1)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+2641 +"): " + "nextVertexOnFace != -1" + ""); } while (false);
                    f2v[iFace][iVertThisFace] = nextVertexOnFace;
                  }
                  //System.out.println("    f2v[iFace="+iFace+"] = "+Arrays.toStringCompact(f2v[iFace]));
                }

                int nIters = 100;
                //int nIters = 2;
                //int nIters = 0;

                // What's the average edge length?  Make that the target.
                double averageEdgeLength = 0.;
                for (int iEdge = 0; iEdge < nEdges; ++iEdge) {
                    averageEdgeLength += volume(new SPolytope(/*initialDensity*/0,/*sign=*/1,allElements[1][iEdge]));
                }
                averageEdgeLength /= nEdges;
                //PRINT(averageEdgeLength);

                double targetEdgeLength = averageEdgeLength;
                double[][][] regularPolygons = new double[8][][]; // max face size is 8
                for (int n = 0; n < regularPolygons.length; ++n) {
                  double circumRadius = n<=1 ? -1. : targetEdgeLength / (2 * Math.sin(Math.PI / n)); // https://www.mathopenref.com/polygonradius.html
                  //System.out.println("          targetEdgeLength="+targetEdgeLength+" n="+n+" -> circumRadius="+circumRadius);
                  regularPolygons[n] = new double[n][3];
                  for (int i = 0; i < n; ++i) {
                    regularPolygons[n][i][0] = Math.cos(2*Math.PI / n * i) * circumRadius;
                    regularPolygons[n][i][1] = Math.sin(2*Math.PI / n * i) * circumRadius;
                    regularPolygons[n][i][2] = 0.;
                  }
                }

                double[][] newScratchVertCoords = new double[nVerts][3]; // scratch for loop
                for (int iIter = 0; iIter < nIters; ++iIter)
                {
                  VecMath.zeromat(newScratchVertCoords);
                  for (int iFace = 0; iFace < nFaces; ++iFace)
                  {
                    // Find procrustes rotation and translation that best-fits a regular polygon of the appropriate size to this face's verts.
                    int gonality = f2v[iFace].length;
                    double[][] targetRegularPolygon = VecMath.bestFitRotatedAndTranslated(regularPolygons[gonality], get(scratchVertCoords, f2v[iFace]));
                    // targetRegularPolygon is now the set of target points for the vertices of this face.
                    for (int i = 0; i < gonality; ++i) {
                      int iVert = f2v[iFace][i];
                      VecMath.vpsxv(newScratchVertCoords[iVert], newScratchVertCoords[iVert], 1/3., targetRegularPolygon[i]);
                    }
                  }
                  VecMath.copymat(scratchVertCoords, newScratchVertCoords);
                }

                if (false) { // set to true to dump some svgs and exit
                  /*
                  make && java -classpath donhatchsw.jar com.donhatchsw.mc4d.PolytopePuzzleDescription "Frucht 3(5)" ; make && java -classpath donhatchsw.jar com.donhatchsw.mc4d.PolytopePuzzleDescription "Frucht 3(5)" | perl -ne 'print if (/xml/../^<\/svg/); flush;' >| ~/tmp/FOO.svg
                  */
                  System.out.println(""+"================================");
                  System.out.println(""+"ATTEMPTING TO ANSWER OSKAR'S QUESTION");
                  int edges[][] = new int[18][2];
                  do { if (!((allIncidences[1].length)==(18))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+2697 +"): (" + "allIncidences[1].length" + ")" + "==" + "(" + "18" + ") ("+(allIncidences[1].length)+" vs. "+(18)+")"); } while (false);
                  for (int iEdge = 0; iEdge < allIncidences[1].length; ++iEdge) {
                    do { if (!((allIncidences[1][iEdge][0].length)==(2))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+2699 +"): (" + "allIncidences[1][iEdge][0].length" + ")" + "==" + "(" + "2" + ") ("+(allIncidences[1][iEdge][0].length)+" vs. "+(2)+")"); } while (false);
                    int iVert = allIncidences[1][iEdge][0][0];
                    int jVert = allIncidences[1][iEdge][0][1];
                    edges[iEdge][0] = iVert;
                    edges[iEdge][1] = jVert;
                  }
                  //PRINTMAT(scratchVertCoords);
                  //PRINTMAT(edges);
                  //System.exit(33);

                  // Find index of the quad face(s).  1 for frucht, 2 for not-frucht.
                  int[] theQuadFaceIndices = {};
                  for (int iFace = 0; iFace < allIncidences[2].length; ++iFace) {
                    if (allIncidences[2][iFace][1].length == 4) {
                      System.out.println("      Found a quad at face index "+iFace);
                      theQuadFaceIndices = Arrays.append(theQuadFaceIndices, iFace);
                    }
                  }
                  do { if (!((theQuadFaceIndices.length)==((notFruchtFlag ? 3 : 1)))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+2717 +"): (" + "theQuadFaceIndices.length" + ")" + "==" + "(" + "(notFruchtFlag ? 3 : 1)" + ") ("+(theQuadFaceIndices.length)+" vs. "+((notFruchtFlag ? 3 : 1))+")"); } while (false);
                  for (int iQuadFaceIndex = 0; iQuadFaceIndex < theQuadFaceIndices.length; ++iQuadFaceIndex) {
                    int theQuadFaceIndex = theQuadFaceIndices[iQuadFaceIndex];
                    // Find the quad face vertices in order...
                    int quadVerts[] = VecMath.copyvec(allIncidences[2][theQuadFaceIndex][0]);
                    do { if (!((quadVerts.length)==(4))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+2722 +"): (" + "quadVerts.length" + ")" + "==" + "(" + "4" + ") ("+(quadVerts.length)+" vs. "+(4)+")"); } while (false);
                    // Which quad face vert is *not* incident on its vert 0?
                    int vert0 = quadVerts[0];
                    int oppositeVert0Index = -1;
                    for (int i = 1; i < 4; ++i) {
                      int maybeOppositeVert0 = quadVerts[i];
                      boolean theEdgeExists = false;
                      for (int iEdge = 0; iEdge < edges.length; ++iEdge) { // before adding the diagonals
                        if ((edges[iEdge][0] == vert0 && edges[iEdge][1] == maybeOppositeVert0)
                         || (edges[iEdge][1] == vert0 && edges[iEdge][0] == maybeOppositeVert0))
                        {
                           theEdgeExists = true;
                           break;
                        }
                      }
                      if (!theEdgeExists) {
                        do { if (!((oppositeVert0Index)==(-1))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+2738 +"): (" + "oppositeVert0Index" + ")" + "==" + "(" + "-1" + ") ("+(oppositeVert0Index)+" vs. "+(-1)+")"); } while (false);
                        oppositeVert0Index = i;
                      }
                    }
                    do { if (!(oppositeVert0Index != -1)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+2742 +"): " + "oppositeVert0Index != -1" + ""); } while (false);
                    int temp;
                    System.out.println("        " + "quadVerts" + " = " + Arrays.toStringCompact(quadVerts));
                    {temp=(quadVerts[2]);quadVerts[2]=(quadVerts[oppositeVert0Index]);quadVerts[oppositeVert0Index]=(temp);};
                    System.out.println("        " + "quadVerts" + " = " + Arrays.toStringCompact(quadVerts));
                    // Add two more edges of length sqrt(2) for this quad
                    edges = (int[][])Arrays.concat(edges, new int[][] {
                      {quadVerts[0], quadVerts[2]},
                      {quadVerts[1], quadVerts[3]},
                    });
                  }

                  int nItersEdgeSprings = 10000;
                  int[] weights = new int[nVerts]; // scratch for loop
                  for (int iIter = 0; iIter < nItersEdgeSprings; ++iIter) {
                    // Move each vert to the average of where its edge springs want to go...
                    VecMath.zeromat(newScratchVertCoords);
                    VecMath.zerovec(weights);
                    do { if (!((edges.length)==(18+2*(notFruchtFlag?3:1)))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+2760 +"): (" + "edges.length" + ")" + "==" + "(" + "18+2*(notFruchtFlag?3:1)" + ") ("+(edges.length)+" vs. "+(18+2*(notFruchtFlag?3:1))+")"); } while (false);
                    int nEdgesToEnforce = edges.length;
                    //int nEdgesToEnforce = 18;  // all but the square diagonals
                    for (int iEdge = 0; iEdge < nEdgesToEnforce; ++iEdge)
                    {
                      int i0 = edges[iEdge][0];
                      int i1 = edges[iEdge][1];
                      double desiredEdgeLength = (iEdge<18 ? 1. : Math.sqrt(2.));
                      double currentEdgeLength = VecMath.dist(scratchVertCoords[i0], scratchVertCoords[i1]);
                      double[] edgeCenter = VecMath.lerp(scratchVertCoords[i0], scratchVertCoords[i1], .5);
                      do { if (!(currentEdgeLength != 0.)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+2770 +"): " + "currentEdgeLength != 0." + ""); } while (false);
                      double target0[] = VecMath.lerp(edgeCenter, scratchVertCoords[i0], desiredEdgeLength/currentEdgeLength);
                      double target1[] = VecMath.lerp(edgeCenter, scratchVertCoords[i1], desiredEdgeLength/currentEdgeLength);
                      VecMath.vpv(newScratchVertCoords[i0], newScratchVertCoords[i0], target0);
                      VecMath.vpv(newScratchVertCoords[i1], newScratchVertCoords[i1], target1);
                      weights[i0]++;
                      weights[i1]++;
                    }
                    for (int iVert = 0; iVert < nVerts; ++iVert) {
                      if (weights[iVert] == 0) {
                        VecMath.copyvec(newScratchVertCoords[iVert], scratchVertCoords[iVert]);
                      } else {
                        VecMath.vxs(newScratchVertCoords[iVert], newScratchVertCoords[iVert], 1./weights[iVert]);
                      }
                    }
                    //PRINTMAT(newScratchVertCoords);
                    VecMath.copymat(scratchVertCoords, newScratchVertCoords);

                    {
                      // print edge lengths before normalizing
                      double edgeLengths[] = new double[edges.length];
                      for (int iEdge = 0; iEdge < edges.length; ++iEdge) {
                        edgeLengths[iEdge] = VecMath.dist(scratchVertCoords[edges[iEdge][0]], scratchVertCoords[edges[iEdge][1]]);
                      }
                      System.out.println("        " + "edgeLengths" + " = " + VecMath.toString(edgeLengths));
                    }

                    // And project to average-radius sphere.
                    {
                      double radiusSum = 0.;
                      for (int i = 0; i < scratchVertCoords.length; ++i) {
                        radiusSum += VecMath.norm(scratchVertCoords[i]);
                      }
                      double radiusAvg = radiusSum / scratchVertCoords.length;

                      if (false)
                      {
                        // (note, numbers changed since I changed a scale factor from .25 to .24 somewhere, oh well)
                        // see if we can make it converge to anything other than 1.1529514113610924.
                        // Yes, we can:
                        // If I use the LHS for first half, then relax, I get the following.
                        //    1.2 -> 1.1603250494151354
                        //    1.56 -> 1.1588165925160983
                        //    1.75 -> 1.1551804712278597
                        //    1.6 -> 1.1520790557486702
                        //    2 -> 1.4155905092142513
                        //    3 -> 2.8204609090536152  (but starts to be inside out)
                        //    4 -> 3.8895526737549204
                        //    5 -> 4.914543779458654
                        // hmm, but the large numbers end up looking all tangled.
                        // hmm, behavior is rather confusing.
                        if (iIter < nIters/2) {
                          //radiusAvg = 2.5; // inside out
                          radiusAvg = 2.45;
                          //radiusAvg = 2.4;
                          //radiusAvg = 2.3;
                          //radiusAvg = 2.25;
                          //radiusAvg = 2;  // inside out
                          //radiusAvg = 1.9;
                          //radiusAvg = 1.75;
                          //radiusAvg = 1.6; // starting to reverse.  Hmm, that's no good.
                          //radiusAvg = 1.58; // starting to reverse
                          //radiusAvg = 1.57; // starting to reverse
                          //radiusAvg = 1.56; // looks almost straight  (if we only do this to halfway and then let it snap back, it's not the final target)
                          //radiusAvg = 1.55; // good, barely
                          //radiusAvg = 1.5; // good, but looking very stretched
                          //radiusAvg = 1.25;  // good.  but can't get it to that exactly (using halfway) nor snapping, hmm.
                          //radiusAvg = 1.16;
                          //radiusAvg = 1.1588165925160983;
                          //radiusAvg = 1.14;
                          //radiusAvg = 1.1;
                          //radiusAvg = 1.;
                        }
                      }
                      {System.out.print("        "); System.out.println("radiusAvg" + " = " + (radiusAvg));};
                      if (false)
                      {
                        // (Hmm,  this converged to something different in general-- abandoning for now :-( )

                        // Let's try something more graceful.
                        // 0..1/3: let it relax
                        // 1/3..2/3: nudge it towards target
                        // 2/3..1: keep it at target.

                        //double target = 3;
                        //double target = 2;  // snaps to the side
                        double target = 1.56;
                        //double target = 1.2;  // no good, it can't get there!
                        //double target = 1.17; // nope, can't get there
                        //double target = 1.16;  // fine
                        //double target = 1.1588165925160983;  // fine

                        if (iIter < nIters*1/3) {
                          // nothing
                        } else if (iIter < nIters*2/3) {
                          radiusAvg = ((1-((iIter - nIters*1/3)/(double)(nIters*2/3-nIters*1/3)))*(radiusAvg) + ((iIter - nIters*1/3)/(double)(nIters*2/3-nIters*1/3))*(target));
                        } else {
                          radiusAvg = target;
                        }
                      }
                      {System.out.print("        "); System.out.println("radiusAvg" + " = " + (radiusAvg));};

                      for (int i = 0; i < scratchVertCoords.length; ++i) {
                        VecMath.vxs(scratchVertCoords[i], scratchVertCoords[i], radiusAvg / VecMath.norm(scratchVertCoords[i]));
                      }
                    }
                    {
                      // print edge lengths after normalizing
                      double edgeLengths[] = new double[edges.length];
                      for (int iEdge = 0; iEdge < edges.length; ++iEdge) {
                        edgeLengths[iEdge] = VecMath.dist(scratchVertCoords[edges[iEdge][0]], scratchVertCoords[edges[iEdge][1]]);
                      }
                      System.out.println("        " + "edgeLengths" + " = " + VecMath.toString(edgeLengths));
                    }
                    {
                      // and print radii
                      double radii[] = new double[scratchVertCoords.length];
                      for (int i = 0; i < scratchVertCoords.length; ++i)
                      {
                        radii[i] = VecMath.norm(scratchVertCoords[i]);
                      }
                      System.out.println("        " + "radii" + " = " + VecMath.toString(radii));
                    }
                  }
                  System.out.println("        " + "scratchVertCoords" + " =\n" + VecMath.toString(scratchVertCoords));
                  System.out.println("        " + "edges" + " = " + Arrays.toStringCompact(edges));

                  if (notFruchtFlag) {
                    // one of the quads comes out flat which isn't interesting.
                    // rotate y ever so slightly towards z.  or backwards.
                    double[][] fudgeRotMatYZ;
                    {
                      double fudgeDegreesYZ = 10;
                      double c = Math.cos(((fudgeDegreesYZ)*(Math.PI/180.)));
                      double s = Math.sin(((fudgeDegreesYZ)*(Math.PI/180.)));
                      fudgeRotMatYZ = new double[][] {
                        {1,0,0},
                        {0,c,s},
                        {0,-s,c},
                      };
                    }
                    double[][] fudgeRotMatXY;
                    {
                      double fudgeDegreesXY = 5;
                      double c = Math.cos(((fudgeDegreesXY)*(Math.PI/180.)));
                      double s = Math.sin(((fudgeDegreesXY)*(Math.PI/180.)));
                      fudgeRotMatXY = new double[][] {
                        {c,s,0},
                        {-s,c,0},
                        {0,0,1},
                      };
                    }
                    scratchVertCoords = VecMath.mxmxm(scratchVertCoords, fudgeRotMatXY, fudgeRotMatYZ);
                    //scratchVertCoords = VecMath.mxmxm(scratchVertCoords, fudgeRotMatYZ, fudgeRotMatXY);
                  } else {
                    double[][] fudgeRotMatXZ;
                    {
                      double fudgeDegreesXZ = -4;
                      double c = Math.cos(((fudgeDegreesXZ)*(Math.PI/180.)));
                      double s = Math.sin(((fudgeDegreesXZ)*(Math.PI/180.)));
                      fudgeRotMatXZ = new double[][] {
                        {c,0,s},
                        {0,1,0},
                        {-s,0,c},
                      };
                    }
                    double[][] fudgeRotMatYZ;
                    {
                      double fudgeDegreesYZ = 5;
                      double c = Math.cos(((fudgeDegreesYZ)*(Math.PI/180.)));
                      double s = Math.sin(((fudgeDegreesYZ)*(Math.PI/180.)));
                      fudgeRotMatYZ = new double[][] {
                        {1,0,0},
                        {0,c,s},
                        {0,-s,c},
                      };
                    }
                    scratchVertCoords = VecMath.mxmxm(scratchVertCoords, fudgeRotMatXZ, fudgeRotMatYZ);
                  }

                  if (true)
                  {
                    System.out.println("  Attempting to do some spherical circles");
                    double[][] circleXYRs = new double[2*nVerts][3];
                    int nSamplesPerCircle = 360;
                    double[][] samples3d = new double[nSamplesPerCircle*2*nVerts][3];
                    double[][][] edges3d = new double[nEdges][2][3];
                    double[][][] edges2d = new double[nEdges][2][2];
                    {
                      // Make circles on the sphere, and apply stereographic projection
                      // https://en.wikipedia.org/wiki/Stereographic_projection
                      double[] sphericalCircleAngularRadii = {
                        .01, // small, to draw a circle representing the center
                        .525, // tweaked til it's roughly right, meet in center of triangle, so edges-only puzzle
                        //.66,  // tweaked til it meets in center of square
                      };
                      for (int iRadius = 0; iRadius < sphericalCircleAngularRadii.length; ++iRadius) {
                        double sphericalCircleAngularRadius = sphericalCircleAngularRadii[iRadius];
                        double sin = Math.sin(sphericalCircleAngularRadius);
                        double cos= Math.cos(sphericalCircleAngularRadius);
                        for (int iEdge = 0; iEdge < nEdges; ++iEdge) {
                          for (int iEnd = 0; iEnd < 2; ++iEnd) {
                            edges3d[iEdge][iEnd] = VecMath.normalize(scratchVertCoords[edges[iEdge][iEnd]]);
                            edges2d[iEdge][iEnd][0] = edges3d[iEdge][iEnd][0]/(1+edges3d[iEdge][iEnd][2]);
                            edges2d[iEdge][iEnd][1] = edges3d[iEdge][iEnd][1]/(1+edges3d[iEdge][iEnd][2]);
                          }
                        }
                        for (int iVert = 0; iVert < nVerts; ++iVert) {
                          double[][] mat = new double[3][3];
                          VecMath.normalize(mat[0], scratchVertCoords[iVert]);
                          VecMath.extendAndOrthogonalize(1, 3, mat, mat);
                          double[] normal = mat[0];

                          for (int iSample = 0; iSample < nSamplesPerCircle; ++iSample) {
                            VecMath.sxvpsxvpsxv(samples3d[(iRadius*nVerts+iVert)*nSamplesPerCircle+iSample],
                                                cos, normal,
                                                sin*Math.cos(2*Math.PI*iSample/nSamplesPerCircle), mat[1],
                                                sin*Math.sin(2*Math.PI*iSample/nSamplesPerCircle), mat[2]);
                          }

                          // points3d will be the circle center, and 3 points on the circle.
                          double[][] points3d = new double[4][3];
                          VecMath.copyvec(points3d[0], normal);
                          VecMath.sxvpsxv(points3d[1], cos, normal, sin, mat[1]);
                          VecMath.sxvpsxv(points3d[2], cos, normal, sin, mat[2]);
                          VecMath.sxvpsxv(points3d[3], cos, normal, -sin, mat[1]);
                          // project those to the plane.
                          double points2d[][] = new double[4][2];
                          for (int i = 0; i < 4; ++i) {
                            points2d[i][0] = points3d[i][0]/(1+points3d[i][2]);
                            points2d[i][1] = points3d[i][1]/(1+points3d[i][2]);
                          }
                          System.out.println("        " + "points3d" + " =\n" + VecMath.toString(points3d));
                          System.out.println("        " + "points2d" + " =\n" + VecMath.toString(points2d));
                          // Find circumcircle of points2d[1,2,3].
                          // http://mathworld.wolfram.com/BarycentricCoordinates.html
                          // https://en.wikipedia.org/wiki/Circumscribed_circle#Barycentric_coordinates
                          double a = VecMath.dist(points2d[2], points2d[3]);
                          double b = VecMath.dist(points2d[3], points2d[1]);
                          double c = VecMath.dist(points2d[1], points2d[2]);
                          double aBary = a*a*(b*b+c*c-a*a);
                          double bBary = b*b*(c*c+a*a-b*b);
                          double cBary = c*c*(a*a+b*b-c*c);
                          double barySum = aBary+bBary+cBary;
                          aBary /= barySum;
                          bBary /= barySum;
                          cBary /= barySum;
                          double[] xy = VecMath.sxvpsxvpsxv(aBary, points2d[1],
                                                            bBary, points2d[2],
                                                            cBary, points2d[3]);
                          double r = a*b*c/Math.sqrt((a+b+c)*(b+c-a)*(c+a-b)*(a+b-c));
                          System.out.println("          aBary+bBary+cBary="+(aBary+bBary+cBary));
                          System.out.println("          r = "+r);
                          System.out.println("should be r = "+VecMath.dist(xy, points2d[1]));
                          System.out.println("should be r = "+VecMath.dist(xy, points2d[2]));
                          System.out.println("should be r = "+VecMath.dist(xy, points2d[3]));
                          circleXYRs[2*iVert+iRadius][0] = xy[0];
                          circleXYRs[2*iVert+iRadius][1] = xy[1];
                          circleXYRs[2*iVert+iRadius][2] = r;
                        }
                      } // for both radii
                    }



                    System.out.println("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>");
                    System.out.println("<svg xmlns:dc=\"http://purl.org/dc/elements/1.1/\" xmlns:cc=\"http://creativecommons.org/ns#\" xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns=\"http://www.w3.org/2000/svg\" width=\"256pt\" height=\"256pt\" viewBox=\"0.00 0.00 256.00 256.00\">");

                    if (true) // The stereographic projection on the plane
                    {
                      System.out.println("<g style=\"fill:none;stroke:#000000\" transform=\"translate(128,128)\">");
                      double scale = 35;
                      if (false) { // draw the edges too
                        System.out.println("<g style=\"fill:none;stroke:#e0e0e0\" transform=\"translate(0,0)\">");
                        for (int iEdge = 0; iEdge < nEdges; ++iEdge)
                        {
                          double x0 = edges2d[iEdge][0][0];
                          double y0 = edges2d[iEdge][0][1];
                          double x1 = edges2d[iEdge][1][0];
                          double y1 = edges2d[iEdge][1][1];
                          System.out.println("  <path d=\"M "+(x0*scale)+","+(-y0*scale)+" L"+(x1*scale)+","+(-y1*scale)+" \" />\"");
                        }
                        System.out.println("</g>");
                      }
                      for (int i = 0; i < circleXYRs.length; ++i) {
                        double cx = circleXYRs[i][0];
                        double cy = circleXYRs[i][1];
                        double r = circleXYRs[i][2];
                        System.out.println("<circle cx=\""+(cx*scale)+"\" cy=\""+(-cy*scale)+"\" r=\""+(r*scale)+"\" />");
                      }
                      System.out.println("</g>");
                    }
                    if (false) // The samples in 3d, so it looks like a sphere
                    {
                      double scale = 70;
                      double R = .01;
                      double r = .005;
                      System.out.println("<g style=\"fill:none;stroke:#e0e0e0\" transform=\"translate(128,128)\">");
                      for (int i = 0; i < samples3d.length; ++i) {
                        double cx = samples3d[i][0];
                        double cy = samples3d[i][1];
                        double cz = samples3d[i][2];
                        if (cz <= 0) {
                          System.out.println("<circle cx=\""+(cx*scale)+"\" cy=\""+(-cy*scale)+"\" r=\""+(r*scale)+"\" />");
                        }
                      }
                      System.out.println("</g>");

                      System.out.println("<g style=\"fill:none;stroke:#8080ff\" transform=\"translate(128,128)\">");
                      System.out.println("<circle stroke-width=\"3\" cx=\""+(0*scale)+"\" cy=\""+(-0*scale)+"\" r=\""+(1*scale)+"\" />");
                      System.out.println("</g>");

                      System.out.println("<g style=\"fill:none;stroke:#000000\" transform=\"translate(128,128)\">");
                      for (int i = 0; i < samples3d.length; ++i) {
                        double cx = samples3d[i][0];
                        double cy = samples3d[i][1];
                        double cz = samples3d[i][2];
                        if (cz >= 0) {
                          System.out.println("<circle cx=\""+(cx*scale)+"\" cy=\""+(-cy*scale)+"\" r=\""+(R*scale)+"\" />");
                        }
                      }
                      System.out.println("</g>");

                      if (true) { // draw the edges too
                        System.out.println("<g style=\"fill:none;stroke:#000000\" transform=\"translate(128,128)\">");
                        for (int iEdge = 0; iEdge < nEdges; ++iEdge)
                        {
                          double x0 = edges3d[iEdge][0][0];
                          double y0 = edges3d[iEdge][0][1];
                          double x1 = edges3d[iEdge][1][0];
                          double y1 = edges3d[iEdge][1][1];
                          System.out.println("  <path d=\"M "+(x0*scale)+","+(-y0*scale)+" L"+(x1*scale)+","+(-y1*scale)+" \" />\"");
                        }
                        System.out.println("</g>");
                      }
                    }
                    System.out.println("</svg>");

                    System.out.flush();

                  } // circles picture (3d or planar)

                  // Print a quick svg of it.
                  // As template of sorts, here is part of the svg for frucht graph from wikipedia:
                  /*
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:cc="http://creativecommons.org/ns#" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" width="224pt" height="214pt" viewBox="0.00 0.00 224.00 214.00">
<g style="fill:none;stroke:#000000" transform="translate(0,0)">
<path d="M 208,-97 C 204,-86 195,-60 192,-48" />

<g style="fill:blue;stroke:black">
<path d="M 143.59307,12.969697 L 153.32035,62.532468" />
<circle cx="102" cy="159" r="5" />
<g transform="translate(4,210)">
<circle cx="210" cy="-103" r="5" />
</g>
</g></svg>
                  */
                  if (false) { // svg of the polyhedron
                    System.out.println("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>");
                    System.out.println("<svg xmlns:dc=\"http://purl.org/dc/elements/1.1/\" xmlns:cc=\"http://creativecommons.org/ns#\" xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns=\"http://www.w3.org/2000/svg\" width=\"512pt\" height=\"214pt\" viewBox=\"0.00 0.00 224.00 214.00\">");

                    double scale = 50.;

                    System.out.println("<g style=\"fill:none;stroke:#000000\" transform=\"translate(-50,150)\">");
                    for (int iEdge = 0; iEdge < 18; ++iEdge) {
                      System.out.println("<path d=\"M "+(scratchVertCoords[edges[iEdge][0]][0]*scale)+","+(-scratchVertCoords[edges[iEdge][0]][1]*scale)+" L "+(scratchVertCoords[edges[iEdge][1]][0]*scale)+","+(-scratchVertCoords[edges[iEdge][1]][1]*scale)+"\" />");
                    }
                    System.out.println("</g>");

                    System.out.println("<g style=\"fill:none;stroke:#000000\" transform=\"translate(100,150)\">");
                    for (int iEdge = 0; iEdge < 18; ++iEdge) {
                      System.out.println("<path d=\"M "+(scratchVertCoords[edges[iEdge][0]][0]*scale)+","+(-scratchVertCoords[edges[iEdge][0]][2]*scale)+" L "+(scratchVertCoords[edges[iEdge][1]][0]*scale)+","+(-scratchVertCoords[edges[iEdge][1]][2]*scale)+"\" />");
                    }
                    System.out.println("</g>");

                    System.out.println("<g style=\"fill:none;stroke:#000000\" transform=\"translate(250,150)\">");
                    for (int iEdge = 0; iEdge < 18; ++iEdge) {
                      System.out.println("<path d=\"M "+(scratchVertCoords[edges[iEdge][0]][1]*scale)+","+(-scratchVertCoords[edges[iEdge][0]][2]*scale)+" L "+(scratchVertCoords[edges[iEdge][1]][1]*scale)+","+(-scratchVertCoords[edges[iEdge][1]][2]*scale)+"\" />");
                    }
                    System.out.println("</g>");

                    System.out.println("</svg>");
                    System.out.flush();

                  } // svg of just the polyhedron

                  System.out.println(""+"DONE ATTEMPTING TO ANSWER OSKAR'S QUESTION");
                  System.out.println(""+"================================");
                  System.exit(0);
                }

                // Ok, now we have scratchVertCoords, optimized.
                // Can we re-make the polyhedron, using that?
                // How?
                // Well, let's try to find a best-fit plane through each face's verts.
                // We can use the same code as above for finding a best-fit-regular polygon for a given face;
                // then just take the plane through that polygon.
                if (true)
                {
                    // Re-center vert-centroid of scratchVertCoords at origin
                    double[] centroid = VecMath.average(scratchVertCoords);
                    for (int iVert = 0; iVert < scratchVertCoords.length; ++iVert) {
                        VecMath.vmv(scratchVertCoords[iVert], scratchVertCoords[iVert], centroid);
                    }
                }
                double[][] newFaceNormals = new double[nFaces][3];
                double[] newFaceOffsets = new double[nFaces];
                for (int iFace = 0; iFace < nFaces; ++iFace) {
                    int gonality = f2v[iFace].length;

                    double[][] skewPolygon = get(scratchVertCoords, f2v[iFace]);
                    double[] skewPolygonNormal = new double[3];
                    for (int i = 0; i < skewPolygon.length-2; ++i) {
                        VecMath.vpv(skewPolygonNormal,
                                    skewPolygonNormal,
                                    VecMath.crossprod(new double[][] {VecMath.vmv(skewPolygon[i+1], skewPolygon[0]),
                                                                      VecMath.vmv(skewPolygon[i+2], skewPolygon[0])}));
                    }
                    VecMath.normalize(skewPolygonNormal, skewPolygonNormal);
                    double skewPolygonOffset = VecMath.dot(skewPolygonNormal, skewPolygon[0]);
                    if (skewPolygonOffset < 0.)
                    {
                        VecMath.vxs(skewPolygonNormal, skewPolygonNormal, -1.);
                        skewPolygonOffset *= -1.;
                    }

                    double[][] targetRegularPolygon = VecMath.bestFitRotatedAndTranslated(regularPolygons[gonality], skewPolygon);

                    double[] newFaceNormal = new double[3];
                    for (int i = 0; i < targetRegularPolygon.length-2; ++i)
                    {
                        VecMath.vpv(newFaceNormal,
                                    newFaceNormal,
                                    VecMath.crossprod(new double[][] {VecMath.vmv(targetRegularPolygon[i+1], targetRegularPolygon[0]),
                                                                      VecMath.vmv(targetRegularPolygon[i+2], targetRegularPolygon[0])}));
                    }
                    VecMath.normalize(newFaceNormal, newFaceNormal);
                    double newFaceOffset = VecMath.dot(newFaceNormal, targetRegularPolygon[0]);
                    if (newFaceOffset < 0)
                    {
                        // make it face outward
                        VecMath.vxs(newFaceNormal, newFaceNormal, -1.);
                        newFaceOffset *= -1.;
                    }

                    newFaceNormals[iFace] = newFaceNormal;
                    newFaceOffsets[iFace] = newFaceOffset;
                }
                //PRINTMAT(newFaceNormals);
                //PRINTVEC(newFaceOffsets);


                // XXX dup code. make a function out of this?  hmm.
                answer = makeHypercube(3); // unit in-radius
                for (int iFace = 0; iFace < normalAndOffsetPairs.length; ++iFace) {
                    double[] normal = newFaceNormals[iFace];
                    double offset = newFaceOffsets[iFace];
                    Hyperplane hyperplane = new Hyperplane(normal, offset);
                    slice(answer,
                          hyperplane,
                          /*aux=*/null,
                          returnBelow, /*returnBelowIndex=*/0,
                          /*returnBelowCapFacet=*/null, /*returnAboveCapFacetIndex=*/-1,
                          /*returnAboveCapFacet=*/null, /*returnAboveCapFacetIndex=*/-1,
                          /*returnAbove=*/null, /*returnAboveIndex=*/-1);
                    answer = returnBelow[0];
                }
                if (localVerboseLevel >= 1) System.out.println(""+"DONE ATTEMPTING TO REGULARIZE "+(notFruchtFlag?"NOT-FRUCHT":"FRUCHT")+"");
                if (localVerboseLevel >= 1) System.out.println(""+"================================");
            } // regularize

            return answer;
        } // makeFruchtPolyhedron

        private static double[][] get(double[][] A, int inds[])
        {
            double[][] answer = new double[inds.length][inds.length==0 ? 0 : A[0].length];
            for (int i = 0; i < inds.length; ++i) {
                answer[i] = A[inds[i]];
            }
            return answer;
        }


        public static SPolytope makeGrandAntiprism()
        {
            // R0 = circumradius, R1 = inradius
            double R0_decagon = 1./(2*Math.cos(Math.PI * (.5 - 1./10)));
            /* double R1_decagon  = .5*Math.tan(Math.PI * (.5 - 1./10)); */
            double R0_pentagon = 1./(2*Math.cos(Math.PI * (.5 - 1./5)));
            double R1_pentagon = .5*Math.tan(Math.PI * (.5 - 1./5));
            double antiprism_height = Math.sqrt(.75 - (R0_pentagon - R1_pentagon)
                                                     *(R0_pentagon - R1_pentagon));

            /*
             * Vertices...
             */
            double verts[][] = new double[100][4];
            int nverts = 0;

            /* the ring of antiprisms that's mostly in the xy plane */
            /* XXX changed it to xz plane for viewer program-- get this straight! */
            for (int i = 0; (i) < (10); ++i)
                for (int j = 0; (j) < (5); ++j)
                {
                    do { if (!(nverts < verts.length)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+3276 +"): " + "nverts < verts.length" + ""); } while (false);
                    verts[nverts][0] = Math.cos(2*Math.PI * i / 10) * R0_decagon
                                                * antiprism_height;
                    verts[nverts][2] = Math.sin(2*Math.PI * i / 10) * R0_decagon
                                                * antiprism_height;
                    verts[nverts][1] = Math.sin(2*Math.PI * (j+.5*(i+.5)) / 5) * R0_pentagon;
                    verts[nverts][3] = Math.cos(2*Math.PI * (j+.5*(i+.5)) / 5) * R0_pentagon;
                    nverts++;
                }
            /* the ring of antiprisms that's mostly in the zw plane */
            /* XXX changed it to yw plane for viewer program-- get this straight! */
            for (int i = 0; (i) < (10); ++i)
                for (int j = 0; (j) < (5); ++j)
                {
                    do { if (!(nverts < verts.length)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+3290 +"): " + "nverts < verts.length" + ""); } while (false);
                    verts[nverts][0] = Math.cos(2*Math.PI * (j+.5*(i+1)) / 5) * R0_pentagon;
                    verts[nverts][2] = Math.sin(2*Math.PI * (j+.5*(i+1)) / 5) * R0_pentagon;
                    verts[nverts][1] = Math.sin(2*Math.PI * (i+.5) / 10) * R0_decagon
                                                * antiprism_height;
                    verts[nverts][3] = Math.cos(2*Math.PI * (i+.5) / 10) * R0_decagon
                                                * antiprism_height;
                    nverts++;
                }
            do { if (!((nverts)==(verts.length))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+3299 +"): (" + "nverts" + ")" + "==" + "(" + "verts.length" + ") ("+(nverts)+" vs. "+(verts.length)+")"); } while (false);

            // Now if we had a convex hull function,
            // we'd just use it on the vertices and be done.
            // but we don't, so there's more work to do.
            // Screw it, for now, just hard-code the output from
            // "pcalc grand_antiprism".
            if (false)
                return makeConvexHull(verts);
            else
            {
                String s = ""
+"100 0-cells:\n"
+"  0:     0.85065080835203988 1.1135163644116066 0 0.80901699437494734\n"
+"  1:     1.3763819204711734 0.85065080835203988 0 0\n"
+"  2:     1.1135163644116064 0.68819096023558657 -0.80901699437494756 0.50000000000000011\n"
+"  3:     1.3763819204711734 0.2628655560595668 0 0.80901699437494734\n"
+"  4:     1.1135163644116064 0.6881909602355869 -0.80901699437494756 -0.49999999999999972\n"
+"  5:     1.3763819204711734 0.26286555605956685 0 -0.80901699437494734\n"
+"  6:     1.3763819204711734 -0.68819096023558679 0 0.49999999999999983\n"
+"  7:     1.3763819204711734 -0.68819096023558668 0 -0.50000000000000011\n"
+"  8:     1.1135163644116064 -0.26286555605956696 -0.80901699437494756 0.80901699437494734\n"
+"  9:     1.1135163644116064 -0.85065080835203988 -0.80901699437494756 0\n"
+" 10:     1.1135163644116064 -0.26286555605956646 -0.80901699437494756 -0.80901699437494745\n"
+" 11:     0.68819096023558657 0.42532540417601988 -0.50000000000000011 1.3090169943749472\n"
+" 12:     0.26286555605956663 1.1135163644116066 -0.80901699437494745 0.80901699437494734\n"
+" 13:     0.68819096023558679 0.42532540417601988 0.49999999999999994 1.3090169943749472\n"
+" 14:     0.26286555605956685 1.1135163644116066 0.80901699437494734 0.80901699437494734\n"
+" 15:     -0.26286555605956674 0.42532540417601988 0.80901699437494734 1.3090169943749472\n"
+" 16:     -0.68819096023558668 1.1135163644116066 0.5 0.80901699437494734\n"
+" 17:     -0.85065080835203988 0.42532540417601988 0 1.3090169943749472\n"
+" 18:     -0.68819096023558679 1.1135163644116066 -0.49999999999999989 0.80901699437494734\n"
+" 19:     -0.26286555605956691 0.42532540417601988 -0.80901699437494734 1.3090169943749472\n"
+" 20:     -1.1135163644116066 0.26286555605956657 -0.80901699437494712 0.80901699437494745\n"
+" 21:     -1.3763819204711734 0.68819096023558657 0 0.50000000000000011\n"
+" 22:     -1.3763819204711734 -0.26286555605956696 0 0.80901699437494734\n"
+" 23:     -1.3763819204711734 0.6881909602355869 0 -0.49999999999999972\n"
+" 24:     -1.1135163644116066 0.85065080835203988 -0.80901699437494712 0\n"
+" 25:     -1.1135163644116066 0.26286555605956707 -0.80901699437494712 -0.80901699437494723\n"
+" 26:     -1.1135163644116066 -0.68819096023558679 -0.80901699437494712 0.49999999999999983\n"
+" 27:     -1.1135163644116066 -0.68819096023558668 -0.80901699437494712 -0.50000000000000011\n"
+" 28:     -1.3763819204711734 -0.85065080835203988 0 0\n"
+" 29:     -1.3763819204711734 -0.26286555605956669 0 -0.80901699437494745\n"
+" 30:     -0.6881909602355869 -1.3763819204711734 -0.49999999999999972 0\n"
+" 31:     -0.85065080835203988 -1.1135163644116066 0 0.80901699437494701\n"
+" 32:     -0.6881909602355869 -0.42532540417602022 -0.49999999999999972 1.309016994374947\n"
+" 33:     -0.68819096023558657 -0.42532540417602022 0.50000000000000022 1.309016994374947\n"
+" 34:     -0.42532540417602011 -0.26286555605956696 -1.3090169943749472 0.80901699437494734\n"
+" 35:     -0.26286555605956713 -1.1135163644116066 -0.80901699437494723 0.80901699437494701\n"
+" 36:     -0.42532540417602011 -0.85065080835203988 -1.3090169943749472 0\n"
+" 37:     -0.42532540417602011 0.68819096023558657 -1.3090169943749472 0.50000000000000011\n"
+" 38:     -0.42532540417602011 0.6881909602355869 -1.3090169943749472 -0.49999999999999972\n"
+" 39:     -0.42532540417602011 -0.26286555605956646 -1.3090169943749472 -0.80901699437494745\n"
+" 40:     -0.68819096023558679 1.1135163644116066 -0.49999999999999989 -0.80901699437494723\n"
+" 41:     -0.85065080835203988 1.3763819204711734 0 0\n"
+" 42:     -1.1135163644116064 0.26286555605956657 0.80901699437494745 0.80901699437494745\n"
+" 43:     -1.1135163644116064 0.85065080835203988 0.80901699437494745 0\n"
+" 44:     -1.1135163644116064 0.26286555605956685 0.80901699437494745 -0.80901699437494734\n"
+" 45:     -1.1135163644116064 -0.68819096023558679 0.80901699437494745 0.49999999999999983\n"
+" 46:     -1.1135163644116064 -0.68819096023558668 0.80901699437494745 -0.50000000000000011\n"
+" 47:     -0.68819096023558657 -1.3763819204711734 0.50000000000000022 0\n"
+" 48:     -0.26286555605956652 -1.1135163644116066 0.80901699437494745 0.80901699437494701\n"
+" 49:     -0.42532540417601977 -0.26286555605956696 1.3090169943749472 0.80901699437494734\n"
+" 50:     -0.42532540417601977 0.68819096023558657 1.3090169943749472 0.50000000000000011\n"
+" 51:     -0.42532540417601977 0.68819096023558679 1.3090169943749472 -0.49999999999999989\n"
+" 52:     -0.42532540417601977 -0.26286555605956669 1.3090169943749472 -0.80901699437494745\n"
+" 53:     -0.42532540417601977 -0.85065080835203988 1.3090169943749472 0\n"
+" 54:     -0.68819096023558668 1.1135163644116066 0.5 -0.80901699437494723\n"
+" 55:     -0.26286555605956674 1.3763819204711734 0.80901699437494734 0\n"
+" 56:     0.42532540417601994 0.26286555605956657 1.3090169943749472 0.80901699437494745\n"
+" 57:     0.42532540417601994 0.85065080835203988 1.3090169943749472 0\n"
+" 58:     0.42532540417601994 0.26286555605956685 1.3090169943749472 -0.80901699437494734\n"
+" 59:     0.42532540417601994 -0.68819096023558679 1.3090169943749472 0.49999999999999983\n"
+" 60:     0.42532540417601994 -0.68819096023558668 1.3090169943749472 -0.50000000000000011\n"
+" 61:     0.26286555605956702 -0.42532540417602022 0.80901699437494734 1.309016994374947\n"
+" 62:     0.26286555605956641 -0.42532540417602022 -0.80901699437494745 1.309016994374947\n"
+" 63:     0.85065080835203988 -0.42532540417602022 0 1.309016994374947\n"
+" 64:     0.42532540417601966 0.26286555605956657 -1.3090169943749472 0.80901699437494745\n"
+" 65:     0.68819096023558657 -1.1135163644116066 -0.50000000000000011 0.80901699437494701\n"
+" 66:     0.6881909602355869 -1.1135163644116066 0.49999999999999978 0.80901699437494701\n"
+" 67:     -0.26286555605956691 -1.1135163644116064 -0.80901699437494734 -0.80901699437494745\n"
+" 68:     -0.68819096023558679 -0.42532540417601972 -0.49999999999999989 -1.3090169943749472\n"
+" 69:     -0.85065080835203988 0.42532540417602005 0 -1.3090169943749472\n"
+" 70:     0.26286555605956663 1.1135163644116066 -0.80901699437494745 -0.80901699437494723\n"
+" 71:     0.85065080835203988 1.1135163644116066 0 -0.80901699437494723\n"
+" 72:     0.68819096023558657 1.3763819204711734 -0.50000000000000011 0\n"
+" 73:     0.6881909602355869 1.3763819204711734 0.49999999999999978 0\n"
+" 74:     0.26286555605956702 1.1135163644116066 0.80901699437494734 -0.80901699437494723\n"
+" 75:     -0.26286555605956691 1.3763819204711734 -0.80901699437494734 0\n"
+" 76:     0.42532540417601966 0.85065080835203988 -1.3090169943749472 0\n"
+" 77:     0.42532540417601966 0.26286555605956707 -1.3090169943749472 -0.80901699437494723\n"
+" 78:     0.42532540417601966 -0.68819096023558679 -1.3090169943749472 0.49999999999999983\n"
+" 79:     0.42532540417601966 -0.68819096023558657 -1.3090169943749472 -0.50000000000000022\n"
+" 80:     0.26286555605956663 -1.3763819204711734 -0.80901699437494745 0\n"
+" 81:     0.85065080835203988 -1.3763819204711734 0 0\n"
+" 82:     0.68819096023558657 -1.1135163644116064 -0.50000000000000011 -0.80901699437494745\n"
+" 83:     0.6881909602355869 -1.1135163644116064 0.49999999999999978 -0.80901699437494745\n"
+" 84:     0.26286555605956702 -1.3763819204711734 0.80901699437494734 0\n"
+" 85:     -0.26286555605956652 -1.1135163644116064 0.80901699437494745 -0.80901699437494745\n"
+" 86:     -0.85065080835203988 -1.1135163644116064 0 -0.80901699437494745\n"
+" 87:     -0.68819096023558657 -0.42532540417601972 0.50000000000000022 -1.3090169943749472\n"
+" 88:     0.26286555605956663 -0.42532540417601972 -0.80901699437494745 -1.3090169943749472\n"
+" 89:     0.85065080835203988 -0.42532540417601972 0 -1.3090169943749472\n"
+" 90:     0.68819096023558657 0.42532540417602005 -0.50000000000000011 -1.3090169943749472\n"
+" 91:     0.6881909602355869 0.42532540417602005 0.49999999999999978 -1.3090169943749472\n"
+" 92:     0.26286555605956702 -0.42532540417601972 0.80901699437494734 -1.3090169943749472\n"
+" 93:     -0.26286555605956652 0.42532540417602005 0.80901699437494745 -1.3090169943749472\n"
+" 94:     -0.26286555605956691 0.42532540417602005 -0.80901699437494734 -1.3090169943749472\n"
+" 95:     1.1135163644116066 0.68819096023558679 0.80901699437494723 -0.49999999999999989\n"
+" 96:     1.1135163644116066 0.68819096023558668 0.80901699437494723 0.5\n"
+" 97:     1.1135163644116066 -0.26286555605956696 0.80901699437494723 0.80901699437494734\n"
+" 98:     1.1135163644116066 -0.26286555605956669 0.80901699437494723 -0.80901699437494745\n"
+" 99:     1.1135163644116066 -0.85065080835203988 0.80901699437494723 0\n"
+"500 1-cells:\n"
+"   0:    -0  +1 \n"
+"   1:    -2  +1 \n"
+"   2:    -0  +2 \n"
+"   3:    -3  +1 \n"
+"   4:    -2  +3 \n"
+"   5:    -0  +3 \n"
+"   6:    -4  +1 \n"
+"   7:    -4  +2 \n"
+"   8:    -5  +1 \n"
+"   9:    -6  +3 \n"
+"  10:    -7  +6 \n"
+"  11:    -7  +5 \n"
+"  12:    -8  +3 \n"
+"  13:    -8  +6 \n"
+"  14:    -9  +6 \n"
+"  15:    -9  +8 \n"
+"  16:    -8  +2 \n"
+"  17:    -10 +4 \n"
+"  18:    -9  +10\n"
+"  19:    -10 +5 \n"
+"  20:    -4  +5 \n"
+"  21:    -10 +7 \n"
+"  22:    -9  +7 \n"
+"  23:    -11 +3 \n"
+"  24:    -11 +0 \n"
+"  25:    -11 +2 \n"
+"  26:    -12 +2 \n"
+"  27:    -12 +11\n"
+"  28:    -12 +0 \n"
+"  29:    -13 +0 \n"
+"  30:    -11 +13\n"
+"  31:    -14 +0 \n"
+"  32:    -14 +13\n"
+"  33:    -15 +13\n"
+"  34:    -15 +14\n"
+"  35:    -16 +14\n"
+"  36:    -16 +15\n"
+"  37:    -17 +15\n"
+"  38:    -17 +16\n"
+"  39:    -18 +16\n"
+"  40:    -17 +18\n"
+"  41:    -18 +12\n"
+"  42:    -19 +12\n"
+"  43:    -18 +19\n"
+"  44:    -19 +11\n"
+"  45:    -17 +19\n"
+"  46:    -20 +19\n"
+"  47:    -20 +17\n"
+"  48:    -20 +18\n"
+"  49:    -21 +18\n"
+"  50:    -21 +20\n"
+"  51:    -21 +17\n"
+"  52:    -22 +17\n"
+"  53:    -22 +21\n"
+"  54:    -22 +20\n"
+"  55:    -23 +24\n"
+"  56:    -21 +24\n"
+"  57:    -23 +21\n"
+"  58:    -20 +24\n"
+"  59:    -25 +24\n"
+"  60:    -26 +20\n"
+"  61:    -27 +26\n"
+"  62:    -27 +25\n"
+"  63:    -22 +26\n"
+"  64:    -28 +26\n"
+"  65:    -28 +22\n"
+"  66:    -28 +29\n"
+"  67:    -29 +23\n"
+"  68:    -28 +27\n"
+"  69:    -29 +27\n"
+"  70:    -29 +25\n"
+"  71:    -23 +25\n"
+"  72:    -28 +30\n"
+"  73:    -27 +30\n"
+"  74:    -26 +30\n"
+"  75:    -31 +30\n"
+"  76:    -26 +31\n"
+"  77:    -28 +31\n"
+"  78:    -22 +31\n"
+"  79:    -22 +32\n"
+"  80:    -26 +32\n"
+"  81:    -31 +32\n"
+"  82:    -22 +33\n"
+"  83:    -31 +33\n"
+"  84:    -32 +33\n"
+"  85:    -17 +33\n"
+"  86:    -17 +32\n"
+"  87:    -20 +32\n"
+"  88:    -32 +19\n"
+"  89:    -34 +19\n"
+"  90:    -32 +34\n"
+"  91:    -20 +34\n"
+"  92:    -26 +34\n"
+"  93:    -26 +35\n"
+"  94:    -32 +35\n"
+"  95:    -34 +35\n"
+"  96:    -36 +35\n"
+"  97:    -26 +36\n"
+"  98:    -36 +34\n"
+"  99:    -20 +37\n"
+" 100:    -24 +37\n"
+" 101:    -38 +37\n"
+" 102:    -24 +38\n"
+" 103:    -34 +37\n"
+" 104:    -39 +38\n"
+" 105:    -36 +39\n"
+" 106:    -25 +38\n"
+" 107:    -25 +39\n"
+" 108:    -27 +39\n"
+" 109:    -27 +36\n"
+" 110:    -40 +38\n"
+" 111:    -24 +40\n"
+" 112:    -25 +40\n"
+" 113:    -23 +40\n"
+" 114:    -41 +40\n"
+" 115:    -24 +41\n"
+" 116:    -23 +41\n"
+" 117:    -21 +41\n"
+" 118:    -24 +18\n"
+" 119:    -41 +18\n"
+" 120:    -21 +16\n"
+" 121:    -41 +16\n"
+" 122:    -42 +16\n"
+" 123:    -21 +42\n"
+" 124:    -42 +17\n"
+" 125:    -22 +42\n"
+" 126:    -23 +43\n"
+" 127:    -21 +43\n"
+" 128:    -42 +43\n"
+" 129:    -44 +43\n"
+" 130:    -45 +42\n"
+" 131:    -46 +45\n"
+" 132:    -46 +44\n"
+" 133:    -22 +45\n"
+" 134:    -28 +45\n"
+" 135:    -28 +46\n"
+" 136:    -29 +46\n"
+" 137:    -29 +44\n"
+" 138:    -23 +44\n"
+" 139:    -28 +47\n"
+" 140:    -46 +47\n"
+" 141:    -45 +47\n"
+" 142:    -31 +47\n"
+" 143:    -45 +31\n"
+" 144:    -45 +33\n"
+" 145:    -45 +48\n"
+" 146:    -31 +48\n"
+" 147:    -33 +48\n"
+" 148:    -49 +48\n"
+" 149:    -33 +49\n"
+" 150:    -45 +49\n"
+" 151:    -42 +49\n"
+" 152:    -42 +33\n"
+" 153:    -42 +15\n"
+" 154:    -33 +15\n"
+" 155:    -49 +15\n"
+" 156:    -50 +15\n"
+" 157:    -49 +50\n"
+" 158:    -42 +50\n"
+" 159:    -43 +50\n"
+" 160:    -51 +50\n"
+" 161:    -43 +51\n"
+" 162:    -52 +51\n"
+" 163:    -53 +52\n"
+" 164:    -53 +49\n"
+" 165:    -44 +51\n"
+" 166:    -44 +52\n"
+" 167:    -46 +52\n"
+" 168:    -45 +53\n"
+" 169:    -46 +53\n"
+" 170:    -54 +51\n"
+" 171:    -43 +54\n"
+" 172:    -44 +54\n"
+" 173:    -23 +54\n"
+" 174:    -41 +54\n"
+" 175:    -43 +41\n"
+" 176:    -43 +16\n"
+" 177:    -43 +55\n"
+" 178:    -41 +55\n"
+" 179:    -16 +55\n"
+" 180:    -50 +55\n"
+" 181:    -16 +50\n"
+" 182:    -50 +14\n"
+" 183:    -50 +56\n"
+" 184:    -15 +56\n"
+" 185:    -14 +56\n"
+" 186:    -50 +57\n"
+" 187:    -14 +57\n"
+" 188:    -56 +57\n"
+" 189:    -51 +57\n"
+" 190:    -58 +57\n"
+" 191:    -59 +56\n"
+" 192:    -60 +59\n"
+" 193:    -60 +58\n"
+" 194:    -49 +56\n"
+" 195:    -49 +59\n"
+" 196:    -53 +59\n"
+" 197:    -52 +58\n"
+" 198:    -51 +58\n"
+" 199:    -52 +60\n"
+" 200:    -53 +60\n"
+" 201:    -61 +56\n"
+" 202:    -15 +61\n"
+" 203:    -49 +61\n"
+" 204:    -33 +61\n"
+" 205:    -62 +63\n"
+" 206:    -11 +63\n"
+" 207:    -62 +11\n"
+" 208:    -13 +63\n"
+" 209:    -61 +63\n"
+" 210:    -61 +13\n"
+" 211:    -32 +62\n"
+" 212:    -19 +62\n"
+" 213:    -64 +11\n"
+" 214:    -62 +64\n"
+" 215:    -19 +64\n"
+" 216:    -34 +64\n"
+" 217:    -34 +62\n"
+" 218:    -35 +62\n"
+" 219:    -65 +63\n"
+" 220:    -62 +65\n"
+" 221:    -66 +63\n"
+" 222:    -65 +66\n"
+" 223:    -61 +66\n"
+" 224:    -48 +66\n"
+" 225:    -48 +61\n"
+" 226:    -35 +65\n"
+" 227:    -31 +35\n"
+" 228:    -30 +35\n"
+" 229:    -30 +36\n"
+" 230:    -27 +67\n"
+" 231:    -30 +67\n"
+" 232:    -36 +67\n"
+" 233:    -39 +67\n"
+" 234:    -68 +67\n"
+" 235:    -27 +68\n"
+" 236:    -68 +39\n"
+" 237:    -25 +68\n"
+" 238:    -29 +68\n"
+" 239:    -69 +68\n"
+" 240:    -25 +69\n"
+" 241:    -29 +69\n"
+" 242:    -23 +69\n"
+" 243:    -69 +40\n"
+" 244:    -69 +54\n"
+" 245:    -40 +54\n"
+" 246:    -70 +71\n"
+" 247:    -72 +71\n"
+" 248:    -70 +72\n"
+" 249:    -73 +71\n"
+" 250:    -72 +73\n"
+" 251:    -74 +71\n"
+" 252:    -74 +73\n"
+" 253:    -55 +73\n"
+" 254:    -55 +74\n"
+" 255:    -54 +74\n"
+" 256:    -54 +55\n"
+" 257:    -40 +70\n"
+" 258:    -75 +70\n"
+" 259:    -40 +75\n"
+" 260:    -75 +72\n"
+" 261:    -41 +75\n"
+" 262:    -24 +75\n"
+" 263:    -38 +75\n"
+" 264:    -37 +75\n"
+" 265:    -18 +75\n"
+" 266:    -18 +37\n"
+" 267:    -37 +19\n"
+" 268:    -37 +64\n"
+" 269:    -12 +64\n"
+" 270:    -37 +12\n"
+" 271:    -75 +12\n"
+" 272:    -72 +0 \n"
+" 273:    -12 +72\n"
+" 274:    -73 +0 \n"
+" 275:    -14 +73\n"
+" 276:    -55 +14\n"
+" 277:    -76 +72\n"
+" 278:    -12 +76\n"
+" 279:    -75 +76\n"
+" 280:    -37 +76\n"
+" 281:    -64 +76\n"
+" 282:    -38 +76\n"
+" 283:    -77 +76\n"
+" 284:    -78 +64\n"
+" 285:    -79 +78\n"
+" 286:    -79 +77\n"
+" 287:    -34 +78\n"
+" 288:    -36 +78\n"
+" 289:    -39 +77\n"
+" 290:    -38 +77\n"
+" 291:    -39 +79\n"
+" 292:    -36 +79\n"
+" 293:    -80 +78\n"
+" 294:    -36 +80\n"
+" 295:    -80 +79\n"
+" 296:    -67 +79\n"
+" 297:    -67 +80\n"
+" 298:    -30 +80\n"
+" 299:    -80 +81\n"
+" 300:    -82 +81\n"
+" 301:    -80 +82\n"
+" 302:    -83 +81\n"
+" 303:    -82 +83\n"
+" 304:    -84 +81\n"
+" 305:    -84 +83\n"
+" 306:    -85 +83\n"
+" 307:    -85 +84\n"
+" 308:    -47 +84\n"
+" 309:    -47 +85\n"
+" 310:    -86 +85\n"
+" 311:    -86 +47\n"
+" 312:    -30 +47\n"
+" 313:    -86 +30\n"
+" 314:    -67 +82\n"
+" 315:    -86 +67\n"
+" 316:    -27 +86\n"
+" 317:    -28 +86\n"
+" 318:    -29 +86\n"
+" 319:    -86 +68\n"
+" 320:    -29 +87\n"
+" 321:    -86 +87\n"
+" 322:    -68 +87\n"
+" 323:    -69 +87\n"
+" 324:    -88 +89\n"
+" 325:    -90 +89\n"
+" 326:    -88 +90\n"
+" 327:    -91 +89\n"
+" 328:    -90 +91\n"
+" 329:    -92 +89\n"
+" 330:    -92 +91\n"
+" 331:    -93 +91\n"
+" 332:    -93 +92\n"
+" 333:    -87 +92\n"
+" 334:    -87 +93\n"
+" 335:    -69 +93\n"
+" 336:    -68 +88\n"
+" 337:    -94 +88\n"
+" 338:    -68 +94\n"
+" 339:    -94 +90\n"
+" 340:    -69 +94\n"
+" 341:    -25 +94\n"
+" 342:    -39 +94\n"
+" 343:    -38 +94\n"
+" 344:    -40 +94\n"
+" 345:    -38 +70\n"
+" 346:    -94 +70\n"
+" 347:    -90 +71\n"
+" 348:    -70 +90\n"
+" 349:    -91 +71\n"
+" 350:    -74 +91\n"
+" 351:    -93 +74\n"
+" 352:    -54 +93\n"
+" 353:    -77 +90\n"
+" 354:    -70 +77\n"
+" 355:    -94 +77\n"
+" 356:    -70 +76\n"
+" 357:    -70 +4 \n"
+" 358:    -77 +4 \n"
+" 359:    -76 +4 \n"
+" 360:    -72 +4 \n"
+" 361:    -71 +4 \n"
+" 362:    -90 +4 \n"
+" 363:    -90 +5 \n"
+" 364:    -71 +5 \n"
+" 365:    -90 +10\n"
+" 366:    -77 +10\n"
+" 367:    -88 +10\n"
+" 368:    -88 +77\n"
+" 369:    -39 +88\n"
+" 370:    -67 +88\n"
+" 371:    -82 +89\n"
+" 372:    -88 +82\n"
+" 373:    -83 +89\n"
+" 374:    -92 +83\n"
+" 375:    -85 +92\n"
+" 376:    -87 +85\n"
+" 377:    -79 +82\n"
+" 378:    -88 +79\n"
+" 379:    -79 +10\n"
+" 380:    -64 +2 \n"
+" 381:    -76 +2 \n"
+" 382:    -78 +8 \n"
+" 383:    -64 +8 \n"
+" 384:    -78 +9 \n"
+" 385:    -79 +9 \n"
+" 386:    -82 +10\n"
+" 387:    -82 +9 \n"
+" 388:    -80 +9 \n"
+" 389:    -81 +9 \n"
+" 390:    -65 +9 \n"
+" 391:    -80 +65\n"
+" 392:    -65 +81\n"
+" 393:    -66 +81\n"
+" 394:    -84 +66\n"
+" 395:    -48 +84\n"
+" 396:    -47 +48\n"
+" 397:    -35 +80\n"
+" 398:    -78 +65\n"
+" 399:    -35 +78\n"
+" 400:    -62 +78\n"
+" 401:    -62 +8 \n"
+" 402:    -11 +8 \n"
+" 403:    -63 +8 \n"
+" 404:    -65 +8 \n"
+" 405:    -65 +6 \n"
+" 406:    -63 +6 \n"
+" 407:    -72 +2 \n"
+" 408:    -72 +1 \n"
+" 409:    -71 +1 \n"
+" 410:    -95 +1 \n"
+" 411:    -71 +95\n"
+" 412:    -95 +5 \n"
+" 413:    -91 +5 \n"
+" 414:    -91 +95\n"
+" 415:    -74 +95\n"
+" 416:    -73 +95\n"
+" 417:    -73 +1 \n"
+" 418:    -96 +1 \n"
+" 419:    -95 +96\n"
+" 420:    -73 +96\n"
+" 421:    -57 +96\n"
+" 422:    -57 +73\n"
+" 423:    -57 +95\n"
+" 424:    -74 +57\n"
+" 425:    -55 +57\n"
+" 426:    -51 +55\n"
+" 427:    -51 +74\n"
+" 428:    -14 +96\n"
+" 429:    -0  +96\n"
+" 430:    -13 +96\n"
+" 431:    -13 +3 \n"
+" 432:    -96 +3 \n"
+" 433:    -97 +3 \n"
+" 434:    -13 +97\n"
+" 435:    -97 +96\n"
+" 436:    -56 +96\n"
+" 437:    -56 +13\n"
+" 438:    -56 +97\n"
+" 439:    -61 +97\n"
+" 440:    -98 +95\n"
+" 441:    -99 +98\n"
+" 442:    -99 +97\n"
+" 443:    -58 +95\n"
+" 444:    -58 +98\n"
+" 445:    -60 +98\n"
+" 446:    -59 +97\n"
+" 447:    -59 +99\n"
+" 448:    -60 +99\n"
+" 449:    -74 +58\n"
+" 450:    -93 +58\n"
+" 451:    -51 +93\n"
+" 452:    -44 +93\n"
+" 453:    -52 +93\n"
+" 454:    -92 +58\n"
+" 455:    -52 +92\n"
+" 456:    -87 +52\n"
+" 457:    -44 +87\n"
+" 458:    -46 +87\n"
+" 459:    -44 +69\n"
+" 460:    -46 +86\n"
+" 461:    -46 +85\n"
+" 462:    -53 +85\n"
+" 463:    -47 +53\n"
+" 464:    -53 +48\n"
+" 465:    -48 +59\n"
+" 466:    -84 +59\n"
+" 467:    -53 +84\n"
+" 468:    -85 +60\n"
+" 469:    -84 +60\n"
+" 470:    -84 +99\n"
+" 471:    -66 +99\n"
+" 472:    -59 +66\n"
+" 473:    -61 +59\n"
+" 474:    -66 +97\n"
+" 475:    -63 +97\n"
+" 476:    -63 +3 \n"
+" 477:    -97 +6 \n"
+" 478:    -66 +6 \n"
+" 479:    -99 +6 \n"
+" 480:    -98 +5 \n"
+" 481:    -98 +7 \n"
+" 482:    -99 +7 \n"
+" 483:    -81 +6 \n"
+" 484:    -81 +99\n"
+" 485:    -81 +7 \n"
+" 486:    -83 +7 \n"
+" 487:    -83 +99\n"
+" 488:    -82 +7 \n"
+" 489:    -89 +7 \n"
+" 490:    -89 +10\n"
+" 491:    -89 +5 \n"
+" 492:    -89 +98\n"
+" 493:    -83 +98\n"
+" 494:    -92 +98\n"
+" 495:    -91 +98\n"
+" 496:    -58 +91\n"
+" 497:    -92 +60\n"
+" 498:    -52 +85\n"
+" 499:    -60 +83\n"
+"720 2-cells:\n"
+"   0:    +0   -1   -2  \n"
+"   1:    +1   -3   -4  \n"
+"   2:    +0   -3   -5  \n"
+"   3:    +5   -4   -2  \n"
+"   4:    +6   -1   -7  \n"
+"   5:    +8   -3   -9   -10  +11 \n"
+"   6:    +12  -9   -13 \n"
+"   7:    +14  -13  -15 \n"
+"   8:    +16  -7   -17  -18  +15 \n"
+"   9:    +19  -20  -17 \n"
+"  10:    +6   -8   -20 \n"
+"  11:    +19  -11  -21 \n"
+"  12:    +22  -21  -18 \n"
+"  13:    +14  -10  -22 \n"
+"  14:    +12  -4   -16 \n"
+"  15:    +23  -5   -24 \n"
+"  16:    +23  -4   -25 \n"
+"  17:    +25  -2   -24 \n"
+"  18:    +26  -25  -27 \n"
+"  19:    +26  -2   -28 \n"
+"  20:    +28  -24  -27 \n"
+"  21:    +24  -29  -30 \n"
+"  22:    +31  -29  -32 \n"
+"  23:    +33  -32  -34 \n"
+"  24:    +35  -34  -36 \n"
+"  25:    +37  -36  -38 \n"
+"  26:    +38  -39  -40 \n"
+"  27:    +28  -31  -35  -39  +41 \n"
+"  28:    +41  -42  -43 \n"
+"  29:    +44  -27  -42 \n"
+"  30:    +33  -30  -44  -45  +37 \n"
+"  31:    +45  -43  -40 \n"
+"  32:    +46  -45  -47 \n"
+"  33:    +46  -43  -48 \n"
+"  34:    +48  -40  -47 \n"
+"  35:    +49  -48  -50 \n"
+"  36:    +49  -40  -51 \n"
+"  37:    +51  -47  -50 \n"
+"  38:    +52  -51  -53 \n"
+"  39:    +52  -47  -54 \n"
+"  40:    +54  -50  -53 \n"
+"  41:    +55  -56  -57 \n"
+"  42:    +56  -58  -50 \n"
+"  43:    +59  -58  -60  -61  +62 \n"
+"  44:    +54  -60  -63 \n"
+"  45:    +64  -63  -65 \n"
+"  46:    +57  -53  -65  +66  +67 \n"
+"  47:    +68  -69  -66 \n"
+"  48:    +70  -62  -69 \n"
+"  49:    +70  -71  -67 \n"
+"  50:    +55  -59  -71 \n"
+"  51:    +64  -61  -68 \n"
+"  52:    +72  -73  -68 \n"
+"  53:    +73  -74  -61 \n"
+"  54:    +72  -74  -64 \n"
+"  55:    +74  -75  -76 \n"
+"  56:    +72  -75  -77 \n"
+"  57:    +77  -76  -64 \n"
+"  58:    +77  -78  -65 \n"
+"  59:    +78  -76  -63 \n"
+"  60:    +79  -80  -63 \n"
+"  61:    +80  -81  -76 \n"
+"  62:    +79  -81  -78 \n"
+"  63:    +82  -83  -78 \n"
+"  64:    +83  -84  -81 \n"
+"  65:    +82  -84  -79 \n"
+"  66:    +82  -85  -52 \n"
+"  67:    +85  -84  -86 \n"
+"  68:    +79  -86  -52 \n"
+"  69:    +79  -87  -54 \n"
+"  70:    +87  -86  -47 \n"
+"  71:    +45  -88  -86 \n"
+"  72:    +46  -88  -87 \n"
+"  73:    +88  -89  -90 \n"
+"  74:    +46  -89  -91 \n"
+"  75:    +91  -90  -87 \n"
+"  76:    +92  -91  -60 \n"
+"  77:    +92  -90  -80 \n"
+"  78:    +80  -87  -60 \n"
+"  79:    +93  -94  -80 \n"
+"  80:    +94  -95  -90 \n"
+"  81:    +93  -95  -92 \n"
+"  82:    +93  -96  -97 \n"
+"  83:    +96  -95  -98 \n"
+"  84:    +92  -98  -97 \n"
+"  85:    +99  -100 -58 \n"
+"  86:    +100 -101 -102\n"
+"  87:    +103 -101 -104 -105 +98 \n"
+"  88:    +106 -104 -107\n"
+"  89:    +108 -107 -62 \n"
+"  90:    +99  -103 -91 \n"
+"  91:    +109 -97  -61 \n"
+"  92:    +108 -105 -109\n"
+"  93:    +106 -102 -59 \n"
+"  94:    +102 -110 -111\n"
+"  95:    +106 -110 -112\n"
+"  96:    +112 -111 -59 \n"
+"  97:    +113 -112 -71 \n"
+"  98:    +113 -111 -55 \n"
+"  99:    +111 -114 -115\n"
+" 100:    +113 -114 -116\n"
+" 101:    +116 -115 -55 \n"
+" 102:    +116 -117 -57 \n"
+" 103:    +117 -115 -56 \n"
+" 104:    +49  -118 -56 \n"
+" 105:    +118 -119 -115\n"
+" 106:    +49  -119 -117\n"
+" 107:    +120 -121 -117\n"
+" 108:    +121 -39  -119\n"
+" 109:    +120 -39  -49 \n"
+" 110:    +120 -38  -51 \n"
+" 111:    +120 -122 -123\n"
+" 112:    +122 -38  -124\n"
+" 113:    +51  -124 -123\n"
+" 114:    +52  -124 -125\n"
+" 115:    +125 -123 -53 \n"
+" 116:    +126 -127 -57 \n"
+" 117:    +127 -128 -123\n"
+" 118:    +129 -128 -130 -131 +132\n"
+" 119:    +125 -130 -133\n"
+" 120:    +134 -133 -65 \n"
+" 121:    +135 -136 -66 \n"
+" 122:    +137 -132 -136\n"
+" 123:    +137 -138 -67 \n"
+" 124:    +126 -129 -138\n"
+" 125:    +134 -131 -135\n"
+" 126:    +139 -140 -135\n"
+" 127:    +140 -141 -131\n"
+" 128:    +139 -141 -134\n"
+" 129:    +141 -142 -143\n"
+" 130:    +139 -142 -77 \n"
+" 131:    +77  -143 -134\n"
+" 132:    +78  -143 -133\n"
+" 133:    +82  -144 -133\n"
+" 134:    +144 -83  -143\n"
+" 135:    +145 -146 -143\n"
+" 136:    +146 -147 -83 \n"
+" 137:    +145 -147 -144\n"
+" 138:    +147 -148 -149\n"
+" 139:    +145 -148 -150\n"
+" 140:    +150 -149 -144\n"
+" 141:    +150 -151 -130\n"
+" 142:    +151 -149 -152\n"
+" 143:    +144 -152 -130\n"
+" 144:    +82  -152 -125\n"
+" 145:    +152 -85  -124\n"
+" 146:    +153 -37  -124\n"
+" 147:    +37  -154 -85 \n"
+" 148:    +153 -154 -152\n"
+" 149:    +154 -155 -149\n"
+" 150:    +153 -155 -151\n"
+" 151:    +155 -156 -157\n"
+" 152:    +153 -156 -158\n"
+" 153:    +158 -157 -151\n"
+" 154:    +158 -159 -128\n"
+" 155:    +159 -160 -161\n"
+" 156:    +157 -160 -162 -163 +164\n"
+" 157:    +165 -162 -166\n"
+" 158:    +167 -166 -132\n"
+" 159:    +150 -164 -168\n"
+" 160:    +169 -168 -131\n"
+" 161:    +167 -163 -169\n"
+" 162:    +165 -161 -129\n"
+" 163:    +161 -170 -171\n"
+" 164:    +165 -170 -172\n"
+" 165:    +172 -171 -129\n"
+" 166:    +173 -172 -138\n"
+" 167:    +173 -171 -126\n"
+" 168:    +171 -174 -175\n"
+" 169:    +173 -174 -116\n"
+" 170:    +116 -175 -126\n"
+" 171:    +117 -175 -127\n"
+" 172:    +120 -176 -127\n"
+" 173:    +176 -121 -175\n"
+" 174:    +177 -178 -175\n"
+" 175:    +178 -179 -121\n"
+" 176:    +177 -179 -176\n"
+" 177:    +179 -180 -181\n"
+" 178:    +177 -180 -159\n"
+" 179:    +159 -181 -176\n"
+" 180:    +158 -181 -122\n"
+" 181:    +122 -176 -128\n"
+" 182:    +153 -36  -122\n"
+" 183:    +36  -156 -181\n"
+" 184:    +35  -182 -181\n"
+" 185:    +182 -34  -156\n"
+" 186:    +183 -184 -156\n"
+" 187:    +184 -185 -34 \n"
+" 188:    +183 -185 -182\n"
+" 189:    +186 -187 -182\n"
+" 190:    +187 -188 -185\n"
+" 191:    +186 -188 -183\n"
+" 192:    +189 -186 -160\n"
+" 193:    +190 -188 -191 -192 +193\n"
+" 194:    +194 -191 -195\n"
+" 195:    +196 -195 -164\n"
+" 196:    +197 -198 -162\n"
+" 197:    +189 -190 -198\n"
+" 198:    +197 -193 -199\n"
+" 199:    +200 -199 -163\n"
+" 200:    +196 -192 -200\n"
+" 201:    +194 -183 -157\n"
+" 202:    +194 -184 -155\n"
+" 203:    +184 -201 -202\n"
+" 204:    +194 -201 -203\n"
+" 205:    +203 -202 -155\n"
+" 206:    +204 -203 -149\n"
+" 207:    +204 -202 -154\n"
+" 208:    +205 -206 -207\n"
+" 209:    +206 -208 -30 \n"
+" 210:    +209 -208 -210\n"
+" 211:    +33  -210 -202\n"
+" 212:    +205 -209 -204 -84  +211\n"
+" 213:    +211 -212 -88 \n"
+" 214:    +44  -207 -212\n"
+" 215:    +207 -213 -214\n"
+" 216:    +44  -213 -215\n"
+" 217:    +215 -214 -212\n"
+" 218:    +216 -215 -89 \n"
+" 219:    +216 -214 -217\n"
+" 220:    +217 -212 -89 \n"
+" 221:    +211 -217 -90 \n"
+" 222:    +217 -218 -95 \n"
+" 223:    +211 -218 -94 \n"
+" 224:    +205 -219 -220\n"
+" 225:    +219 -221 -222\n"
+" 226:    +209 -221 -223\n"
+" 227:    +224 -223 -225\n"
+" 228:    +204 -225 -147\n"
+" 229:    +226 -220 -218\n"
+" 230:    +224 -222 -226 -227 +146\n"
+" 231:    +227 -94  -81 \n"
+" 232:    +93  -227 -76 \n"
+" 233:    +227 -228 -75 \n"
+" 234:    +93  -228 -74 \n"
+" 235:    +228 -96  -229\n"
+" 236:    +97  -229 -74 \n"
+" 237:    +109 -229 -73 \n"
+" 238:    +230 -231 -73 \n"
+" 239:    +231 -232 -229\n"
+" 240:    +230 -232 -109\n"
+" 241:    +232 -233 -105\n"
+" 242:    +230 -233 -108\n"
+" 243:    +230 -234 -235\n"
+" 244:    +234 -233 -236\n"
+" 245:    +108 -236 -235\n"
+" 246:    +107 -236 -237\n"
+" 247:    +235 -237 -62 \n"
+" 248:    +238 -235 -69 \n"
+" 249:    +238 -237 -70 \n"
+" 250:    +237 -239 -240\n"
+" 251:    +238 -239 -241\n"
+" 252:    +241 -240 -70 \n"
+" 253:    +241 -242 -67 \n"
+" 254:    +242 -240 -71 \n"
+" 255:    +112 -243 -240\n"
+" 256:    +113 -243 -242\n"
+" 257:    +173 -244 -242\n"
+" 258:    +244 -245 -243\n"
+" 259:    +173 -245 -113\n"
+" 260:    +174 -245 -114\n"
+" 261:    +246 -247 -248\n"
+" 262:    +247 -249 -250\n"
+" 263:    +251 -249 -252\n"
+" 264:    +253 -252 -254\n"
+" 265:    +255 -254 -256\n"
+" 266:    +178 -256 -174\n"
+" 267:    +246 -251 -255 -245 +257\n"
+" 268:    +257 -258 -259\n"
+" 269:    +260 -248 -258\n"
+" 270:    +253 -250 -260 -261 +178\n"
+" 271:    +261 -259 -114\n"
+" 272:    +262 -261 -115\n"
+" 273:    +262 -259 -111\n"
+" 274:    +259 -263 -110\n"
+" 275:    +262 -263 -102\n"
+" 276:    +263 -264 -101\n"
+" 277:    +262 -264 -100\n"
+" 278:    +262 -265 -118\n"
+" 279:    +265 -264 -266\n"
+" 280:    +100 -266 -118\n"
+" 281:    +99  -266 -48 \n"
+" 282:    +48  -118 -58 \n"
+" 283:    +43  -267 -266\n"
+" 284:    +46  -267 -99 \n"
+" 285:    +89  -267 -103\n"
+" 286:    +216 -268 -103\n"
+" 287:    +268 -215 -267\n"
+" 288:    +215 -269 -42 \n"
+" 289:    +268 -269 -270\n"
+" 290:    +270 -42  -267\n"
+" 291:    +41  -270 -266\n"
+" 292:    +270 -271 -264\n"
+" 293:    +41  -271 -265\n"
+" 294:    +28  -272 -273\n"
+" 295:    +272 -274 -250\n"
+" 296:    +31  -274 -275\n"
+" 297:    +253 -275 -276\n"
+" 298:    +35  -276 -179\n"
+" 299:    +260 -273 -271\n"
+" 300:    +261 -265 -119\n"
+" 301:    +273 -277 -278\n"
+" 302:    +260 -277 -279\n"
+" 303:    +279 -278 -271\n"
+" 304:    +280 -279 -264\n"
+" 305:    +280 -278 -270\n"
+" 306:    +278 -281 -269\n"
+" 307:    +280 -281 -268\n"
+" 308:    +282 -280 -101\n"
+" 309:    +283 -281 -284 -285 +286\n"
+" 310:    +216 -284 -287\n"
+" 311:    +288 -287 -98 \n"
+" 312:    +289 -290 -104\n"
+" 313:    +282 -283 -290\n"
+" 314:    +289 -286 -291\n"
+" 315:    +292 -291 -105\n"
+" 316:    +288 -285 -292\n"
+" 317:    +288 -293 -294\n"
+" 318:    +293 -285 -295\n"
+" 319:    +292 -295 -294\n"
+" 320:    +292 -296 -232\n"
+" 321:    +296 -295 -297\n"
+" 322:    +294 -297 -232\n"
+" 323:    +298 -294 -229\n"
+" 324:    +298 -297 -231\n"
+" 325:    +299 -300 -301\n"
+" 326:    +300 -302 -303\n"
+" 327:    +304 -302 -305\n"
+" 328:    +306 -305 -307\n"
+" 329:    +308 -307 -309\n"
+" 330:    +310 -309 -311\n"
+" 331:    +311 -312 -313\n"
+" 332:    +299 -304 -308 -312 +298\n"
+" 333:    +314 -301 -297\n"
+" 334:    +306 -303 -314 -315 +310\n"
+" 335:    +315 -231 -313\n"
+" 336:    +230 -315 -316\n"
+" 337:    +73  -313 -316\n"
+" 338:    +72  -313 -317\n"
+" 339:    +317 -316 -68 \n"
+" 340:    +317 -318 -66 \n"
+" 341:    +318 -316 -69 \n"
+" 342:    +235 -319 -316\n"
+" 343:    +238 -319 -318\n"
+" 344:    +320 -321 -318\n"
+" 345:    +321 -322 -319\n"
+" 346:    +320 -322 -238\n"
+" 347:    +320 -323 -241\n"
+" 348:    +323 -322 -239\n"
+" 349:    +324 -325 -326\n"
+" 350:    +325 -327 -328\n"
+" 351:    +329 -327 -330\n"
+" 352:    +331 -330 -332\n"
+" 353:    +333 -332 -334\n"
+" 354:    +335 -334 -323\n"
+" 355:    +324 -329 -333 -322 +336\n"
+" 356:    +336 -337 -338\n"
+" 357:    +339 -326 -337\n"
+" 358:    +331 -328 -339 -340 +335\n"
+" 359:    +340 -338 -239\n"
+" 360:    +341 -340 -240\n"
+" 361:    +341 -338 -237\n"
+" 362:    +338 -342 -236\n"
+" 363:    +341 -342 -107\n"
+" 364:    +342 -343 -104\n"
+" 365:    +341 -343 -106\n"
+" 366:    +341 -344 -112\n"
+" 367:    +344 -343 -110\n"
+" 368:    +257 -345 -110\n"
+" 369:    +345 -346 -343\n"
+" 370:    +257 -346 -344\n"
+" 371:    +246 -347 -348\n"
+" 372:    +347 -349 -328\n"
+" 373:    +251 -349 -350\n"
+" 374:    +331 -350 -351\n"
+" 375:    +255 -351 -352\n"
+" 376:    +335 -352 -244\n"
+" 377:    +339 -348 -346\n"
+" 378:    +340 -344 -243\n"
+" 379:    +348 -353 -354\n"
+" 380:    +339 -353 -355\n"
+" 381:    +355 -354 -346\n"
+" 382:    +290 -355 -343\n"
+" 383:    +290 -354 -345\n"
+" 384:    +282 -356 -345\n"
+" 385:    +356 -283 -354\n"
+" 386:    +357 -358 -354\n"
+" 387:    +358 -359 -283\n"
+" 388:    +357 -359 -356\n"
+" 389:    +359 -360 -277\n"
+" 390:    +357 -360 -248\n"
+" 391:    +248 -277 -356\n"
+" 392:    +279 -356 -258\n"
+" 393:    +282 -279 -263\n"
+" 394:    +345 -258 -263\n"
+" 395:    +360 -361 -247\n"
+" 396:    +357 -361 -246\n"
+" 397:    +357 -362 -348\n"
+" 398:    +362 -361 -347\n"
+" 399:    +363 -364 -347\n"
+" 400:    +364 -20  -361\n"
+" 401:    +363 -20  -362\n"
+" 402:    +363 -19  -365\n"
+" 403:    +362 -17  -365\n"
+" 404:    +358 -362 -353\n"
+" 405:    +358 -17  -366\n"
+" 406:    +366 -365 -353\n"
+" 407:    +367 -366 -368\n"
+" 408:    +367 -365 -326\n"
+" 409:    +326 -353 -368\n"
+" 410:    +355 -368 -337\n"
+" 411:    +289 -355 -342\n"
+" 412:    +289 -368 -369\n"
+" 413:    +369 -337 -342\n"
+" 414:    +336 -369 -236\n"
+" 415:    +369 -370 -233\n"
+" 416:    +336 -370 -234\n"
+" 417:    +324 -371 -372\n"
+" 418:    +371 -373 -303\n"
+" 419:    +329 -373 -374\n"
+" 420:    +306 -374 -375\n"
+" 421:    +333 -375 -376\n"
+" 422:    +310 -376 -321\n"
+" 423:    +314 -372 -370\n"
+" 424:    +315 -234 -319\n"
+" 425:    +372 -377 -378\n"
+" 426:    +314 -377 -296\n"
+" 427:    +296 -378 -370\n"
+" 428:    +291 -296 -233\n"
+" 429:    +291 -378 -369\n"
+" 430:    +368 -286 -378\n"
+" 431:    +367 -379 -378\n"
+" 432:    +379 -366 -286\n"
+" 433:    +380 -381 -281\n"
+" 434:    +381 -7   -359\n"
+" 435:    +382 -383 -284\n"
+" 436:    +380 -16  -383\n"
+" 437:    +382 -15  -384\n"
+" 438:    +385 -384 -285\n"
+" 439:    +379 -18  -385\n"
+" 440:    +379 -386 -377\n"
+" 441:    +386 -18  -387\n"
+" 442:    +385 -387 -377\n"
+" 443:    +388 -385 -295\n"
+" 444:    +388 -387 -301\n"
+" 445:    +301 -377 -295\n"
+" 446:    +387 -389 -300\n"
+" 447:    +388 -389 -299\n"
+" 448:    +388 -390 -391\n"
+" 449:    +390 -389 -392\n"
+" 450:    +299 -392 -391\n"
+" 451:    +392 -393 -222\n"
+" 452:    +304 -393 -394\n"
+" 453:    +224 -394 -395\n"
+" 454:    +308 -395 -396\n"
+" 455:    +146 -396 -142\n"
+" 456:    +142 -312 -75 \n"
+" 457:    +298 -397 -228\n"
+" 458:    +226 -391 -397\n"
+" 459:    +391 -398 -293\n"
+" 460:    +226 -398 -399\n"
+" 461:    +399 -293 -397\n"
+" 462:    +288 -399 -96 \n"
+" 463:    +294 -397 -96 \n"
+" 464:    +287 -399 -95 \n"
+" 465:    +399 -400 -218\n"
+" 466:    +287 -400 -217\n"
+" 467:    +214 -284 -400\n"
+" 468:    +401 -382 -400\n"
+" 469:    +401 -383 -214\n"
+" 470:    +383 -402 -213\n"
+" 471:    +401 -402 -207\n"
+" 472:    +402 -403 -206\n"
+" 473:    +401 -403 -205\n"
+" 474:    +401 -404 -220\n"
+" 475:    +404 -403 -219\n"
+" 476:    +405 -406 -219\n"
+" 477:    +406 -13  -403\n"
+" 478:    +405 -13  -404\n"
+" 479:    +405 -14  -390\n"
+" 480:    +404 -15  -390\n"
+" 481:    +382 -404 -398\n"
+" 482:    +384 -390 -398\n"
+" 483:    +388 -384 -293\n"
+" 484:    +220 -398 -400\n"
+" 485:    +23  -12  -402\n"
+" 486:    +25  -16  -402\n"
+" 487:    +380 -25  -213\n"
+" 488:    +26  -380 -269\n"
+" 489:    +27  -213 -269\n"
+" 490:    +26  -381 -278\n"
+" 491:    +381 -407 -277\n"
+" 492:    +26  -407 -273\n"
+" 493:    +407 -2   -272\n"
+" 494:    +408 -0   -272\n"
+" 495:    +408 -1   -407\n"
+" 496:    +408 -6   -360\n"
+" 497:    +407 -7   -360\n"
+" 498:    +408 -409 -247\n"
+" 499:    +409 -6   -361\n"
+" 500:    +409 -8   -364\n"
+" 501:    +409 -410 -411\n"
+" 502:    +410 -8   -412\n"
+" 503:    +364 -412 -411\n"
+" 504:    +413 -364 -349\n"
+" 505:    +413 -412 -414\n"
+" 506:    +414 -411 -349\n"
+" 507:    +415 -414 -350\n"
+" 508:    +415 -411 -251\n"
+" 509:    +415 -416 -252\n"
+" 510:    +416 -411 -249\n"
+" 511:    +417 -409 -249\n"
+" 512:    +417 -410 -416\n"
+" 513:    +410 -418 -419\n"
+" 514:    +417 -418 -420\n"
+" 515:    +420 -419 -416\n"
+" 516:    +421 -420 -422\n"
+" 517:    +421 -419 -423\n"
+" 518:    +423 -416 -422\n"
+" 519:    +415 -423 -424\n"
+" 520:    +252 -422 -424\n"
+" 521:    +253 -422 -425\n"
+" 522:    +425 -424 -254\n"
+" 523:    +189 -425 -426\n"
+" 524:    +189 -424 -427\n"
+" 525:    +427 -254 -426\n"
+" 526:    +255 -427 -170\n"
+" 527:    +256 -426 -170\n"
+" 528:    +177 -256 -171\n"
+" 529:    +177 -426 -161\n"
+" 530:    +426 -180 -160\n"
+" 531:    +186 -425 -180\n"
+" 532:    +425 -187 -276\n"
+" 533:    +182 -276 -180\n"
+" 534:    +275 -422 -187\n"
+" 535:    +428 -421 -187\n"
+" 536:    +428 -420 -275\n"
+" 537:    +420 -429 -274\n"
+" 538:    +428 -429 -31 \n"
+" 539:    +428 -430 -32 \n"
+" 540:    +430 -429 -29 \n"
+" 541:    +431 -5   -29 \n"
+" 542:    +5   -432 -429\n"
+" 543:    +431 -432 -430\n"
+" 544:    +431 -433 -434\n"
+" 545:    +433 -432 -435\n"
+" 546:    +430 -435 -434\n"
+" 547:    +436 -430 -437\n"
+" 548:    +436 -435 -438\n"
+" 549:    +438 -434 -437\n"
+" 550:    +439 -438 -201\n"
+" 551:    +439 -434 -210\n"
+" 552:    +210 -437 -201\n"
+" 553:    +33  -437 -184\n"
+" 554:    +32  -437 -185\n"
+" 555:    +428 -436 -185\n"
+" 556:    +436 -421 -188\n"
+" 557:    +435 -419 -440 -441 +442\n"
+" 558:    +443 -440 -444\n"
+" 559:    +445 -444 -193\n"
+" 560:    +446 -438 -191\n"
+" 561:    +446 -442 -447\n"
+" 562:    +448 -447 -192\n"
+" 563:    +445 -441 -448\n"
+" 564:    +443 -423 -190\n"
+" 565:    +415 -443 -449\n"
+" 566:    +424 -190 -449\n"
+" 567:    +198 -449 -427\n"
+" 568:    +198 -450 -451\n"
+" 569:    +450 -449 -351\n"
+" 570:    +427 -351 -451\n"
+" 571:    +352 -451 -170\n"
+" 572:    +452 -352 -172\n"
+" 573:    +452 -451 -165\n"
+" 574:    +452 -453 -166\n"
+" 575:    +453 -451 -162\n"
+" 576:    +197 -450 -453\n"
+" 577:    +450 -454 -332\n"
+" 578:    +197 -454 -455\n"
+" 579:    +455 -332 -453\n"
+" 580:    +333 -455 -456\n"
+" 581:    +334 -453 -456\n"
+" 582:    +452 -334 -457\n"
+" 583:    +166 -456 -457\n"
+" 584:    +167 -456 -458\n"
+" 585:    +458 -457 -132\n"
+" 586:    +320 -458 -136\n"
+" 587:    +320 -457 -137\n"
+" 588:    +457 -323 -459\n"
+" 589:    +241 -459 -137\n"
+" 590:    +242 -459 -138\n"
+" 591:    +172 -244 -459\n"
+" 592:    +452 -335 -459\n"
+" 593:    +458 -321 -460\n"
+" 594:    +318 -460 -136\n"
+" 595:    +317 -460 -135\n"
+" 596:    +140 -311 -460\n"
+" 597:    +139 -311 -317\n"
+" 598:    +139 -312 -72 \n"
+" 599:    +461 -310 -460\n"
+" 600:    +461 -309 -140\n"
+" 601:    +309 -462 -463\n"
+" 602:    +461 -462 -169\n"
+" 603:    +169 -463 -140\n"
+" 604:    +168 -463 -141\n"
+" 605:    +145 -396 -141\n"
+" 606:    +396 -464 -463\n"
+" 607:    +145 -464 -168\n"
+" 608:    +464 -148 -164\n"
+" 609:    +195 -465 -148\n"
+" 610:    +196 -465 -464\n"
+" 611:    +465 -466 -395\n"
+" 612:    +196 -466 -467\n"
+" 613:    +467 -395 -464\n"
+" 614:    +308 -467 -463\n"
+" 615:    +467 -307 -462\n"
+" 616:    +200 -468 -462\n"
+" 617:    +468 -469 -307\n"
+" 618:    +200 -469 -467\n"
+" 619:    +466 -192 -469\n"
+" 620:    +470 -448 -469\n"
+" 621:    +470 -447 -466\n"
+" 622:    +447 -471 -472\n"
+" 623:    +470 -471 -394\n"
+" 624:    +394 -472 -466\n"
+" 625:    +224 -472 -465\n"
+" 626:    +223 -472 -473\n"
+" 627:    +465 -473 -225\n"
+" 628:    +195 -473 -203\n"
+" 629:    +203 -225 -148\n"
+" 630:    +201 -191 -473\n"
+" 631:    +439 -446 -473\n"
+" 632:    +446 -474 -472\n"
+" 633:    +439 -474 -223\n"
+" 634:    +474 -475 -221\n"
+" 635:    +439 -475 -209\n"
+" 636:    +434 -475 -208\n"
+" 637:    +431 -476 -208\n"
+" 638:    +476 -433 -475\n"
+" 639:    +433 -9   -477\n"
+" 640:    +476 -9   -406\n"
+" 641:    +406 -477 -475\n"
+" 642:    +478 -406 -221\n"
+" 643:    +478 -477 -474\n"
+" 644:    +478 -479 -471\n"
+" 645:    +479 -477 -442\n"
+" 646:    +474 -442 -471\n"
+" 647:    +418 -3   -432\n"
+" 648:    +480 -412 -440\n"
+" 649:    +480 -11  -481\n"
+" 650:    +482 -481 -441\n"
+" 651:    +479 -10  -482\n"
+" 652:    +483 -479 -484\n"
+" 653:    +483 -10  -485\n"
+" 654:    +485 -482 -484\n"
+" 655:    +486 -485 -302\n"
+" 656:    +486 -482 -487\n"
+" 657:    +487 -484 -302\n"
+" 658:    +470 -487 -305\n"
+" 659:    +470 -484 -304\n"
+" 660:    +471 -484 -393\n"
+" 661:    +478 -483 -393\n"
+" 662:    +405 -478 -222\n"
+" 663:    +405 -483 -392\n"
+" 664:    +483 -14  -389\n"
+" 665:    +485 -22  -389\n"
+" 666:    +488 -485 -300\n"
+" 667:    +488 -22  -387\n"
+" 668:    +488 -21  -386\n"
+" 669:    +488 -489 -371\n"
+" 670:    +489 -21  -490\n"
+" 671:    +386 -490 -371\n"
+" 672:    +367 -386 -372\n"
+" 673:    +367 -490 -324\n"
+" 674:    +365 -490 -325\n"
+" 675:    +363 -491 -325\n"
+" 676:    +491 -19  -490\n"
+" 677:    +491 -11  -489\n"
+" 678:    +491 -480 -492\n"
+" 679:    +489 -481 -492\n"
+" 680:    +486 -489 -373\n"
+" 681:    +486 -481 -493\n"
+" 682:    +493 -492 -373\n"
+" 683:    +494 -493 -374\n"
+" 684:    +494 -492 -329\n"
+" 685:    +494 -495 -330\n"
+" 686:    +495 -492 -327\n"
+" 687:    +413 -491 -327\n"
+" 688:    +413 -480 -495\n"
+" 689:    +414 -440 -495\n"
+" 690:    +443 -414 -496\n"
+" 691:    +444 -495 -496\n"
+" 692:    +494 -444 -454\n"
+" 693:    +330 -496 -454\n"
+" 694:    +331 -496 -450\n"
+" 695:    +350 -496 -449\n"
+" 696:    +494 -445 -497\n"
+" 697:    +454 -193 -497\n"
+" 698:    +199 -497 -455\n"
+" 699:    +199 -468 -498\n"
+" 700:    +468 -497 -375\n"
+" 701:    +455 -375 -498\n"
+" 702:    +376 -498 -456\n"
+" 703:    +461 -376 -458\n"
+" 704:    +461 -498 -167\n"
+" 705:    +462 -498 -163\n"
+" 706:    +374 -499 -497\n"
+" 707:    +306 -499 -468\n"
+" 708:    +305 -499 -469\n"
+" 709:    +448 -487 -499\n"
+" 710:    +445 -493 -499\n"
+" 711:    +493 -441 -487\n"
+" 712:    +363 -413 -328\n"
+" 713:    +488 -486 -303\n"
+" 714:    +0   -418 -429\n"
+" 715:    +417 -0   -274\n"
+" 716:    +408 -417 -250\n"
+" 717:    +476 -12  -403\n"
+" 718:    +23  -476 -206\n"
+" 719:    +23  -431 -30 \n"
+"320 3-cells:\n"
+"   0:    +0   +1   -2   -3  \n"
+"   1:    -4   -1   +5   -6   +7   +8   -9   +10  +11  -12  -13  +14 \n"
+"   2:    +15  +3   -16  -17 \n"
+"   3:    +18  +17  -19  -20 \n"
+"   4:    +20  +21  -22  +23  -24  +25  +26  -27  +28  -29  -30  -31 \n"
+"   5:    +32  +31  -33  -34 \n"
+"   6:    +35  +34  -36  -37 \n"
+"   7:    +38  +37  -39  -40 \n"
+"   8:    -41  -42  +43  -44  +45  -46  +40  -47  +48  -49  +50  -51 \n"
+"   9:    -52  -53  +54  +51 \n"
+"  10:    -54  -55  +56  +57 \n"
+"  11:    +58  +59  -57  -45 \n"
+"  12:    +60  +61  -62  -59 \n"
+"  13:    -63  -64  +65  +62 \n"
+"  14:    +66  +67  -65  -68 \n"
+"  15:    -69  -70  +68  +39 \n"
+"  16:    -32  -71  +72  +70 \n"
+"  17:    -72  -73  +74  +75 \n"
+"  18:    -76  -75  +77  +78 \n"
+"  19:    -60  -78  +69  +44 \n"
+"  20:    +79  +80  -81  -77 \n"
+"  21:    -82  -83  +81  +84 \n"
+"  22:    +85  +86  -87  +88  -89  -43  +76  -90  -84  +91  +92  -93 \n"
+"  23:    +93  +94  -95  -96 \n"
+"  24:    +97  +96  -98  -50 \n"
+"  25:    +98  +99  -100 -101\n"
+"  26:    -102 -103 +101 +41 \n"
+"  27:    -104 -105 +106 +103\n"
+"  28:    +107 +108 -109 -106\n"
+"  29:    -110 -26  +109 +36 \n"
+"  30:    -111 -112 +110 +113\n"
+"  31:    -38  -113 +114 +115\n"
+"  32:    +116 +117 -118 +119 -120 +46  -115 +121 -122 +123 -124 +125\n"
+"  33:    +126 +127 -128 -125\n"
+"  34:    +128 +129 -130 -131\n"
+"  35:    -58  -132 +131 +120\n"
+"  36:    -133 -134 +63  +132\n"
+"  37:    -135 -136 +137 +134\n"
+"  38:    -137 -138 +139 +140\n"
+"  39:    +141 +142 -140 -143\n"
+"  40:    +133 +143 -144 -119\n"
+"  41:    +144 +145 -66  -114\n"
+"  42:    +146 +147 -148 -145\n"
+"  43:    +148 +149 -150 -142\n"
+"  44:    +150 +151 -152 -153\n"
+"  45:    -154 -155 +156 -157 +158 +118 -141 +153 +159 -160 -161 +162\n"
+"  46:    -162 -163 +164 +165\n"
+"  47:    -166 -165 +167 +124\n"
+"  48:    -167 -168 +169 +170\n"
+"  49:    +102 +171 -170 -116\n"
+"  50:    +172 +173 -107 -171\n"
+"  51:    +174 +175 -176 -173\n"
+"  52:    +176 +177 -178 -179\n"
+"  53:    +154 +179 -180 -181\n"
+"  54:    +111 +181 -172 -117\n"
+"  55:    -182 -183 +152 +180\n"
+"  56:    -184 -185 +24  +183\n"
+"  57:    -186 -187 +188 +185\n"
+"  58:    +189 +190 -191 -188\n"
+"  59:    +192 +191 -193 +194 -195 -156 +196 -197 -198 +199 +200 -201\n"
+"  60:    +201 +186 -202 -151\n"
+"  61:    +202 +203 -204 -205\n"
+"  62:    +206 +205 -207 -149\n"
+"  63:    -208 -209 +210 -211 +207 -147 -67  +212 -213 +214 +30  +71 \n"
+"  64:    -214 -215 +216 +217\n"
+"  65:    -218 -217 +219 +220\n"
+"  66:    -221 -220 +213 +73 \n"
+"  67:    +221 +222 -223 -80 \n"
+"  68:    +224 +225 -226 +227 -228 +136 +64  -212 +223 -229 -230 -231\n"
+"  69:    +232 +231 -79  -61 \n"
+"  70:    -232 -233 +234 +55 \n"
+"  71:    -234 -235 +82  +236\n"
+"  72:    -91  -236 +237 +53 \n"
+"  73:    +238 +239 -240 -237\n"
+"  74:    +240 +241 -242 -92 \n"
+"  75:    -243 -244 +242 +245\n"
+"  76:    +89  +246 -245 -247\n"
+"  77:    +248 +247 -249 -48 \n"
+"  78:    +249 +250 -251 -252\n"
+"  79:    -253 -254 +252 +49 \n"
+"  80:    -97  -255 +256 +254\n"
+"  81:    +257 +258 -259 -256\n"
+"  82:    -169 -260 +259 +100\n"
+"  83:    +261 +262 -263 +264 -265 +266 +260 -267 +268 -269 -270 -271\n"
+"  84:    +272 +271 -273 -99 \n"
+"  85:    +273 +274 -275 -94 \n"
+"  86:    +275 +276 -277 -86 \n"
+"  87:    -278 -279 +277 +280\n"
+"  88:    -85  -280 +281 +282\n"
+"  89:    -35  -282 +104 +42 \n"
+"  90:    +33  +283 -284 -281\n"
+"  91:    -74  -285 +284 +90 \n"
+"  92:    -286 -287 +218 +285\n"
+"  93:    +287 +288 -289 -290\n"
+"  94:    +291 +290 -28  -283\n"
+"  95:    -291 -292 +293 +279\n"
+"  96:    -294 -295 +296 -297 +298 -175 -108 +27  -293 +299 +270 +300\n"
+"  97:    -272 -300 +278 +105\n"
+"  98:    -299 -301 +302 +303\n"
+"  99:    -304 -303 +305 +292\n"
+" 100:    -305 -306 +307 +289\n"
+" 101:    -308 -307 +309 -310 +311 +87  -312 +313 +314 -315 -316 +286\n"
+" 102:    -317 -318 +316 +319\n"
+" 103:    +320 +321 -319 -322\n"
+" 104:    +323 +322 -324 -239\n"
+" 105:    +325 +326 -327 +328 -329 +330 +331 -332 +324 -333 -334 -335\n"
+" 106:    +336 +335 -238 -337\n"
+" 107:    +52  +337 -338 -339\n"
+" 108:    -340 -341 +339 +47 \n"
+" 109:    -248 -342 +343 +341\n"
+" 110:    +344 +345 -346 -343\n"
+" 111:    -347 -348 +346 +251\n"
+" 112:    +349 +350 -351 +352 -353 +354 +348 -355 +356 -357 -358 -359\n"
+" 113:    +360 +359 -361 -250\n"
+" 114:    +361 +362 -363 -246\n"
+" 115:    +363 +364 -365 -88 \n"
+" 116:    -366 -367 +365 +95 \n"
+" 117:    -368 -369 +370 +367\n"
+" 118:    -371 -372 +373 -374 +375 -376 -258 +267 -370 +377 +358 +378\n"
+" 119:    -360 -378 +366 +255\n"
+" 120:    -377 -379 +380 +381\n"
+" 121:    -382 -381 +383 +369\n"
+" 122:    +384 +385 -313 -383\n"
+" 123:    +386 +387 -388 -385\n"
+" 124:    +388 +389 -390 -391\n"
+" 125:    +269 +391 -302 -392\n"
+" 126:    +393 +392 -384 -394\n"
+" 127:    +368 +394 -268 -274\n"
+" 128:    +308 +304 -393 -276\n"
+" 129:    +390 +395 -396 -261\n"
+" 130:    -397 -398 +396 +371\n"
+" 131:    -399 -400 +401 +398\n"
+" 132:    +402 +9   -401 -403\n"
+" 133:    +404 +403 -405 -406\n"
+" 134:    +407 +406 -408 -409\n"
+" 135:    +357 +409 -380 -410\n"
+" 136:    +411 +410 -412 -413\n"
+" 137:    +414 +413 -356 -362\n"
+" 138:    -414 -415 +416 +244\n"
+" 139:    -417 -418 +419 -420 +421 -422 -345 +355 -416 +423 +334 +424\n"
+" 140:    -336 -424 +243 +342\n"
+" 141:    -423 -425 +426 +427\n"
+" 142:    -428 -427 +429 +415\n"
+" 143:    +412 +430 -314 -429\n"
+" 144:    +431 +432 -407 -430\n"
+" 145:    +433 +434 -8   +405 -432 -309 +435 -436 -437 +438 +439 -387\n"
+" 146:    +440 +441 -439 -442\n"
+" 147:    +443 +442 -444 -445\n"
+" 148:    +333 +445 -426 -321\n"
+" 149:    +444 +446 -447 -325\n"
+" 150:    -448 -449 +447 +450\n"
+" 151:    -450 -451 +452 -453 +454 -455 -456 +332 -457 +458 +230 +233\n"
+" 152:    -458 -459 +460 +461\n"
+" 153:    -462 -461 +317 +463\n"
+" 154:    -323 -463 +457 +235\n"
+" 155:    -311 -464 +462 +83 \n"
+" 156:    +464 +465 -466 -222\n"
+" 157:    -219 -467 +310 +466\n"
+" 158:    -468 -435 +469 +467\n"
+" 159:    -469 -470 +471 +215\n"
+" 160:    -471 -472 +473 +208\n"
+" 161:    +474 +475 -473 -224\n"
+" 162:    +476 +477 -478 -475\n"
+" 163:    -479 -7   +478 +480\n"
+" 164:    -481 -480 +437 +482\n"
+" 165:    -483 -482 +448 +459\n"
+" 166:    -443 -438 +483 +318\n"
+" 167:    +468 +481 -474 -484\n"
+" 168:    +229 +484 -460 -465\n"
+" 169:    -485 -14  +16  +486\n"
+" 170:    -487 -486 +436 +470\n"
+" 171:    +488 +487 -18  -489\n"
+" 172:    +29  +489 -216 -288\n"
+" 173:    -488 -433 +490 +306\n"
+" 174:    -490 -491 +492 +301\n"
+" 175:    -492 -493 +19  +294\n"
+" 176:    -494 -0   +495 +493\n"
+" 177:    +496 +4   -495 -497\n"
+" 178:    +491 +497 -434 -389\n"
+" 179:    +498 +499 -496 -395\n"
+" 180:    -499 -10  +500 +400\n"
+" 181:    +501 +502 -500 -503\n"
+" 182:    +504 +503 -505 -506\n"
+" 183:    +507 +506 -508 -373\n"
+" 184:    -509 -510 +508 +263\n"
+" 185:    -511 -501 +512 +510\n"
+" 186:    -512 -513 +514 +515\n"
+" 187:    -516 -515 +517 +518\n"
+" 188:    -519 -518 +509 +520\n"
+" 189:    -264 -520 +521 +522\n"
+" 190:    -523 -522 +524 +525\n"
+" 191:    -526 -525 +265 +527\n"
+" 192:    -528 -527 +529 +163\n"
+" 193:    -529 -530 +178 +155\n"
+" 194:    -192 -531 +523 +530\n"
+" 195:    +531 +532 -189 -533\n"
+" 196:    +184 +533 -298 -177\n"
+" 197:    +297 +534 -521 -532\n"
+" 198:    +535 +516 -536 -534\n"
+" 199:    +536 +537 -538 -296\n"
+" 200:    -539 -540 +538 +22 \n"
+" 201:    -541 -542 +543 +540\n"
+" 202:    +544 +545 -543 -546\n"
+" 203:    +547 +546 -548 -549\n"
+" 204:    +550 +549 -551 -552\n"
+" 205:    +211 +552 -553 -203\n"
+" 206:    -23  -554 +553 +187\n"
+" 207:    -555 -547 +539 +554\n"
+" 208:    +555 +556 -535 -190\n"
+" 209:    -556 -517 +557 -558 +559 +193 -560 +548 +561 -562 -563 +564\n"
+" 210:    -565 -564 +519 +566\n"
+" 211:    -524 -566 +197 +567\n"
+" 212:    +568 +569 -567 -570\n"
+" 213:    +526 +570 -375 -571\n"
+" 214:    +572 +571 -573 -164\n"
+" 215:    -574 -575 +573 +157\n"
+" 216:    -196 -568 +576 +575\n"
+" 217:    -576 -577 +578 +579\n"
+" 218:    -580 -579 +353 +581\n"
+" 219:    -582 -581 +574 +583\n"
+" 220:    -158 -583 +584 +585\n"
+" 221:    -586 -585 +587 +122\n"
+" 222:    -587 -588 +347 +589\n"
+" 223:    +253 +590 -589 -123\n"
+" 224:    +166 +591 -257 -590\n"
+" 225:    +592 +376 -572 -591\n"
+" 226:    -592 -354 +582 +588\n"
+" 227:    +586 +593 -344 -594\n"
+" 228:    +340 +594 -595 -121\n"
+" 229:    -126 -596 +597 +595\n"
+" 230:    -597 -331 +598 +338\n"
+" 231:    +130 +456 -598 -56 \n"
+" 232:    -599 -330 +600 +596\n"
+" 233:    -600 -601 +602 +603\n"
+" 234:    +160 +604 -603 -127\n"
+" 235:    +605 +606 -607 -604\n"
+" 236:    +607 +608 -139 -159\n"
+" 237:    +195 +609 -610 -608\n"
+" 238:    +610 +611 -612 -613\n"
+" 239:    +614 +613 -454 -606\n"
+" 240:    -614 -615 +329 +601\n"
+" 241:    -616 -617 +618 +615\n"
+" 242:    +612 +619 -200 -618\n"
+" 243:    +620 +562 -621 -619\n"
+" 244:    +621 +622 -623 -624\n"
+" 245:    +453 +624 -625 -611\n"
+" 246:    -227 -626 +625 +627\n"
+" 247:    -609 -627 +628 +629\n"
+" 248:    -206 -629 +228 +138\n"
+" 249:    +204 +630 -194 -628\n"
+" 250:    +631 +560 -550 -630\n"
+" 251:    -631 -632 +633 +626\n"
+" 252:    -633 -634 +635 +226\n"
+" 253:    +551 +636 -635 -210\n"
+" 254:    +637 +638 -544 -636\n"
+" 255:    -638 -639 +640 +641\n"
+" 256:    -642 -641 +643 +634\n"
+" 257:    +644 +645 -643 -646\n"
+" 258:    +632 +646 -561 -622\n"
+" 259:    +513 +647 -5   +639 -645 -557 +648 -502 -649 +650 +651 -545\n"
+" 260:    -652 -651 +653 +654\n"
+" 261:    -655 -654 +656 +657\n"
+" 262:    -658 -657 +659 +327\n"
+" 263:    +623 +660 -659 -452\n"
+" 264:    +661 +652 -644 -660\n"
+" 265:    -662 -661 +663 +451\n"
+" 266:    -663 -664 +479 +449\n"
+" 267:    +664 +13  -653 -665\n"
+" 268:    +666 +665 -667 -446\n"
+" 269:    +667 +12  -668 -441\n"
+" 270:    -669 -670 +668 +671\n"
+" 271:    -672 -671 +673 +417\n"
+" 272:    +408 +674 -673 -349\n"
+" 273:    +675 +676 -402 -674\n"
+" 274:    -676 -11  +677 +670\n"
+" 275:    +678 +649 -677 -679\n"
+" 276:    +680 +679 -681 -682\n"
+" 277:    +683 +682 -684 -419\n"
+" 278:    -685 -686 +684 +351\n"
+" 279:    -687 -678 +688 +686\n"
+" 280:    -688 -648 +505 +689\n"
+" 281:    -690 -689 +558 +691\n"
+" 282:    -692 -691 +685 +693\n"
+" 283:    -352 -693 +694 +577\n"
+" 284:    +374 +695 -694 -569\n"
+" 285:    +565 +690 -507 -695\n"
+" 286:    -696 -559 +692 +697\n"
+" 287:    -578 -697 +198 +698\n"
+" 288:    +699 +700 -698 -701\n"
+" 289:    +580 +701 -421 -702\n"
+" 290:    +703 +702 -704 -584\n"
+" 291:    -602 -705 +704 +161\n"
+" 292:    -199 -699 +616 +705\n"
+" 293:    +599 +422 -703 -593\n"
+" 294:    +420 +706 -707 -700\n"
+" 295:    -328 -708 +707 +617\n"
+" 296:    -620 -709 +658 +708\n"
+" 297:    -710 -711 +563 +709\n"
+" 298:    -656 -650 +681 +711\n"
+" 299:    +696 +710 -683 -706\n"
+" 300:    +712 +687 -675 -350\n"
+" 301:    -712 -504 +399 +372\n"
+" 302:    -713 -680 +669 +418\n"
+" 303:    +713 +655 -666 -326\n"
+" 304:    -431 -440 +672 +425\n"
+" 305:    +662 +642 -476 -225\n"
+" 306:    -714 -647 +2   +542\n"
+" 307:    +715 +714 -514 -537\n"
+" 308:    -716 -715 +494 +295\n"
+" 309:    +716 +511 -498 -262\n"
+" 310:    +717 +6   -640 -477\n"
+" 311:    -718 -717 +485 +472\n"
+" 312:    -719 -637 +718 +209\n"
+" 313:    +719 +541 -15  -21 \n"
+" 314:    +135 +455 -605 -129\n"
+" 315:    -174 -266 +528 +168\n"
+" 316:    +315 +428 -320 -241\n"
+" 317:    +312 +382 -411 -364\n"
+" 318:    -386 -404 +397 +379\n"
+" 319:    -146 -25  +182 +112\n"
+"1 4-cell:\n"
+" 0:    +0   +1   +2   +3   +4   +5   +6   +7   +8   +9   +10  +11  +12  +13  +14  +15  +16  +17  +18  +19  +20  +21  +22  +23  +24  +25  +26  +27  +28  +29  +30  +31  +32  +33  +34  +35  +36  +37  +38  +39  +40  +41  +42  +43  +44  +45  +46  +47  +48  +49  +50  +51  +52  +53  +54  +55  +56  +57  +58  +59  +60  +61  +62  +63  +64  +65  +66  +67  +68  +69  +70  +71  +72  +73  +74  +75  +76  +77  +78  +79  +80  +81  +82  +83  +84  +85  +86  +87  +88  +89  +90  +91  +92  +93  +94  +95  +96  +97  +98  +99  +100 +101 +102 +103 +104 +105 +106 +107 +108 +109 +110 +111 +112 +113 +114 +115 +116 +117 +118 +119 +120 +121 +122 +123 +124 +125 +126 +127 +128 +129 +130 +131 +132 +133 +134 +135 +136 +137 +138 +139 +140 +141 +142 +143 +144 +145 +146 +147 +148 +149 +150 +151 +152 +153 +154 +155 +156 +157 +158 +159 +160 +161 +162 +163 +164 +165 +166 +167 +168 +169 +170 +171 +172 +173 +174 +175 +176 +177 +178 +179 +180 +181 +182 +183 +184 +185 +186 +187 +188 +189 +190 +191 +192 +193 +194 +195 +196 +197 +198 +199 +200 +201 +202 +203 +204 +205 +206 +207 +208 +209 +210 +211 +212 +213 +214 +215 +216 +217 +218 +219 +220 +221 +222 +223 +224 +225 +226 +227 +228 +229 +230 +231 +232 +233 +234 +235 +236 +237 +238 +239 +240 +241 +242 +243 +244 +245 +246 +247 +248 +249 +250 +251 +252 +253 +254 +255 +256 +257 +258 +259 +260 +261 +262 +263 +264 +265 +266 +267 +268 +269 +270 +271 +272 +273 +274 +275 +276 +277 +278 +279 +280 +281 +282 +283 +284 +285 +286 +287 +288 +289 +290 +291 +292 +293 +294 +295 +296 +297 +298 +299 +300 +301 +302 +303 +304 +305 +306 +307 +308 +309 +310 +311 +312 +313 +314 +315 +316 +317 +318 +319\n"
;
                System.out.println("making a grand antiprism!");
                System.out.flush();
                return SPolytope.fromStringInPcalcFormat(s);
            }

        } // makeGrandAntiprism

        public static SPolytope makeConvexHull(double verts[][])
        {
            do {if (true) throw new Error("Unimplemented at "+"com/donhatchsw/util/CSG.prejava"+"("+4967 +")"); } while (false); // :-(
            return null;
        } // makeConvexHull




    //
    // Utilities...
    //
        //
        // A polytope is "binary"
        // if all densities are 0 or 1.
        // XXX also checks whether it's finite-or-cofinite,
        // XXX so isBinary is a misnomer.
        //
        public static boolean isBinaryDensityShallow(Polytope p)
        {
            if (p.dim == 1)
            {
                int nPluses = 0, nMinuses = 0; // and counting
                SPolytope facets[] = p.facets;
                int nFacets = facets.length;
                for (int iFacet = 0; (iFacet) < (nFacets); ++iFacet)
                {
                    SPolytope facet = facets[iFacet];

                    if (facet.initialDensity != 0)
                        return false; // only top-level can have nonzero initial density in a finite-or-cofinite polytope

                    int sign = facet.sign;
                    if (sign == 1)
                        nPluses++;
                    else if (sign == -1)
                        nMinuses++;
                    else
                        return false;
                }
                if (nPluses != nMinuses)
                    return false;
            }
            // XXX else!?
            return true;
        } // isBinaryDensityShallow

        public static boolean isBinaryDensityDeep(SPolytope sp)
        {
            if (sp.initialDensity != 0
             && sp.initialDensity != 1)
                return false;
            Polytope allElements[][] = sp.p.getAllElements();
            int dim = sp.p.dim;
            for (int iDim = 0; (iDim) < (dim+1); ++iDim)
            {
                Polytope ofDim[] = allElements[iDim];
                int nOfDim = ofDim.length;
                for (int iOfDim = 0; (iOfDim) < (nOfDim); ++iOfDim)
                    if (!isBinaryDensityShallow(ofDim[iOfDim]))
                        return false;
            }
            return true;
        } // isBinaryDensityDeep



        //
        // Do one level of orientedness checking.
        // XXX This is O(n^2); should use a hash table
        // XXX instead of an array for boundaryRidges
        //
        public static boolean isOrientedShallow(Polytope p)
        {
            final boolean verbose = false;
            //
            // A polytope is considered oriented
            // if the summation of the signed facets of its
            // signed facets is zero.
            //
            SPolytope facets[] = p.facets;
            int nFacets = facets.length;
            int maxRidges;
            {
                maxRidges = 0; // and counting
                for (int iFacet = 0; (iFacet) < (nFacets); ++iFacet)
                    maxRidges += facets[iFacet].p.facets.length;
            }
            SPolytope boundaryRidges[] = new SPolytope[maxRidges];
            int nBoundaryRidges = 0; // and counting
            {
                for (int iFacet = 0; (iFacet) < (nFacets); ++iFacet)
                {
                    SPolytope facet = facets[iFacet];
                    SPolytope ridgesThisFacet[] = facet.p.facets;
                    int nRidgesThisFacet = ridgesThisFacet.length;
                    for (int iRidgeThisFacet = 0; (iRidgeThisFacet) < (nRidgesThisFacet); ++iRidgeThisFacet)
                    {
                        SPolytope ridge = ridgesThisFacet[iRidgeThisFacet];
                        int sign = facet.sign * ridge.sign;
                        // Add boundaryRidge to boundaryRidges.
                        {
                            if (verbose)
                                System.out.println("Adding "
                                                   +signToString(facet.sign)
                                                   +signToString(ridge.sign)
                                                   +"="
                                                   +signToString(sign)
                                                   +ridge.p.id);
                            int iBoundaryRidge;
                            for (iBoundaryRidge = 0; (iBoundaryRidge) < (nBoundaryRidges); ++iBoundaryRidge)
                            {
                                if (boundaryRidges[iBoundaryRidge].p
                                 == ridge.p)
                                {
                                    // Found it!  Add the new coefficient.
                                    if ((boundaryRidges[iBoundaryRidge].sign
                                       += sign) == 0)
                                    {
                                        // New coefficient for this ridge is 0;
                                        // remove the ridge from the list.

                                        boundaryRidges[iBoundaryRidge--] = boundaryRidges[--nBoundaryRidges]; // subtle-- decrement iBoundaryRidges too, so that the test after this loop will still be valid
                                        if (verbose)
                                            System.out.println("    (poof!)");
                                    }
                                    else
                                    {
                                        //
                                        // It's an unusual polytope
                                        // in which the cumulative sign
                                        // can ever be other than
                                        // 0, -1, or +1; as of this writing
                                        // I don't think I've provided a way
                                        // to make one.  But it's
                                        // theoretically possible.
                                        //
                                        if (verbose)
                                            System.out.println("    (SURPRISE, cumulative sign is "+signToString(boundaryRidges[iBoundaryRidge].sign)+")");
                                    }
                                    break;
                                }
                            }
                            if (iBoundaryRidge == nBoundaryRidges)
                            {
                                // Didn't find it; add it
                                boundaryRidges[nBoundaryRidges++] = new SPolytope(0, sign, ridge.p);
                                if (verbose)
                                    System.out.println("    (truly)");
                            }
                        }
                    }
                }
            }
            return nBoundaryRidges == 0;
        } // isOrientedShallow


        public static boolean isOrientedDeep(Polytope p)
        {
            Polytope allElements[][] = p.getAllElements();
            int dim = p.dim;
            for (int i = 0; (i) < (dim+1); ++i)
            {
                Polytope elementsOfDim[] = allElements[i];
                int nElementsOfDim = elementsOfDim.length;
                for (int j = 0; (j) < (nElementsOfDim); ++j)
                    if (!isOrientedShallow(elementsOfDim[j]))
                    {
                        if (verboseLevel >= 2)
                        {
                            System.out.println("isOrientedDeep returning false because element "+j+"/"+nElementsOfDim+" of dimension "+i+" is not oriented shallow:");
                            System.out.println("        " + "allElements" + "["+(i)+"]["+(j)+"] = " + (allElements)[i][j]);
                        }
                        return false;
                    }
            }
            return true;
        } // isOrientedDeep


        /**
        *  Count up number of vertices, edges, ...
        *  and return the counts in an array.
        */
        public static int[] counts(Polytope p)
        {
            return (int[])Arrays.arrayLengths(p.getAllElements(), 1, 1);
        } // counts

        private static boolean contains(Polytope p, Polytope q)
        {
            Polytope eltsOfDim[] = p.getAllElements()[q.dim];
            // XXX shouldn't have to keep making comparator...
            int index = SortStuff.bsearch(eltsOfDim, q,
                               new SortStuff.Comparator() {
                                   @Override public int compare(Object _a, Object _b)
                                   {
                                       Polytope a = (Polytope)_a;
                                       Polytope b = (Polytope)_b;
                                       return a.id < b.id ? -1 :
                                              a.id > b.id ? 1 : 0;
                                   }
                               });
            return index != -1;
        } // contains

        /**
        * The order returned will be a factor of maxPossibleOrder.
        *  usefulMat should be an orthogonal matrix
        *  whose last two rows are in the plane of the desired rotation.
        * So a rotation of any angle in that plane can be computed as:
        *        Take the rows of mat to the canonical basis vectors e[0]..e[n-1]
        *        rotate e[n-2] towards e[n-1]
        *        take the canonical basis vectors back to the original rows
        * I.e. rotMat = VecMath.mxmxm(VecMath.transpose(mat),
        *                             VecMath.makeRowRotMat(nDims,nDims-2,nDims-1, angle),
        *                             mat);
        * XXX isn't there a version of makeRowRotMat that does something like this?  check it out.  it looks overly complicated though, and assumes nDims==3 which is lame, should have a look at it
        */
        public static int calcRotationGroupOrder(Polytope p,
                                                 int maxPossibleOrder,
                                                 double usefulMat[][])
        {
            if (maxPossibleOrder == 0)
                return 0; // XXX maybe the caller should not call in this case... I doubt usefulMat is sane here
            //PRINT(maxPossibleOrder);
            //PRINTMAT(usefulMat);
            int nDims = usefulMat.length;

            //
            // Compute a rotation matrix
            // that rotates by 2pi/maxPossibleOrder
            // in the plane spanned by the last two rows of usefulMat.
            // The rotation we want to describe is:
            //     take the rows of mat to the canonical basis vectors e[0]..e[n-1]
            //     rotate e[n-2] towards e[n-1]
            //     take the canonical basis vectors back to the original rows
            //
            double maxPossibleOrderMat[][] =
                VecMath.mxmxm(VecMath.transpose(usefulMat),
                              VecMath.makeRowRotMat(nDims,nDims-2,nDims-1, 2*Math.PI/maxPossibleOrder),
                              usefulMat);

            //double littleTol = 1e-9, bigTol = 1e-8; // gives this: FuzzyException: FuzzyPoint.hashCode: coord -16.34765624446268 is neither equal nor unequal to grid line -16.34765625, using littleTol=1.0E-9, bigTol=1.0E-8, bucketSize=0.001953125
            //double littleTol = 1e-8, bigTol = 1e-7; // another similar error
            double littleTol = 1e-10, bigTol = 1e-9;

            FuzzyPointHashSet hashSet = new FuzzyPointHashSet(littleTol,
                                                              bigTol,
                                                              1./512);
            Polytope verts[] = p.getAllElements()[0];
            int nVerts = verts.length;
            {
                for (int iVert = 0; (iVert) < (nVerts); ++iVert)
                {
                    double vertCoords[] = verts[iVert].getCoords();
                    while (vertCoords.length < nDims)
                        vertCoords = Arrays.append(vertCoords, 0.);
                    hashSet.add(vertCoords);
                }
            }

            // The actual order will be some factor of maxPossibleOrder.
            // Try all possibilities, from big to little.
            for (int order = maxPossibleOrder; order >= 1; order--)
            {
                if (maxPossibleOrder % order != 0)
                    continue;
                //System.err.println("(Trying order "+order+"/"+maxPossibleOrder+")");
                double mat[][];
                {
                    // XXX should have VecMath.pow(double[][], int) that does it the smart way so it's only O(sqrt(n)) matrix multiplies
                    mat = VecMath.identitymat(nDims);
                    for (int i = 0; (i) < (maxPossibleOrder/order); ++i)
                        mat = VecMath.mxm(mat, maxPossibleOrderMat);
                }

                double scratchVert[] = new double[nDims];
                int iVert = 0;
                for (iVert = 0; (iVert) < (nVerts); ++iVert)
                {
                    double vertCoords[] = verts[iVert].getCoords();
                    while (vertCoords.length < nDims)
                        vertCoords = Arrays.append(vertCoords, 0.);
                    VecMath.vxm(scratchVert, vertCoords, mat);
                    if (!hashSet.contains(scratchVert))
                    {
                        //System.err.print("(HEY! order "+order+"/"+maxPossibleOrder+" didn't work!)");
                        break; // no good!
                    }
                }
                if (iVert == nVerts) // everything was good!
                {
                    return order; // everything was good!
                }
            }
            // order 1 should have succeeded, so we can't get here.
            // Actually we could have just returned 1 if all larger orders failed,
            // but we tested it anyway as a sanity check-- it better have succeeded.
            {System.out.print("        "); System.out.println("maxPossibleOrder" + " = " + (maxPossibleOrder));};
            do { if (!(false)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+5266 +"): " + "false" + ""); } while (false);
            return 1;
        } // calcRotationGroupOrder

        /**
        * DEPRECATED.  This is currently retained
        * as a backwards-compatibility shim for superliminal/magiccube4d,
        * until it updates to a new version of PolytopePuzzleDescription
        * that figures out usefulMat itself and calls calcRotationGroupOrder() directly.
        *
        * calculates the order of the group of symmetries
        * that are rotations in the 3-space containing cell3d,
        * about the axis through cell3d's center and subCell's center.
        * subCell's center must be different from cell3d's center
        * (which rules out some non-convex uniform polyhedra
        * that have faces or edges crossing the origin).
        *
        * returnUsefulMat is filled in with an orthogonal matrix
        * the last two rows of which are in the plane of the rotation.
        * So a rotation of any angle in that plane can be computed as:
        *        Take the rows of mat to the canonical basis vectors e[0]..e[n-1]
        *        rotate e[n-2] towards e[n-1]
        *        take the canonical basis vectors back to the original rows
        * I.e. rotMat = VecMath.mxmxm(VecMath.transpose(mat),
        *                             VecMath.makeRowRotMat(nDims,nDims-2,nDims-1, angle,
        *                             mat);
        * XXX isn't there a version of makeRowRotMat that does something like this?  check it out.  it looks overly complicated though, and assumes nDims==3 which is lame, should have a look at it
        *
        * Returns 0 when subCell is cell3d itself (and zeros out returnUselMat).
        */
        public static int calcRotationGroupOrderDEPRECATED(Polytope p,
                                                 Polytope cell3d,
                                                 Polytope subCell,
                                                 double returnUsefulMat[][])
        {
            int nDims = p.fullDim;
            do { if (!(cell3d.dim == 3)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+5302 +"): " + "cell3d.dim == 3" + ""); } while (false);

            Polytope cell3dAllElements[][] = cell3d.getAllElements();

            int maxPossibleOrder;
            {
                if (subCell.dim == 0)
                {
                    // number of edges in cell3d that are incident on this vertex
                    maxPossibleOrder = 0; // and counting
                    Polytope edges[] = cell3dAllElements[1];
                    for (int iEdge = 0; (iEdge) < (edges.length); ++iEdge)
                    {
                        Polytope edge = edges[iEdge];
                        for (int iVertOnEdge = 0; (iVertOnEdge) < (edge.facets.length); ++iVertOnEdge)
                            if (edge.facets[iVertOnEdge].p == subCell)
                                maxPossibleOrder++;
                    }
                }
                else if (subCell.dim == 1)
                    maxPossibleOrder = 2; // assumes two faces meet here, and two vertices
                else if (subCell.dim == 2)
                    maxPossibleOrder = subCell.facets.length; // gonality of the face
                else
                {
                    VecMath.zeromat(returnUsefulMat); // nothing better to do
                    return 0; // no rotation possible here at all
                }
            }

            // Figure out returnUsefulMat.
            {
                double pCenter[] = new double[nDims]; cgOfVerts(pCenter, p);
                double cell3dCenter[] = new double[nDims]; cgOfVerts(cell3dCenter, cell3d);
                double subCellCenter[] = new double[nDims]; cgOfVerts(subCellCenter, subCell);
                // Make the centers relative (so they are now vectors)
                VecMath.vmv(subCellCenter, subCellCenter, cell3dCenter);
                VecMath.vmv(cell3dCenter, cell3dCenter, pCenter);

                //
                // We want two orthogonal unit vectors
                // in the 3-space of cell3d
                // that are orthogonal to the line between
                // cell3d's center and CGsubCell's center.
                // We can get this by taking two random vectors
                // and gram-schmidting them against the normals
                // of all the hyperplanes defining cell3d's space,
                // and then against that line,
                // and then against each other.
                // XXX should try to do this without randomization!
                double mat[][] = new double[nDims][nDims];
                int iRow = 0;
                for (iRow = 0; (iRow) < (cell3d.contributingHyperplanes.length); ++iRow)
                    VecMath.copyvec(mat[iRow], cell3d.contributingHyperplanes[iRow].normal);
                VecMath.copyvec(mat[iRow++], subCellCenter);
                java.util.Random generator = new java.util.Random(3); // same every time
                VecMath.random(mat[iRow++], generator);
                VecMath.random(mat[iRow++], generator);
                do { if (!(iRow == mat.length)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+5360 +"): " + "iRow == mat.length" + ""); } while (false);
                if (VecMath.det(mat) < 0.)
                    VecMath.vxs(mat[mat.length-1], mat[mat.length-1], -1.);

                // Gram-Schmidt (XXX should be a function)
                {
                    for (int i = 0; (i) < (mat.length); ++i)
                    {
                        for (int j = 0; (j) < (i); ++j)
                        {
                            // mat[j] is already unit length...
                            // mat[i] -= (mat[i] dot mat[j])*mat[j]
                            VecMath.vpsxv(mat[i],
                                          mat[i],
                                          -VecMath.dot(mat[i],mat[j]),
                                          mat[j]);
                        }
                        VecMath.normalize(mat[i], mat[i]);
                    }
                }
                do { if (!(VecMath.det(mat) > .9)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+5380 +"): " + "VecMath.det(mat) > .9" + ""); } while (false); // should be 1

                VecMath.copymat(returnUsefulMat, mat);
            }

            return calcRotationGroupOrder(p, maxPossibleOrder, returnUsefulMat);
        } // calcRotationGroupOrderDEPRECATED



        // XXX comment me!!
        public static void calcDensity(SPolytope sp,
                                       double point[],
                                       double tol,
                                       int result[/*2*/]) // interval arithmetic
        {
            //System.out.println("    in calcDensity (dim="+sp.p.dim+")");
            Polytope p = sp.p;
            int dim = p.dim;

            if (dim == 0)
            {
                // XXX logically should probably be something else, but this will do for now...
                result[0] = 1;
                result[1] = 1;
                //System.out.println("    out calcDensity (dim="+sp.p.dim+"), returning "+result[0]+","+result[1]+"");
                return;
            }

            // dir = a random vector in the space spanned by this polytope.
            // We get it by taking all the plane normals,
            // augmenting by random vectors if necessary to get
            // dim-1 vectors, and taking the cross product.
            double dir[];
            {
                int nContributingHyperplanes = p.contributingHyperplanes.length;
                int fullDim = sp.p.fullDim;
                do { if (!(nContributingHyperplanes < fullDim)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+5417 +"): " + "nContributingHyperplanes < fullDim" + ""); } while (false);
                double M[][] = new double[fullDim-1][fullDim];
                int iRow;
                for (iRow = 0; (iRow) < (nContributingHyperplanes); ++iRow)
                    VecMath.copyvec(M[iRow], p.contributingHyperplanes[iRow].normal);
                for (; iRow < fullDim-1; ++iRow)
                    VecMath.random(M[iRow], randomGenerator);
                dir = VecMath.crossprod(M);
                VecMath.normalize(dir, dir); // XXX not necessary if we want to be clever
            }
            double pointDotDir = VecMath.dot(point, dir);

            int densityMin = sp.initialDensity; // and counting
            int densityMax = sp.initialDensity; // and counting

            if (p.dim == 1)
            {
                SPolytope vertices[] = p.facets;
                int nVertices = vertices.length;
                for (int iVertex = 0; (iVertex) < (nVertices); ++iVertex)
                {
                    SPolytope v = vertices[iVertex];
                    int a = 0, b = 0;
                    double vDotDir = VecMath.dot(v.p.getCoords(),
                                                 dir);

                    if ((((pointDotDir)-(vDotDir)) <= (tol)))
                        a = v.sign;
                    if ((((vDotDir)-(pointDotDir)) > (tol)))
                        b = v.sign;
                    if (a > b)
                    {
                        int temp;
                        {temp=(a);a=(b);b=(temp);};
                    }
                    densityMin += a;
                    densityMax += b;
                }
            }
            else
            {
                do { if (!(p.dim >= 2)) throw new Error("Assumption failed at "+"com/donhatchsw/util/CSG.prejava"+"("+5458 +"): " + "p.dim >= 2" + ""); } while (false); // XXX never ask for density of a point
                SPolytope facets[] = p.facets;
                int nFacets = facets.length;
                double qoint[] = new double[point.length]; // scratch for loop
                for (int iFacet = 0; (iFacet) < (nFacets); ++iFacet)
                {
                    SPolytope facet = facets[iFacet];

                    // We want qoint = intersection of point+t*dir with plane
                    //                   of the facet.
                    // So we want t such that
                    //          (point+t*dir) dot hyperplane.normal
                    //                          = hyperplane.offset
                    //          point dot hyperplane.normal + t*dir dot hyperplane.normal = hyperplane.offset
                    //  t = (hyperplane.offset - (point dot hyperplane.normal)) / (dir dot hyperplane.normal)
                    {
                        Hyperplane hyperplane = (Hyperplane)itemOfAThatsNotInB(facet.p.contributingHyperplanes, p.contributingHyperplanes);
                        double t = (hyperplane.offset - VecMath.dot(point, hyperplane.normal)) / VecMath.dot(dir, hyperplane.normal);
                        VecMath.vpsxv(qoint, point, t, dir);
                    }

                    double qointDotDir = VecMath.dot(qoint, dir);

                    int a = 0, b = 0;
                    if ((((pointDotDir)-(qointDotDir)) <= (tol)))
                        a = facet.sign;
                    if ((((qointDotDir)-(pointDotDir)) > (tol)))
                        b = facet.sign;
                    if (a > b)
                    {
                        int temp;
                        {temp=(a);a=(b);b=(temp);};
                    }

                    if (verboseLevel >= 2 && a != b)
                    {
                        System.out.println("uh oh,,,,,,,,,,,,,,,,,,,,,,,,,,");
                        {System.out.print("        "); System.out.println("p" + " = " + (p));};
                        System.out.println("        " + "point" + " = " + VecMath.toString(point));
                        System.out.println("        " + "qoint" + " = " + VecMath.toString(qoint));
                        {System.out.print("        "); System.out.println("a" + " = " + (a));};
                        {System.out.print("        "); System.out.println("b" + " = " + (b));};
                    }
                    if (a != 0 || b != 0)
                    {
                        calcDensity(facet, qoint, tol, result); // using result as temporary
                        densityMin += a * result[0];
                        densityMax += b * result[1];
                    }
                }
            }

            if (verboseLevel >= 2 && densityMin != densityMax)
            {
                System.out.println("Uh oh................");
                {System.out.print("        "); System.out.println("p" + " = " + (p));};
                System.out.println("        " + "point" + " = " + VecMath.toString(point));
                {System.out.print("        "); System.out.println("densityMin" + " = " + (densityMin));};
                {System.out.print("        "); System.out.println("densityMax" + " = " + (densityMax));};
            }

            result[0] = densityMin;
            result[1] = densityMax;

            //System.out.println("    out calcDensity (dim="+sp.p.dim+"), returning "+result[0]+","+result[1]+"");
        } // calcDensity


         // simplicallySubdivide
        private static double[/*nSimplices*/][/*k+1*/][/*n*/] simpliciallySubdivide(Polytope p)
        {
            int k = p.dim;
            int n = p.fullDim;

            if (k == 0)
            {
                return new double[][][] {
                    {p.getCoords()},
                };
            }
            if (p.facets.length == 0)
            {
                return new double[0][k+1][n];
            }


            Polytope v0; // first vertex
            {
                v0 = p;
                while (v0.dim > 0)
                    v0 = v0.facets[0].p;
            }
            double v0coords[] = v0.getCoords();

            java.util.ArrayList<double[][]> simplicesList = new java.util.ArrayList<double[][]>();
            {
                SPolytope facets[] = p.facets;
                int nFacets = facets.length;
                double simplex[][] = new double[k+1][/*n*/];

                if (k == 1) // XXX this case is not really necessary, but it is optimized a bit
                {
                    for (int iFacet = 0; (iFacet) < (nFacets); ++iFacet)
                    {
                        if (iFacet == 0)
                            continue;
                        SPolytope facet = facets[iFacet];
                        simplex[0] = v0coords;
                        simplex[1] = facet.p.getCoords();
                        if (facet.sign < 0)
                        {
                            // swap last two vertices on the simplex.
                            double temp[];
                            {temp=(simplex[k-1]);simplex[k-1]=(simplex[k]);simplex[k]=(temp);};
                        }
                        for (int i = (((facet.sign) < 0 ? -(facet.sign) : (facet.sign)))-1; (i) >= 0; --i)
                            simplicesList.add(VecMath.copymat(simplex));
                    }
                }
                else // k > 1
                {

                    for (int iFacet = 0; (iFacet) < (nFacets); ++iFacet)
                    {
                        if (iFacet == 0)
                            continue; // facet 0 definitely contains v0
                        SPolytope facet = facets[iFacet];
                        if (contains(facet.p, v0))
                            continue;
                        double facetSimplices[][][] = simpliciallySubdivide(facet.p);
                        int nFacetSimplices = facetSimplices.length;
                        for (int iFacetSimplex = 0; (iFacetSimplex) < (nFacetSimplices); ++iFacetSimplex)
                        {
                            simplex[0] = v0coords;
                            System.arraycopy(facetSimplices[iFacetSimplex], 0,
                                             simplex, 1,
                                             k);
                            if (facet.sign < 0)
                            {
                                // swap last two vertices on the simplex.
                                double temp[];
                                {temp=(simplex[k-1]);simplex[k-1]=(simplex[k]);simplex[k]=(temp);};
                            }
                            for (int i = (((facet.sign) < 0 ? -(facet.sign) : (facet.sign)))-1; (i) >= 0; --i)
                                simplicesList.add(VecMath.copymat(simplex));
                        }
                    }
                }
            }
            double array[][][] = new double[simplicesList.size()][k+1][n];
            simplicesList.toArray(array);
            return array;
        } // simplicallySubdivide

        /**
        * This will be the actual (signed) volume
        * if all the hyperplanes are orthogonal and unit length
        * (which includes the case when there are no hyperplanes,
        * i.e. when sp.p.dim is the full dimension of the space).
        * Otherwise it will be scaled by the volume
        * of the parallelepiped spanned by those normals.
        */
        public static double volume(SPolytope sp)
        {
            int nNormals = sp.p.contributingHyperplanes.length;
            double simplices[][][] = simpliciallySubdivide(sp.p);
            int nSimplices = simplices.length;
            if (nSimplices == 0)
                return 0.;
            int k = simplices[0].length-1; // dimension of each simplex
            int n = simplices[0][0].length; // full dimension of space

            do { if (!((sp.p.dim)==(k))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+5630 +"): (" + "sp.p.dim" + ")" + "==" + "(" + "k" + ") ("+(sp.p.dim)+" vs. "+(k)+")"); } while (false);
            do { if (!((sp.p.fullDim)==(n))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+5631 +"): (" + "sp.p.fullDim" + ")" + "==" + "(" + "n" + ") ("+(sp.p.fullDim)+" vs. "+(n)+")"); } while (false);
            int nNonRedundantNormals = n-k;
            do { if (!(nNonRedundantNormals <= nNormals)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+5633 +"): " + "nNonRedundantNormals <= nNormals" + ""); } while (false);
            double sum = 0.;
            double M[][] = new double[n][n];
            for (int iSimplex = 0; (iSimplex) < (nSimplices); ++iSimplex)
            {
                double simplex[][] = simplices[iSimplex];
                for (int iRow = 0; (iRow) < (k); ++iRow)
                    VecMath.vmv(M[iRow], simplex[iRow+1], simplex[0]);
                for (int iNormal = 0; (iNormal) < (nNonRedundantNormals); ++iNormal) // XXX just takes the first nNonRedundantNormals normals... is this what we want?  should we be doing something smarter?  test using {3,3,3,4}.  hopefully the nonequal case only occurs when we only care about the sign of the volume (i.e. when called from orientFacetsConsistently)... but then what the hell are we doing down in here anyway? hmm.
                    VecMath.copyvec(M[k+iNormal],
                                    sp.p.contributingHyperplanes[iNormal].normal);
                sum += VecMath.detDestructive(M);
            }
            return sum * sp.sign / factorial(k);
        } // volume

        /**
        * Get the normal of the n-1-dimensional polytope sp,
        * with length equal to the hyper-area of sp.
        * Uses the vertices but not the hyperplanes,
        * so can be used to build the hyperplanes
        * if only the vertices are known.
        */
        private static void areaNormal(double result[], SPolytope sp)
        {
            VecMath.zerovec(result);
            double simplices[][][] = simpliciallySubdivide(sp.p);
            int nSimplices = simplices.length;
            if (nSimplices == 0)
                return;
            int k = simplices[0].length-1; // dimension of each simplex
            int n = simplices[0][0].length; // full dimension of space
            do { if (!((k)==(sp.p.dim))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+5665 +"): (" + "k" + ")" + "==" + "(" + "sp.p.dim" + ") ("+(k)+" vs. "+(sp.p.dim)+")"); } while (false);

            do { if (!((k)==(n-1))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+5667 +"): (" + "k" + ")" + "==" + "(" + "n-1" + ") ("+(k)+" vs. "+(n-1)+")"); } while (false);
            do { if (!((result.length)==(n))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+5668 +"): (" + "result.length" + ")" + "==" + "(" + "n" + ") ("+(result.length)+" vs. "+(n)+")"); } while (false); // make sure they passed in the right dimension result
            double M[][] = new double[k][n];
            double simplexNormal[] = new double[n];
            for (int iSimplex = 0; (iSimplex) < (nSimplices); ++iSimplex)
            {
                double simplex[][] = simplices[iSimplex];
                for (int iRow = 0; (iRow) < (k); ++iRow)
                    VecMath.vmv(M[iRow], simplex[iRow+1], simplex[0]);
                VecMath.crossprod(simplexNormal, M);
                VecMath.vpv(result, result, simplexNormal);
            }
            VecMath.vxs(result, result, (double)sp.sign/(double)factorial(k));
        } // areaNormal

        /**
        * returns the centroid (average) of the vertices of p
        * into an array supplied by the caller.
        */
        public static void cgOfVerts(double result[], Polytope p)
        {
            Polytope vertPolytopes[] = p.getAllElements()[0];
            VecMath.zerovec(result);
            for (int i = 0; (i) < (vertPolytopes.length); ++i)
                VecMath.vpv(result, result, vertPolytopes[i].getCoords());
            do { if (!(vertPolytopes.length != 0)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+5692 +"): " + "vertPolytopes.length != 0" + ""); } while (false);
            VecMath.vxs(result, result, 1./vertPolytopes.length);
        } // cgOfVerts

        /**
        * returns the centroid (average) of the vertices of p
        * as a newly allocated double[].
        */
        public static double[] cgOfVerts(Polytope p)
        {
            double result[] = new double[p.fullDim];
            cgOfVerts(result, p);
            return result;
        } // cgOfVerts

        public static double[][] covarianceOfVerts(Polytope p, double[] origin)
        {
            Polytope vertPolytopes[] = p.getAllElements()[0];
            // TODO: which method do I like here?
            if (true)
            {
                double[][] answer = new double[p.fullDim][p.fullDim]; // zeros initially
                if (origin == null)
                {
                    for (int i = 0; (i) < (vertPolytopes.length); ++i)
                    {
                        double[] vertCoords = vertPolytopes[i].getCoords();
                        VecMath.mpouterProduct(answer, answer, vertCoords, vertCoords);
                    }
                }
                else
                {
                    double[] vertCoords_minus_origin = new double[p.fullDim];
                    for (int i = 0; (i) < (vertPolytopes.length); ++i)
                    {
                        VecMath.vmv(vertCoords_minus_origin, vertPolytopes[i].getCoords(), origin);
                        VecMath.mpouterProduct(answer, answer, vertCoords_minus_origin, vertCoords_minus_origin);
                    }
                }
                return answer;
            }
            else
            {
                // alternatively, could take the sum of the outer product of each vertex with itself
                double[][] verts = new double[vertPolytopes.length][p.fullDim];
                for (int i = 0; (i) < (vertPolytopes.length); ++i)
                    VecMath.copyvec(verts[i], vertPolytopes[i].getCoords());
                if (origin != null) VecMath.mmv(verts, verts, origin);
                return VecMath.mxm(VecMath.transpose(verts), verts);
            }
        } // covarianceOfVerts

        public static double[][] covarianceOfVertsAboutCG(Polytope p)
        {
            return covarianceOfVerts(p, cgOfVerts(p));
        } // covarianceOfVertsAboutCG

        /**
        * See discussion of (products and) joins in https://en.wikipedia.org/wiki/Schl%C3%A4fli_symbol#Prismatic_polytopes .
        * TODO: that wikipedia page also supports bipyramids; support those too!
        */
        public static SPolytope join(SPolytope A,
                                     SPolytope B)
        {
            int verboseLevel = 0;
            if (verboseLevel >= 1) System.out.println("in join");
            // Choose y (joining axis) positions for A and B
            // according to their numbers of vertices,
            // so the join will have its cg-of-verts at y=0.
            // TODO: think about whether to make special cases so that the triangle {}x()
            // and the pyramids 3x(), 4x(), 5x() come out with regular triangles...
            // and also so that, in general, simplices will come out regular.
            int nA = A.p.getAllElements()[0].length;
            int nB = B.p.getAllElements()[0].length;
            do { if (!((nA)>(0))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+5766 +"): (" + "nA" + ")" + ">" + "(" + "0" + ") ("+(nA)+" vs. "+(0)+")"); } while (false);
            do { if (!((nB)>(0))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+5767 +"): (" + "nB" + ")" + ">" + "(" + "0" + ") ("+(nB)+" vs. "+(0)+")"); } while (false);
            double y0 = -2.*nB/(nA+nB);
            double y1 = 2.*nA/(nA+nB);
            if (verboseLevel >= 1) {System.out.print("        "); System.out.println("y0" + " = " + (y0));};
            if (verboseLevel >= 1) {System.out.print("        "); System.out.println("y1" + " = " + (y1));};

            // Choose y scale so that final covariance
            // will be as uniform as possible.
            if (A.p.fullDim + B.p.fullDim + 1 > 1) // otherwise there's nothing to scale it to; just leave it
            {
                int AfullDim = A.p.fullDim;
                int BfullDim = B.p.fullDim;
                Polytope AvertPolytopes[] = A.p.getAllElements()[0];
                Polytope BvertPolytopes[] = B.p.getAllElements()[0];
                int yIndex = AfullDim;

                double[][] expectedVerts = new double[nA + nB][AfullDim + 1 + BfullDim]; // all zeros initially
                for (int iA = 0; iA < nA; ++iA)
                {
                    System.arraycopy(AvertPolytopes[iA].getCoords(), 0,
                                     expectedVerts[iA], 0,
                                     AfullDim);
                    expectedVerts[iA][yIndex] = y0;
                }
                for (int iB = 0; iB < nB; ++iB)
                {
                    expectedVerts[nA+iB][yIndex] = y1;
                    System.arraycopy(BvertPolytopes[iB].getCoords(), 0,
                                     expectedVerts[nA+iB], yIndex+1,
                                     BfullDim);
                }
                double[][] covariance = VecMath.mxm(VecMath.transpose(expectedVerts), expectedVerts);
                if (verboseLevel >= 1) System.out.println("        " + "covariance" + " = " + Arrays.toStringCompact(covariance));
                double det = VecMath.det(covariance);
                if (verboseLevel >= 1) System.out.println("        " + "det" + " = " + Arrays.toStringCompact(det));
                double yvariance = covariance[yIndex][yIndex];
                if (verboseLevel >= 1) {System.out.print("        "); System.out.println("yvariance" + " = " + (yvariance));};
                double productOfOtherVariances = det / yvariance;
                if (verboseLevel >= 1) {System.out.print("        "); System.out.println("productOfOtherVariances" + " = " + (productOfOtherVariances));};
                double yvarianceTarget = Math.pow(productOfOtherVariances, 1./(covariance.length-1)); // this is where we'd fail if fullDim is only 1
                if (verboseLevel >= 1) {System.out.print("        "); System.out.println("yvarianceTarget" + " = " + (yvarianceTarget));};
                double yscale = Math.sqrt(yvarianceTarget / yvariance);
                if (verboseLevel >= 1) {System.out.print("        "); System.out.println("yscale" + " = " + (yscale));};
                y0 *= yscale;
                y1 *= yscale;
                double[][] yscaleMat = VecMath.identitymat(covariance.length);
                for (int i = 0; i < expectedVerts.length; ++i) expectedVerts[i][yIndex] *= yscale;
                // now do it again, corrected
                covariance = VecMath.mxm(VecMath.transpose(expectedVerts), expectedVerts);
                if (verboseLevel >= 1) System.out.println("        " + "covariance" + " = " + Arrays.toStringCompact(covariance));
                det = VecMath.det(covariance);
                if (verboseLevel >= 1) System.out.println("        " + "det" + " = " + Arrays.toStringCompact(det));
                yvariance = covariance[yIndex][yIndex];
                if (verboseLevel >= 1) {System.out.print("        "); System.out.println("yvariance" + " = " + (yvariance));};
                productOfOtherVariances = det / yvariance;
                if (verboseLevel >= 1) {System.out.print("        "); System.out.println("productOfOtherVariances" + " = " + (productOfOtherVariances));};
                yvarianceTarget = Math.pow(productOfOtherVariances, 1./(covariance.length-1)); // this is where we'd fail if fullDim is only 1
                if (verboseLevel >= 1) {System.out.print("        "); System.out.println("yvarianceTarget" + " = " + (yvarianceTarget));};
                yscale = Math.sqrt(yvarianceTarget / yvariance);
                if (verboseLevel >= 1) {System.out.print("        "); System.out.println("yscale" + " = " + (yscale));};
                do { if (!((yscale)==(1.)||Math.abs((yscale)-(1.))<=1e-6)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+5827 +"): " +"(" + "yscale" + ")==(" + "1." + ")+-" + "1e-6" + "" +" ("+(yscale)+" vs. "+(1.)+" +- "+(1e-6)+")" +" (error = "+((yscale)-(1.))+")" ); } while (false);
            }
            {System.out.print("        "); System.out.println("y0" + " = " + (y0));};
            {System.out.print("        "); System.out.println("y1" + " = " + (y1));};

            Polytope p = _join(A.p, A.p.fullDim, y0,
                               B.p, B.p.fullDim, y1,
                               /*ocean=*/new java.util.HashMap<HashablePair,Polytope>(),
                               /*indentString=*/"        ");
            // The vertices of p should now be:
            //     - for each vertex a of A: (   a,    y0, 0,...,0)
            //     - for each vertex b of B: (0,...,0, y1,    b   )
            // As a simple sanity check, we just check that the bounding box is right.
            // CBB: could do full check of all vertices
            {
                double[][] bboxA = A.p.getBBox();
                double[][] bboxB = B.p.getBBox();
                double[][] bbox = p.getBBox();
                int yIndex = A.p.fullDim;
                for (int i = 0; i < A.p.fullDim; ++i)
                {
                    do { if (!((bbox[0][i])==(bboxA[0][i])||Math.abs((bbox[0][i])-(bboxA[0][i]))<=1e-6)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+5848 +"): " +"(" + "bbox[0][i]" + ")==(" + "bboxA[0][i]" + ")+-" + "1e-6" + "" +" ("+(bbox[0][i])+" vs. "+(bboxA[0][i])+" +- "+(1e-6)+")" +" (error = "+((bbox[0][i])-(bboxA[0][i]))+")" ); } while (false);
                    do { if (!((bbox[1][i])==(bboxA[1][i])||Math.abs((bbox[1][i])-(bboxA[1][i]))<=1e-6)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+5849 +"): " +"(" + "bbox[1][i]" + ")==(" + "bboxA[1][i]" + ")+-" + "1e-6" + "" +" ("+(bbox[1][i])+" vs. "+(bboxA[1][i])+" +- "+(1e-6)+")" +" (error = "+((bbox[1][i])-(bboxA[1][i]))+")" ); } while (false);
                }
                do { if (!((bbox[0][yIndex])==(((y0)<=(y1)?(y0):(y1)))||Math.abs((bbox[0][yIndex])-(((y0)<=(y1)?(y0):(y1))))<=1e-6)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+5851 +"): " +"(" + "bbox[0][yIndex]" + ")==(" + "MIN(y0, y1)" + ")+-" + "1e-6" + "" +" ("+(bbox[0][yIndex])+" vs. "+(((y0)<=(y1)?(y0):(y1)))+" +- "+(1e-6)+")" +" (error = "+((bbox[0][yIndex])-(((y0)<=(y1)?(y0):(y1))))+")" ); } while (false);
                do { if (!((bbox[1][yIndex])==(((y0)>=(y1)?(y0):(y1)))||Math.abs((bbox[1][yIndex])-(((y0)>=(y1)?(y0):(y1))))<=1e-6)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+5852 +"): " +"(" + "bbox[1][yIndex]" + ")==(" + "MAX(y0, y1)" + ")+-" + "1e-6" + "" +" ("+(bbox[1][yIndex])+" vs. "+(((y0)>=(y1)?(y0):(y1)))+" +- "+(1e-6)+")" +" (error = "+((bbox[1][yIndex])-(((y0)>=(y1)?(y0):(y1))))+")" ); } while (false);
                for (int i = 0; i < B.p.fullDim; ++i)
                {
                    do { if (!((bbox[0][yIndex+1+i])==(bboxB[0][i])||Math.abs((bbox[0][yIndex+1+i])-(bboxB[0][i]))<=1e-6)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+5855 +"): " +"(" + "bbox[0][yIndex+1+i]" + ")==(" + "bboxB[0][i]" + ")+-" + "1e-6" + "" +" ("+(bbox[0][yIndex+1+i])+" vs. "+(bboxB[0][i])+" +- "+(1e-6)+")" +" (error = "+((bbox[0][yIndex+1+i])-(bboxB[0][i]))+")" ); } while (false);
                    do { if (!((bbox[1][yIndex+1+i])==(bboxB[1][i])||Math.abs((bbox[1][yIndex+1+i])-(bboxB[1][i]))<=1e-6)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+5856 +"): " +"(" + "bbox[1][yIndex+1+i]" + ")==(" + "bboxB[1][i]" + ")+-" + "1e-6" + "" +" ("+(bbox[1][yIndex+1+i])+" vs. "+(bboxB[1][i])+" +- "+(1e-6)+")" +" (error = "+((bbox[1][yIndex+1+i])-(bboxB[1][i]))+")" ); } while (false);
                }
            }

            if (true)
            {
                // I'm interested in the covariance ellipse of the result.
                double[][] Acovariance = covarianceOfVertsAboutCG(A.p);
                double[][] Bcovariance = covarianceOfVertsAboutCG(B.p);
                double[][] covariance = covarianceOfVertsAboutCG(p);
                System.out.println("        " + "Acovariance" + " = " + Arrays.toStringCompact(Acovariance));
                System.out.println("        " + "Bcovariance" + " = " + Arrays.toStringCompact(Bcovariance));
                System.out.println("        " + "covariance" + " = " + Arrays.toStringCompact(covariance));
            }

            SPolytope sp = new SPolytope(A.initialDensity*B.initialDensity, // probably meaningless
                                         A.sign*B.sign, // probably meaningless
                                         p);
            orientDeepFunctional(sp);
            orientDeepCosmetic(sp);
            //System.out.println("join returning sp =\n"+sp);
            if (verboseLevel >= 1) System.out.println("out join");
            return sp;
        } // join

        // recursive work function used by join().
        // doesn't even try to get the signs right.
        // Simple recursive definition:
        //   AvB.facets = [avB for a in A.facets] union [Avb for b in B.facets]
        // where a point is taken to have one null facet, null has no facets,
        // and the following base cases:
        //   (point A in AfullDim) v (null polytope in BfullDim)  is A's coords padded on the right with <y0,0,...,0> (BfullDim 0's)
        //   (null polytope in AfullDim) v (point B in BfullDim)  is B's coords padded on the left with <0,...,0,y1> (AfullDim 0's)
        // Hyperplanes are padded out intelligently, whatever that means.
        // TODO: reexamine this description as soon as I fumble through to success
        private static Polytope _join(Polytope A, int AfullDim, double y0,
                                      Polytope B, int BfullDim, double y1,
                                      java.util.HashMap<HashablePair,Polytope> ocean, // hashtable of crossings already done
                                      String indentString) // for debugging
        {
            int verboseLevel = 0;
            String subIndentString = null;
            if (verboseLevel >= 1)
            {
                System.out.println(indentString+"in CSG._join("+(A==null?-1:A.dim)+"/"+AfullDim+" x "+(B==null?-1:B.dim)+"/"+BfullDim+")");
                subIndentString = indentString + "        ";
            }
            if (verboseLevel >= 1) if (A==null||A.dim==0) System.out.println(indentString+"  A="+A);
            if (verboseLevel >= 1) if (B==null||B.dim==0) System.out.println(indentString+"  B="+B);

            do { if (!(A!=null || B!=null)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+5906 +"): " + "A!=null || B!=null" + ""); } while (false);
            HashablePair key = new HashablePair(A, B);
            Polytope AvB = ocean.get(key);
            if (AvB == null)
            {
                int fullDim = AfullDim + BfullDim + 1;
                int Adim = A==null ? -1 : A.dim;
                int Bdim = B==null ? -1 : B.dim;
                int dim = Adim + Bdim + 1;
                int nFacetsA = A==null ? 0 : A.dim==0 ? 1 : A.facets.length; // override when dim=0 to have 1 facet instead of 0
                int nFacetsB = B==null ? 0 : B.dim==0 ? 1 : B.facets.length; // override when dim=0 to have 1 facet instead of 0
                int nFacets = nFacetsA + nFacetsB;
                if (dim == 0)
                {
                    // a vertex logically has one facet-- the null polytope, of dimension -1,
                    // but our convention is to give it no facets.
                    do { if (!((nFacets)==(1))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+5922 +"): (" + "nFacets" + ")" + "==" + "(" + "1" + ") ("+(nFacets)+" vs. "+(1)+")"); } while (false);
                    nFacets = 0;
                }
                SPolytope[] facets = new SPolytope[nFacets];
                if (nFacets > 0) // need this because of the special case for dim==0
                {
                    if (verboseLevel >= 1) System.out.println(indentString+"  computing facets avB for each facet a of A...");
                    for (int iFacetA = 0; iFacetA < nFacetsA; ++iFacetA)
                    {
                        Polytope a = A.dim==0 ? null : A.facets[iFacetA].p;
                        // append avB to facets
                        facets[iFacetA] = new SPolytope(0,1, _join(a, AfullDim, y0, B, BfullDim, y1, ocean, subIndentString));
                    }
                    if (verboseLevel >= 1) System.out.println(indentString+"  computing facets Avb for each facet b of B...");
                    for (int iFacetB = 0; iFacetB < nFacetsB; ++iFacetB)
                    {
                        Polytope b = B.dim==0 ? null : B.facets[iFacetB].p;
                        // append Avb to facets
                        facets[nFacetsA+iFacetB] = new SPolytope(0,1, _join(A, AfullDim, y0, b, BfullDim, y1, ocean, subIndentString));
                    }
                }
                //Hyperplane[] contributingHyperplanes = new Hyperplane[fullDim - dim];  // doesn't work for {3,4}v(). TODO: get clear on why.  a vertex in 3 dimensions with 4 contributing hyperplanes? maybe.
                Hyperplane[] contributingHyperplanes = new Hyperplane[(A==null ? AfullDim+1 : A.contributingHyperplanes.length)
                                                                    + (B==null ? BfullDim+1 : B.contributingHyperplanes.length)];
                {
                    if (contributingHyperplanes.length != fullDim - dim) {
                        if (verboseLevel >= 1) {
                            // Ah, I get it now.
                            System.out.println("  Hey! number of contributing hyperplanes is a bit surprising! (some vertex figure must not be a simplex)");
                            int AcontributingHyperplanesLength = A==null ? AfullDim+1 : A.contributingHyperplanes.length;
                            int BcontributingHyperplanesLength = B==null ? BfullDim+1 : B.contributingHyperplanes.length;
                            System.out.println("      AfullDim="+AfullDim+" - Adim="+Adim+" = "+(AfullDim-Adim)+" "+(AfullDim-Adim==AcontributingHyperplanesLength ? "==" : "!=")+" "+AcontributingHyperplanesLength+"=AcontributingHyperplanesLength");
                            System.out.println("      BfullDim="+BfullDim+" - Bdim="+Bdim+" = "+(BfullDim-Bdim)+" "+(BfullDim-Bdim==BcontributingHyperplanesLength ? "==" : "!=")+" "+BcontributingHyperplanesLength+"=BcontributingHyperplanesLength");
                            System.out.println("    => fullDim="+ fullDim+" -  dim="+ dim+" = "+( fullDim- dim)+" "+(fullDim-dim==contributingHyperplanes.length ? "==" : "!=")+" "+contributingHyperplanes.length+"=contributingHyperplanes.length");
                        }
                    }
                    if (verboseLevel >= 1) System.out.println(indentString+"  computing hyperplanes...");
                    do { if (!((y0)!=(y1))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+5959 +"): (" + "y0" + ")" + "!=" + "(" + "y1" + ") ("+(y0)+" vs. "+(y1)+")"); } while (false);

                    // For each of A's hyperplanes, lean it against the entire BfullDim space at y=y1.
                    // For each of B's hyperplanes, lean it against the entire AfullDim space at y=y0.

                    int iPlane = 0;
                    if (A == null)
                    {
                        if (verboseLevel >= 1) System.out.println(indentString+"      the A==null case: adding AfullDim+1="+(AfullDim+1)+" hyperplanes");
                        // Add hyperplanes to express the entire BfullDim space at y=y1.
                        // That is, hyperplanes that say that each of the first AfullDim coords are 0, and y=y1.
                        int yIndex = AfullDim;
                        for (int i = 0; i < yIndex+1; ++i)
                        {
                            double[] normal = new double[fullDim];
                            normal[i] = 1.;
                            double offset = (i==yIndex ? y1 : 0.);
                            // CBB: for some reason PolytopePuzzleDescription likes all offsets to be positive, bleah
                            if (offset < 0.)
                            {
                                normal[i] *= -1.;
                                offset *= -1.;
                            }
                            contributingHyperplanes[iPlane++] = new Hyperplane(normal, offset);
                        }
                    }
                    else
                    {
                        if (verboseLevel >= 1) System.out.println(indentString+"      the A!=null case: adding A.contributingHyperplanes.length="+A.contributingHyperplanes.length+" hyperplanes");
                        for (int iPlaneA = 0; (iPlaneA) < (A.contributingHyperplanes.length); ++iPlaneA)
                        {
                            Hyperplane a = A.contributingHyperplanes[iPlaneA];
                            // Lean a at y=y0 against the entire BfullDimSpace at y=y1.
                            // hyperplane.normal will be (a.normal, Y, 0,...,0) for some scalar Y,
                            // and the hyperplane.offset will be some scalar C such that:
                            //     (a.normal, Y, 0,...,0) dot (A, y0, 0,...,0) == C
                            //     (a.normal, Y, 0,...,0) dot (0, y1, 0,...,0) == C
                            // so we want to solve:
                            //     (a.normal dot A) + Y*y0 == C
                            //                        Y*y1 == C
                            // We know a.normal dot A == a.offset, call that c. So we want:
                            //     c + Y*y0 == C
                            //         Y*y1 == C
                            // so:
                            //     Y = c/(y1-y0)
                            //     C = Y*y1;
                            double c = a.offset;
                            double Y = c/(y1-y0);
                            double C = Y*y1;
                            if (verboseLevel >= 1) {System.out.print("        "); System.out.println("Y" + " = " + (Y));};
                            if (verboseLevel >= 1) {System.out.print("        "); System.out.println("C" + " = " + (C));};
                            double[] normal = new double[fullDim]; // zeros initially
                            System.arraycopy(a.normal, 0, normal, 0, AfullDim);
                            normal[AfullDim] = Y;
                            double offset = C;
                            // XXX need to look up a_padded in the ocean to see if it already exists! although it's probably not a functional problem if hyperplane lists get duplicated... maybe
                            contributingHyperplanes[iPlane++] = new Hyperplane(normal, offset);
                        }
                    }
                    if (B == null)
                    {
                        if (verboseLevel >= 1) System.out.println(indentString+"      the B==null case: adding BfullDim+1="+(BfullDim+1)+" hyperplanes");
                        // Add hyperplanes to express the entire AfullDim space at y=y0.
                        // That is, hyperplanes that say that y=y0 and each of the last BfullDim coords are 0.
                        int yIndex = AfullDim;
                        for (int i = yIndex; i < fullDim; ++i)
                        {
                            double[] normal = new double[fullDim];
                            normal[i] = 1.;
                            double offset = (i==yIndex ? y0 : 0.);
                            // CBB: for some reason PolytopePuzzleDescription likes all offsets to be positive, bleah
                            if (offset < 0.)
                            {
                                normal[i] *= -1.;
                                offset *= -1.;
                            }
                            contributingHyperplanes[iPlane++] = new Hyperplane(normal, offset); // XXX currently fails on "{3,4}v()"
                        }
                    }
                    else
                    {
                        if (verboseLevel >= 1) System.out.println(indentString+"      the B!=null case: adding B.contributingHyperplanes.length="+B.contributingHyperplanes.length+" hyperplanes");
                        for (int iPlaneB = 0; (iPlaneB) < (B.contributingHyperplanes.length); ++iPlaneB)
                        {
                            // Same logic as above for A's contributing hyperplanes, just reverse everything
                            Hyperplane b = B.contributingHyperplanes[iPlaneB];
                            double c = b.offset;
                            double Y = c/(y0-y1);
                            double C = Y*y0;
                            if (verboseLevel >= 1) {System.out.print("        "); System.out.println("Y" + " = " + (Y));};
                            if (verboseLevel >= 1) {System.out.print("        "); System.out.println("C" + " = " + (C));};
                            double[] normal = new double[fullDim]; // zeros initially
                            normal[AfullDim] = Y;
                            double offset = C;
                            System.arraycopy(b.normal, 0, normal, AfullDim+1, BfullDim);
                            // XXX need to look up padded_b in the ocean to see if it already exists! although it's probably not a functional problem if hyperplane lists get duplicated... maybe
                            contributingHyperplanes[iPlane++] = new Hyperplane(normal, offset);
                        }
                    }
                    do { if (!((iPlane)==(contributingHyperplanes.length))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+6058 +"): (" + "iPlane" + ")" + "==" + "(" + "contributingHyperplanes.length" + ") ("+(iPlane)+" vs. "+(contributingHyperplanes.length)+")"); } while (false);
                }
                AvB = new Polytope(dim,
                                   fullDim,
                                   facets,
                                   contributingHyperplanes,
                                   null); // loses aux
                ocean.put(key, AvB);
            }
            else
            {
                if (verboseLevel >= 1) System.out.println(indentString+"  (cache hit)");
            }
            if (verboseLevel >= 1) System.out.println(indentString+"out CSG._join("+(A==null?-1:A.dim)+"/"+AfullDim+" x "+(B==null?-1:B.dim)+"/"+BfullDim+")");
            return AvB;
        } // _join


        public static SPolytope cross(SPolytope A,
                                      SPolytope B)
        {
            SPolytope AB = new SPolytope(A.initialDensity*B.initialDensity,
                                         A.sign*B.sign,
                                         _cross(A.p,
                                                B.p,
                                                /*ocean=*/new java.util.HashMap<HashablePair,Polytope>(),
                                                ""));

            // If I was smart, _cross would simply get the signs right
            // as it goes.  Something like,
            // negate everything whose dimensional contribution
            // from C is odd...
            // But I have never been able to figure it out.
            // So, just orient after the fact.  Sigh.
            //
            if (true)
            {
                orientDeepFunctional(AB);
                orientDeepCosmetic(AB);
            }

            return AB;
        } // cross

        // recursive work function used by cross().
        // doesn't even try to get the signs right.
        private static Polytope _cross(Polytope A,
                                       Polytope B,
                                       java.util.HashMap<HashablePair,Polytope> ocean, // hashtable of crossings already done
                                       String indentString) // for debugging
        {
            String subIndentString = null;
            if (verboseLevel >= 1)
            {
                System.out.println(indentString+"in CSG._cross("+A.dim+"/"+A.fullDim+" x "+B.dim+"/"+B.fullDim+")");
                subIndentString = indentString + "        ";
            }
            HashablePair key = new HashablePair(A, B);
            Polytope AB = ocean.get(key);
            if (AB == null)
            {
                SPolytope facets[] = new SPolytope[A.facets.length + B.facets.length];
                {
                    int iFacet = 0;
                    for (int iFacetA = 0; (iFacetA) < (A.facets.length); ++iFacetA)
                    {
                        Polytope a = A.facets[iFacetA].p;
                        Polytope aB = _cross(a, B, ocean, subIndentString);
                        facets[iFacet++] = new SPolytope(0,1,aB); // sign arbitrary, will be fixed later
                    }
                    for (int iFacetB = 0; (iFacetB) < (B.facets.length); ++iFacetB)
                    {
                        Polytope b = B.facets[iFacetB].p;
                        Polytope Ab = _cross(A, b, ocean, subIndentString);
                        facets[iFacet++] = new SPolytope(0,1,Ab); // sign arbitrary, will be fixed later
                    }
                    do { if (!((iFacet)==(facets.length))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+6134 +"): (" + "iFacet" + ")" + "==" + "(" + "facets.length" + ") ("+(iFacet)+" vs. "+(facets.length)+")"); } while (false);
                }

                Hyperplane contributingHyperplanes[] = new Hyperplane[A.contributingHyperplanes.length + B.contributingHyperplanes.length];
                {

                    double leftZero[] = new double[A.fullDim];
                    double rightZero[] = new double[B.fullDim];

                    int iPlane = 0;

                    for (int iPlaneA = 0; (iPlaneA) < (A.contributingHyperplanes.length); ++iPlaneA)
                    {
                        Hyperplane a = A.contributingHyperplanes[iPlaneA];
                        Hyperplane a_zero = new Hyperplane((double[])Arrays.concat(a.normal,
                                                                                   rightZero),
                                                           a.offset);
                        // XXX need to look up a_zero in the ocean to see if it already exists! although it's probably not a functional problem if hyperplane lists get duplicated... maybe
                        contributingHyperplanes[iPlane++] = a_zero;
                    }
                    for (int iPlaneB = 0; (iPlaneB) < (B.contributingHyperplanes.length); ++iPlaneB)
                    {
                        Hyperplane b = B.contributingHyperplanes[iPlaneB];
                        Hyperplane zero_b = new Hyperplane((double[])Arrays.concat(leftZero,
                                                                                   b.normal),
                                                           b.offset);
                        // XXX need to look up zero_b in the ocean to see if it already exists! although it's probably not a functional problem if hyperplane lists get duplicated... maybe
                        contributingHyperplanes[iPlane++] = zero_b;
                    }
                    do { if (!((iPlane)==(contributingHyperplanes.length))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+6163 +"): (" + "iPlane" + ")" + "==" + "(" + "contributingHyperplanes.length" + ") ("+(iPlane)+" vs. "+(contributingHyperplanes.length)+")"); } while (false);
                }

                AB = new Polytope(A.dim+B.dim,
                                  A.fullDim+B.fullDim,
                                  facets,
                                  contributingHyperplanes,
                                  null); // loses aux
                ocean.put(key, AB);
            }

            if (verboseLevel >= 1)
                System.out.println(indentString+"out CSG._cross("+A.dim+"/"+A.fullDim+" x "+B.dim+"/"+B.fullDim+" = "+AB.dim+"/"+AB.fullDim+")");
            return AB;
        } // _cross


        /**
         * Slices up a signed polytope into 3 parts: above, below, and on
         * the hyperplane.
         *    if any part of slicee is strictly above the hyperplane,
         *        returnAbove[0] will be set to that part, of dimension slicee.dim;
         *        otherwise it will be set to null.
         *    if any part of slicee is strictly below the hyperplane,
         *        returnBelow[0] will be set to that part, of dimension slicee.dim;
         *        otherwise it will be set to null.
         *    if slicee lies partly strictly above and partly strictly below
         *        the hyperplane, then returnOn[0] will be set to
         *        the cross-section polytope, of dimension slicee.dim-1
         *        (or slicee.dim, if slicee lies in the hyperplane);
         *        otherwise it will be set to null.
         * You can pass null in as any or all of returnAbove, returnOn,
         * or returnBelow, if you are not interested in them.
         */
        private static void slice(SPolytope slicee,
                                  Hyperplane hyperplane,
                                  Object aux, // to be put in the aux field of all new elements
                                  SPolytope returnBelow[/*1*/], int returnBelowIndex,
                                  SPolytope returnBelowCapFacet[/*1*/], int returnBelowCapFacetIndex,
                                  SPolytope returnAboveCapFacet[/*1*/], int returnAboveCapFacetIndex,
                                  SPolytope returnAbove[/*1*/], int returnAboveIndex)
        {
            _slice(slicee,
                   hyperplane,
                   aux,
                   returnBelow, returnBelowIndex,
                   returnBelowCapFacet, returnBelowCapFacetIndex,
                   returnAboveCapFacet, returnAboveCapFacetIndex,
                   returnAbove, returnAboveIndex,
                   /*ocean=*/new java.util.HashMap<Polytope,Object[]>(),
                   "");
        } // slice

        /**
        * Slice up the eltDim-dimensional elements of the given signed polytope
        * of signed polytopes using a single hyperplane,
        * returning a new signed polytope of the same dimension as the original.
        * XXX this is actually not a great way to do this,
        * XXX since often we make a bunch of parallel cuts
        * XXX and we know the stuff on a particular side of the first cut
        * XXX isn't going to be affected by the next cut
        */
        public static SPolytope sliceElements(SPolytope slicee,
                                              int eltDim,
                                              Hyperplane hyperplane,
                                              Object aux,
                                              int sizes[]) // if not null, only slice elements with specified number of facets
        {
            SPolytope answer = _sliceElements(slicee,
                                              eltDim,
                                              hyperplane,
                                              aux,
                                              sizes,
                                              /*ocean=*/new java.util.HashMap<Polytope,Object[]>(),
                                              "");
            return answer;
        } // sliceElements

        private static SPolytope _sliceElements(SPolytope slicee,
                                                int eltDim,
                                                Hyperplane hyperplane,
                                                Object aux,
                                                int sizes[],
                                                java.util.HashMap<Polytope,Object[]> ocean,
                                                String indentString)
        {
            String subIndentString = null;
            if (verboseLevel >= 1)
            {
                System.out.println(indentString+"in CSG._sliceElements (slicee = "+signToString(slicee.sign)+dimToPrefix(slicee.p.dim)+slicee.p.id+")");
                subIndentString = indentString + "        ";
                System.out.println(indentString+"");
            }
            do { if (!(eltDim < slicee.p.dim)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+6256 +"): " + "eltDim < slicee.p.dim" + ""); } while (false); // otherwise answer could have more than one SPolytope... caller should just use slice directly in that case
            SPolytope newFacets[] = null;

            if (eltDim == slicee.p.dim-1)
            {
                newFacets = new SPolytope[2*slicee.p.facets.length]; // worst case
                int nNewFacets = 0;
                for (int iFacet = 0; (iFacet) < (slicee.p.facets.length); ++iFacet)
                {
                    if (sizes != null
                     && Arrays.indexOf(sizes, slicee.p.facets[iFacet].p.facets.length) == -1)
                    {
                        newFacets[nNewFacets++] = slicee.p.facets[iFacet];
                        continue;
                    }

                    _slice(slicee.p.facets[iFacet],
                           hyperplane,
                           aux,
                           newFacets, nNewFacets, // below part of this facet
                           null, -1, // ignore cap
                           null, -1, // ignore cap
                           newFacets, nNewFacets+1, // above part of this facet
                           ocean,
                           subIndentString);

                    // If we got an above part and/or below part,
                    // move them into the next position(s) in newFacets.
                    // (this seems more complicated than necessary)
                    if (newFacets[nNewFacets] != null)
                    {
                        nNewFacets++;
                        if (newFacets[nNewFacets] != null)
                            nNewFacets++;
                    }
                    else if (newFacets[nNewFacets+1] != null)
                    {
                        newFacets[nNewFacets] = newFacets[nNewFacets+1];
                        newFacets[nNewFacets+1] = null;
                        nNewFacets++;
                    }
                }
                if (nNewFacets < newFacets.length)
                    newFacets = (SPolytope[])Arrays.subarray(newFacets, 0, nNewFacets);
            }
            else // eltDim < slicee.dim-1
            {
                // Recurse
                newFacets = new SPolytope[slicee.p.facets.length];
                for (int iFacet = 0; (iFacet) < (slicee.p.facets.length); ++iFacet)
                    newFacets[iFacet] = _sliceElements(slicee.p.facets[iFacet],
                                                       eltDim,
                                                       hyperplane,
                                                       aux,
                                                       sizes,
                                                       ocean,
                                                       subIndentString);
            }
            SPolytope answer = new SPolytope(
                slicee.initialDensity,
                slicee.sign,
                new Polytope(slicee.p.dim,
                             slicee.p.fullDim,
                             newFacets,
                             slicee.p.contributingHyperplanes,
                             slicee.p.aux)); // not aux, since this one is a full-dimensional piece of slicee
            if (verboseLevel >= 1)
            {
                System.out.println(indentString+"out CSG._sliceElements (slicee = "+signToString(slicee.sign)+dimToPrefix(slicee.p.dim)+slicee.p.id+")");
            }
            return answer;
        } // _sliceElements

            // Little utility SPolytope comparator used within _slice
            private static SortStuff.Comparator SPolytopeCompareIdAndSign = new SortStuff.Comparator() {
                @Override public int compare(Object _a, Object _b)
                {
                    SPolytope A = (SPolytope)_a;
                    SPolytope B = (SPolytope)_b;
                    return A.p.id < B.p.id ? -1 :
                           A.p.id > B.p.id ? 1 :
                           A.sign < B.sign ? -1 :
                           A.sign > B.sign ? 1 :
                           0;
                }
            }; // SPolytopeCompareIdAndSign

            // Assumes splist is disposable/reusable
            static private int sortAndCombineSPolytopes(int nsps, SPolytope sps[])
            {
                SortStuff.sort(sps, 0, nsps, SPolytopeCompareIdAndSign);
                int nFinal = 0;
                for (int i = 0; (i) < (nsps); ++i)
                {
                    if (nFinal > 0
                     && sps[i].p.id == sps[nFinal-1].p.id)
                    {
                        if (sps[i].sign + sps[nFinal-1].sign == 0)
                            nFinal--;
                        else
                        {
                            // any other case would require replacing sps[nFinal-1] with a new SPolytope with the summed sign.  I'm not prepared to test this...
                            do { if (!(false)) throw new Error("Assumption failed at "+"com/donhatchsw/util/CSG.prejava"+"("+6358 +"): " + "false" + ""); } while (false);
                        }
                    }
                    else
                        sps[nFinal++] = sps[i];
                }
                return nFinal;
            } // sortAndCombineSPolytopes



        // recursive work function used by slice() and sliceElements().
        // returns below,belowCapFacet,aboveCapFacet,above
        // of dimensions slicee.dim, slicee.dim-1, slicee.dim-1, slicee.dim.
        // belowCapFacet is either null, or a facet of below.
        // aboveCapFacet is either null, or a facet of above.
        private static void _slice(SPolytope slicee,
                                   Hyperplane hyperplane,
                                   Object aux,
                                   SPolytope returnBelow[], int returnBelowIndex,
                                   SPolytope returnBelowCapFacet[], int returnBelowCapFacetIndex,
                                   SPolytope returnAboveCapFacet[], int returnAboveCapFacetIndex,
                                   SPolytope returnAbove[], int returnAboveIndex,
                                   java.util.HashMap<Polytope,Object[]> ocean, // hashtable of slicings already done
                                   String indentString) // for debugging
        {
            String subIndentString = null;
            if (verboseLevel >= 1)
            {
                System.out.println(indentString+"in CSG._slice (slicee = "+signToString(slicee.sign)+dimToPrefix(slicee.p.dim)+slicee.p.id+")");
                subIndentString = indentString + "        ";
            }
            Object answer[/*4*/] = ocean.get(slicee.p);
            if (answer == null)
            {
                Polytope below = null;
                SPolytope aboveCapFacet = null;
                SPolytope belowCapFacet = null;
                Polytope above = null;

                if (slicee.p.dim == 0)
                {
                    double coords[] = slicee.p.getCoords();
                    double height = VecMath.dot(coords, hyperplane.normal) - hyperplane.offset;
                    double tol = 1e-12; // XXX ad-hoc, need to make a coherent scheme
                    if ((((height)-(0.)) > (tol)))
                        above = slicee.p;
                    else if ((((0.)-(height)) > (tol)))
                        below = slicee.p;
                    else
                    {
                        // it's on the hyperplane.
                        // do nothing... the vertex simply doesn't get included.
                    }
                } // slicee.p.dim == 0
                else if (slicee.p.dim == 1)
                {
                    //
                    // Slicee is a 1-dimensional polytope,
                    // i.e. a (multi-)segment.  Note that
                    // it may have more than two vertices:
                    // e.g. when a hatchet-chop is taken out of the
                    // edge of a regular polyhedron, the resulting pieces of the
                    // chopped edge are still considered to be part
                    // of a single edge, which now has 4 vertices
                    // (with signs -, +, -, + in order).
                    //

                    SPolytope vertsBelow[] = new SPolytope[slicee.p.facets.length];
                    SPolytope vertsAbove[] = new SPolytope[slicee.p.facets.length];
                    int nVertsBelow = 0;
                    int nVertsAbove = 0;
                    int nVertsOn = 0;
                    int totalSignBelow = 0;
                    int totalSignAbove = 0;
                    int totalSignOn = 0;
                    SPolytope someVertexOnHyperplane = null; // if we find one, save it
                    for (int iVert = 0; (iVert) < (slicee.p.facets.length); ++iVert)
                    {
                        // Add the vertex to vertsBelow if it's below,
                        // or to vertsAbove if it's above.
                        _slice(slicee.p.facets[iVert],
                               hyperplane,
                               aux,
                               vertsBelow, nVertsBelow,
                               null, -1,
                               null, -1,
                               vertsAbove, nVertsAbove,
                               ocean,
                               subIndentString);
                        if (vertsBelow[nVertsBelow] != null)
                            totalSignBelow += vertsBelow[nVertsBelow++].sign;
                        else if (vertsAbove[nVertsAbove] != null)
                            totalSignAbove += vertsAbove[nVertsAbove++].sign;
                        else
                        {
                            someVertexOnHyperplane = slicee.p.facets[iVert];
                            totalSignOn += slicee.p.facets[iVert].sign;
                            nVertsOn++;
                        }
                    }
                    if (verboseLevel >= 1)
                    {
                        {System.out.print("        "); System.out.println("nVertsBelow" + " = " + (nVertsBelow));};
                        {System.out.print("        "); System.out.println("nVertsOn" + " = " + (nVertsOn));};
                        {System.out.print("        "); System.out.println("nVertsAbove" + " = " + (nVertsAbove));};
                        {System.out.print("        "); System.out.println("totalSignBelow" + " = " + (totalSignBelow));};
                        {System.out.print("        "); System.out.println("totalSignOn" + " = " + (totalSignOn));};
                        {System.out.print("        "); System.out.println("totalSignAbove" + " = " + (totalSignAbove));};
                    }
                    do { if (!((totalSignBelow + totalSignOn + totalSignAbove)==(0))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+6468 +"): (" + "totalSignBelow + totalSignOn + totalSignAbove" + ")" + "==" + "(" + "0" + ") ("+(totalSignBelow + totalSignOn + totalSignAbove)+" vs. "+(0)+")"); } while (false);

                    if (nVertsAbove > 0 && nVertsBelow == 0)
                    {
                        above = slicee.p;
                        if (nVertsOn > 0)
                        {
                            do { if (!((nVertsOn)==(1))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+6475 +"): (" + "nVertsOn" + ")" + "==" + "(" + "1" + ") ("+(nVertsOn)+" vs. "+(1)+")"); } while (false);
                            aboveCapFacet = someVertexOnHyperplane;
                        }
                    }
                    else if (nVertsBelow > 0 && nVertsAbove == 0)
                    {
                        below = slicee.p;
                        if (nVertsOn > 0)
                        {
                            do { if (!((nVertsOn)==(1))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+6484 +"): (" + "nVertsOn" + ")" + "==" + "(" + "1" + ") ("+(nVertsOn)+" vs. "+(1)+")"); } while (false);
                            belowCapFacet = someVertexOnHyperplane;
                        }
                    }
                    else if (nVertsAbove > 0 || nVertsBelow > 0)
                    {
                        // For the cut point, either use the existing vertex that's on the plane,
                        // or make a new cut point.
                        // If we make a new one, note that we don't need to set the coords on it,
                        // that will be computed lazily from its hyperplanes
                        // the first time anywone calls getCoords() on it.
                        Polytope unsignedCutPoint = nVertsOn > 0 ? someVertexOnHyperplane.p
                                                                 : new Polytope(slicee.p.dim-1,
                                                                                slicee.p.fullDim,
                                                                                new SPolytope[0], // result vertex has no facets
                                                                                addOneHyperplaneAndSort(slicee.p.contributingHyperplanes, hyperplane),
                                                                                aux);
                        if (totalSignBelow != 0)
                        {
                            // Need a cap for the below part.
                            if (totalSignBelow + totalSignOn == 0)
                            {
                                // The existing signed vertex on the plane is the cap for the below part
                                belowCapFacet = someVertexOnHyperplane;
                            }
                            else
                            {
                                // If there's already a vertex on the plane, it's the wrong sign.
                                // Use the unsigned vertex (or the new cutpoint), with the desired sign.
                                belowCapFacet = new SPolytope(0, // initialDensity is always 0 for vertices, I think
                                                              -totalSignBelow,
                                                              unsignedCutPoint);
                            }
                            vertsBelow[nVertsBelow++] = belowCapFacet;
                        }
                        if (totalSignAbove != 0)
                        {
                            // Need a cap for the above part.
                            if (totalSignAbove + totalSignOn == 0)
                            {
                                // The existing signed vertex on the plane is the cap for the above part
                                aboveCapFacet = someVertexOnHyperplane;
                            }
                            else
                            {
                                // If there's already a vertex on the plane, it's the wrong sign.
                                // Use the unsigned vertex (or the new cutpoint), with the desired sign.
                                aboveCapFacet = new SPolytope(0, // initialDensity is always 0 for vertices, I think
                                                              -totalSignAbove,
                                                              unsignedCutPoint);
                            }
                            vertsAbove[nVertsAbove++] = aboveCapFacet;
                        }

                        // XXX think about this... are nVertsBelow and nVertsAbove guaranteed... no they aren't...
                        // XXX BUT, if one of them is zero, then we could have just used slicee for the other, right? hmm
                        if (nVertsBelow != 0)
                        {
                            if (vertsBelow.length != nVertsBelow)
                                vertsBelow = (SPolytope[])Arrays.subarray(vertsBelow, 0, nVertsBelow);
                            below = new Polytope(slicee.p.dim,
                                                 slicee.p.fullDim,
                                                 vertsBelow,
                                                 slicee.p.contributingHyperplanes,
                                                 slicee.p.aux);
                        }
                        if (nVertsAbove != 0)
                        {
                            if (vertsAbove.length != nVertsAbove)
                                vertsAbove = (SPolytope[])Arrays.subarray(vertsAbove, 0, nVertsAbove);
                            above = new Polytope(slicee.p.dim,
                                                 slicee.p.fullDim,
                                                 vertsAbove,
                                                 slicee.p.contributingHyperplanes,
                                                 slicee.p.aux);
                        }
                    }
                    else
                    {
                        // all On... do nothing
                    }
                }
                else // slicee.p.dim >= 2
                {
                    do { if (!(slicee.p.dim >= 2)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+6568 +"): " + "slicee.p.dim >= 2" + ""); } while (false);


                    // The following is a huge time savings--
                    // "{5,3,3} 3" went down from 12 seconds to 2.176 seconds
                    // from the verts test, and down to 1.836 seconds
                    // with the bbox test too.
                    // Hmm, with the bbox test only, it actually went down
                    // to 1.524 seconds... so maybe the verts test isn't worthwhile
                    if (true)
                    {
                        boolean allVertsAreKnownToBeBelow = false;
                        boolean allVertsAreKnownToBeAbove = false;
                        if (true)
                        {
                            // not sure if the bbox test will be a savings
                            double bbox[][] = slicee.p.getBBox();
                            int fullDim = slicee.p.fullDim;
                            double minHeight = -hyperplane.offset;
                            double maxHeight = -hyperplane.offset;
                            for (int iDim = 0; (iDim) < (fullDim); ++iDim)
                            {
                                double a = hyperplane.normal[iDim] * bbox[0][iDim];
                                double b = hyperplane.normal[iDim] * bbox[1][iDim];
                                if (a <= b)
                                {
                                    minHeight += a;
                                    maxHeight += b;
                                }
                                else
                                {
                                    minHeight += b;
                                    maxHeight += a;
                                }
                            }
                            double tol = 1e-12; // XXX ad-hoc, need to make a coherent scheme
                            if ((((0.)-(maxHeight)) > (tol)))
                                allVertsAreKnownToBeBelow = true;
                            else if ((((minHeight)-(0.)) > (tol)))
                                allVertsAreKnownToBeAbove = true;
                        }

                        // theoretically the following is a good idea,
                        // but it actually seems to slow things down a bit
                        if (true
                         && !allVertsAreKnownToBeBelow
                         && !allVertsAreKnownToBeAbove)
                        {
                            boolean allVertsAreBelowSoFar = true; // until proven false
                            boolean allVertsAreAboveSoFar = true; // until proven false
                            Polytope allVerts[] = slicee.p.getAllElements()[0];
                            for (int iVert = 0; (iVert) < (allVerts.length); ++iVert)
                            {
                                double coords[] = allVerts[iVert].getCoords();
                                double height = VecMath.dot(coords, hyperplane.normal) - hyperplane.offset;
                                double tol = 1e-12; // XXX ad-hoc, need to make a coherent scheme
                                if ((((height)-(0.)) > (tol)))
                                {
                                    allVertsAreBelowSoFar = false;
                                    if (!allVertsAreAboveSoFar)
                                        break;
                                }
                                else if ((((0.)-(height)) > (tol)))
                                {
                                    allVertsAreAboveSoFar = false;
                                    if (!allVertsAreBelowSoFar)
                                        break;
                                }
                                else
                                {
                                    allVertsAreAboveSoFar = false;
                                    allVertsAreBelowSoFar = false;
                                    break;
                                }
                            }
                            if (allVertsAreBelowSoFar)
                            {
                                allVertsAreKnownToBeBelow = true;
                                //System.out.println("hey! below after all");
                            }
                            else if (allVertsAreAboveSoFar)
                            {
                                allVertsAreKnownToBeAbove = true;
                                //System.out.println("hey! above after all");
                            }
                        }

                        if (allVertsAreKnownToBeBelow)
                        {
                            ocean.put(slicee.p, new Object[]{slicee.p, null, null, null});
                            if (returnBelow != null)
                                returnBelow[returnBelowIndex] = slicee; // XXX do we need to separate?
                            if (returnBelowCapFacet != null)
                                returnBelowCapFacet[returnBelowCapFacetIndex] = null;
                            if (returnAboveCapFacet != null)
                                returnAboveCapFacet[returnAboveCapFacetIndex] = null;
                            if (returnAbove != null)
                                returnAbove[returnAboveIndex] = null;
                            return;
                        }
                        else if (allVertsAreKnownToBeAbove)
                        {
                            ocean.put(slicee.p, new Object[]{null, null, null, slicee.p});
                            if (returnBelow != null)
                                returnBelow[returnBelowIndex] = null;
                            if (returnBelowCapFacet != null)
                                returnBelowCapFacet[returnBelowCapFacetIndex] = null;
                            if (returnAboveCapFacet != null)
                                returnAboveCapFacet[returnAboveCapFacetIndex] = null;
                            if (returnAbove != null)
                                returnAbove[returnAboveIndex] = slicee; // XXX do we need to separate?
                            return;
                        }
                    }

                    SPolytope facetsBelow[] = new SPolytope[slicee.p.facets.length+1]; // worst case
                    SPolytope boundaryRidgesBelow[] = new SPolytope[slicee.p.facets.length];
                    SPolytope boundaryRidgesAbove[] = new SPolytope[slicee.p.facets.length];
                    SPolytope facetsAbove[] = new SPolytope[slicee.p.facets.length+1]; // worst case
                    SPolytope someFacetOnHyperplane = null; // if some facet is on the hyperplane, save it in this
                    int nFacetsBelow = 0;
                    int nBoundaryRidgesBelow = 0;
                    int nBoundaryRidgesAbove = 0;
                    int nFacetsAbove = 0;
                    int nFacetsOn = 0;
                    for (int iFacet = 0; (iFacet) < (slicee.p.facets.length); ++iFacet)
                    {
                        _slice(slicee.p.facets[iFacet],
                               hyperplane,
                               aux,
                               facetsBelow, nFacetsBelow,
                               boundaryRidgesBelow, nBoundaryRidgesBelow,
                               boundaryRidgesAbove, nBoundaryRidgesAbove,
                               facetsAbove, nFacetsAbove,
                               ocean,
                               subIndentString);
                        if (facetsBelow[nFacetsBelow] == null
                         && facetsAbove[nFacetsAbove] == null)
                        {
                            nFacetsOn++;
                            someFacetOnHyperplane = slicee.p.facets[iFacet];
                            // TODO: currently we don't actually do anything with it... should we?
                        }
                        if (facetsBelow[nFacetsBelow] != null) nFacetsBelow++;
                        if (boundaryRidgesBelow[nBoundaryRidgesBelow] != null) nBoundaryRidgesBelow++;
                        if (boundaryRidgesAbove[nBoundaryRidgesAbove] != null) nBoundaryRidgesAbove++;
                        if (facetsAbove[nFacetsAbove] != null) nFacetsAbove++;
                    }

                    do { if (!(nFacetsOn == 0 || nFacetsOn == 1 || nFacetsOn == slicee.p.facets.length)) throw new Error("Assumption failed at "+"com/donhatchsw/util/CSG.prejava"+"("+6717 +"): " + "nFacetsOn == 0 || nFacetsOn == 1 || nFacetsOn == slicee.p.facets.length" + ""); } while (false)

                                                                ;

                    if (nFacetsOn == 1)
                    {
                        do { if (!(nFacetsAbove==0 || nFacetsBelow==0)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+6723 +"): " + "nFacetsAbove==0 || nFacetsBelow==0" + ""); } while (false);
                        if (nFacetsAbove == 0)
                        {
                            below = slicee.p;
                            belowCapFacet = someFacetOnHyperplane;
                        }
                        else // nFacetsBelow == 0
                        {
                            above = slicee.p;
                            aboveCapFacet = someFacetOnHyperplane;
                        }
                    }
                    else if (nFacetsBelow == 0 && nBoundaryRidgesBelow == 0 && nBoundaryRidgesAbove == 0 && nFacetsAbove > 0)
                    {
                        // Nothing below or on... return whole thing as above
                        above = slicee.p;
                    }
                    else if (nFacetsAbove == 0 && nBoundaryRidgesAbove == 0 && nBoundaryRidgesBelow == 0 && nFacetsBelow > 0)
                    {
                        // Nothing above or on... return whole thing as below
                        below = slicee.p;
                    }
                    else if (nFacetsAbove > 0 || nFacetsBelow > 0)
                    {
                        // POSSIBLE IMPROVEMENT:
                        // if the slicing plane includes a facet, that facet polytope will be lost
                        // and replaced by an identical one... that's not ideal, should try to retain it.

                        //
                        // Sort the boundaries, and combine SPolytopes
                        // that have the same Polytope.
                        //
                        nBoundaryRidgesBelow = sortAndCombineSPolytopes(nBoundaryRidgesBelow, boundaryRidgesBelow);
                        nBoundaryRidgesAbove = sortAndCombineSPolytopes(nBoundaryRidgesAbove, boundaryRidgesAbove);

                        // Check whether the two caps match (opposite) each other.
                        // If they do, then we only need to make one polytope
                        // for both of them.
                        boolean boundariesMatch = true; // until proven false
                        {
                            if (nBoundaryRidgesBelow != nBoundaryRidgesAbove)
                                boundariesMatch = false;
                            else
                            {
                                for (int iBoundaryRidge = 0; (iBoundaryRidge) < (nBoundaryRidgesBelow); ++iBoundaryRidge)
                                {
                                    SPolytope ridgeBelow = boundaryRidgesBelow[iBoundaryRidge];
                                    SPolytope ridgeAbove = boundaryRidgesAbove[iBoundaryRidge];
                                    if (ridgeBelow.p != ridgeAbove.p
                                     || ridgeBelow.sign != -ridgeAbove.sign)
                                    {
                                        boundariesMatch = false;
                                        break;
                                    }
                                }
                            }
                        }

                        if (nBoundaryRidgesBelow != 0)
                        {
                            // XXX should check whether facetOnHyperplane matches, and if so, use that
                            if (boundaryRidgesBelow.length != nBoundaryRidgesBelow)
                                boundaryRidgesBelow = (SPolytope[])Arrays.subarray(boundaryRidgesBelow, 0, nBoundaryRidgesBelow);
                            Polytope unsignedCutFacet = new Polytope(slicee.p.dim-1,
                                                                     slicee.p.fullDim,
                                                                     boundaryRidgesBelow,
                                                                     addOneHyperplaneAndSort(slicee.p.contributingHyperplanes, hyperplane),
                                                                     aux);

                            belowCapFacet = new SPolytope(slicee.initialDensity, // XXX I think this is wrong-- how the hell are we supposed to get an initial density? maybe initialDensity isn't meaningful except for top-level polytopes?
                                                          -1, // to cancel the boundary ridges below
                                                          unsignedCutFacet);
                            facetsBelow[nFacetsBelow++] = belowCapFacet;
                        }
                        if (nBoundaryRidgesAbove != 0)
                        {
                            if (boundariesMatch)
                            {
                                // Use same underlying polytope as aboveCapFacet, with opposite sign
                                aboveCapFacet = new SPolytope(slicee.initialDensity, // XXX I think this is wrong-- how the hell are we supposed to get an initial density? maybe initialDensity isn't meaningful except for top-level polytopes?
                                                              -belowCapFacet.sign,
                                                              belowCapFacet.p);
                                if (verboseLevel >= 1)
                                {
                                    System.out.println(subIndentString+"boundaries match, using "+signToString(belowCapFacet.sign)+dimToPrefix(belowCapFacet.p.dim)+belowCapFacet.p.id+" for below and "+signToString(aboveCapFacet.sign)+dimToPrefix(aboveCapFacet.p.dim)+aboveCapFacet.p.id+" for above");
                                }
                            }
                            else
                            {
                                if (boundaryRidgesAbove.length != nBoundaryRidgesAbove)
                                    boundaryRidgesAbove = (SPolytope[])Arrays.subarray(boundaryRidgesAbove, 0, nBoundaryRidgesAbove);
                                Polytope unsignedCutFacet = new Polytope(slicee.p.dim-1,
                                                                         slicee.p.fullDim,
                                                                         boundaryRidgesAbove,
                                                                         addOneHyperplaneAndSort(slicee.p.contributingHyperplanes, hyperplane),
                                                                         aux);

                                aboveCapFacet = new SPolytope(slicee.initialDensity, // XXX I think this is wrong-- how the hell are we supposed to get an initial density? maybe initialDensity isn't meaningful except for top-level polytopes?
                                                              -1, // to cancel the boundary ridges above
                                                              unsignedCutFacet);
                                if (verboseLevel >= 1)
                                {
                                    System.out.println(subIndentString+"boundaries do NOT match, using "+signToString(aboveCapFacet.sign)+dimToPrefix(aboveCapFacet.p.dim)+aboveCapFacet.p.id+" for above");
                                }
                            }
                            facetsAbove[nFacetsAbove++] = aboveCapFacet;
                        }

                        if (nFacetsAbove != 0)
                        {
                            if (facetsAbove.length != nFacetsAbove)
                                facetsAbove = (SPolytope[])Arrays.subarray(facetsAbove, 0, nFacetsAbove);
                            above = new Polytope(slicee.p.dim,
                                                 slicee.p.fullDim,
                                                 facetsAbove,
                                                 slicee.p.contributingHyperplanes,
                                                 slicee.p.aux);
                        }
                        if (nFacetsBelow != 0)
                        {
                            if (facetsBelow.length != nFacetsBelow)
                                facetsBelow = (SPolytope[])Arrays.subarray(facetsBelow, 0, nFacetsBelow);
                            below = new Polytope(slicee.p.dim,
                                                 slicee.p.fullDim,
                                                 facetsBelow,
                                                 slicee.p.contributingHyperplanes,
                                                 slicee.p.aux);
                        }
                    }
                    else
                    {
                        // All zero-- return nothing
                        do { if (!((nBoundaryRidgesBelow)==(0))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+6855 +"): (" + "nBoundaryRidgesBelow" + ")" + "==" + "(" + "0" + ") ("+(nBoundaryRidgesBelow)+" vs. "+(0)+")"); } while (false);
                        do { if (!((nBoundaryRidgesAbove)==(0))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+6856 +"): (" + "nBoundaryRidgesAbove" + ")" + "==" + "(" + "0" + ") ("+(nBoundaryRidgesAbove)+" vs. "+(0)+")"); } while (false);
                    }
                } // slicee.p.dim >= 2

                answer = new Object[] {below, belowCapFacet, aboveCapFacet, above};
                ocean.put(slicee.p, answer);
            }
            else
            {
                if (verboseLevel >= 1)
                    System.out.println(indentString+"    (found it in the ocean)");
            }

            Polytope belowUnsigned = (Polytope)answer[0];
            SPolytope belowCapFacet = (SPolytope)answer[1];
            SPolytope aboveCapFacet = (SPolytope)answer[2];
            Polytope aboveUnsigned = (Polytope)answer[3];

            if (returnBelow != null)
                returnBelow[returnBelowIndex] = belowUnsigned == null ? null :
                                                aboveUnsigned == null ? slicee :
                                                new SPolytope(slicee.initialDensity,
                                                              slicee.sign,
                                                              belowUnsigned);
            if (returnBelowCapFacet != null)
                returnBelowCapFacet[returnBelowCapFacetIndex] = belowCapFacet==null ? null :
                                                                slicee.sign==1 ? belowCapFacet :
                                                                new SPolytope(belowCapFacet.initialDensity,
                                                                              slicee.sign * belowCapFacet.sign,
                                                                              belowCapFacet.p);

            if (returnAboveCapFacet != null)
                returnAboveCapFacet[returnAboveCapFacetIndex] = aboveCapFacet==null ? null :
                                                                slicee.sign==1 ? aboveCapFacet :
                                                                new SPolytope(aboveCapFacet.initialDensity,
                                                                              slicee.sign * aboveCapFacet.sign,
                                                                              aboveCapFacet.p);
            if (returnAbove != null)
                returnAbove[returnAboveIndex] = aboveUnsigned == null ? null :
                                                belowUnsigned == null ? slicee :
                                                new SPolytope(slicee.initialDensity,
                                                              slicee.sign,
                                                              aboveUnsigned);

            if (true)
            {
                // Make sure we are not sharing--
                // e.g. if we had this:
                //      +f1
                //          +e2
                //      -f2
                //          +e2
                // and the +e2's were actually the same SPolytope,
                // then orientDeep can do something nasty, changing the sign of both of them
                // when it only intended to change the sign of one of them.
                // XXX this seems to be undoing a lot of optimizations we did... lame.
                if (returnBelow != null && returnBelow[returnBelowIndex] != null)
                    returnBelow[returnBelowIndex] = new SPolytope(returnBelow[returnBelowIndex].initialDensity,
                                                                  returnBelow[returnBelowIndex].sign,
                                                                  returnBelow[returnBelowIndex].p);
                if (returnBelowCapFacet != null && returnBelowCapFacet[returnBelowCapFacetIndex] != null)
                    returnBelowCapFacet[returnBelowCapFacetIndex] = new SPolytope(returnBelowCapFacet[returnBelowCapFacetIndex].initialDensity,
                                                                  returnBelowCapFacet[returnBelowCapFacetIndex].sign,
                                                                  returnBelowCapFacet[returnBelowCapFacetIndex].p);
                if (returnAboveCapFacet != null && returnAboveCapFacet[returnAboveCapFacetIndex] != null)
                    returnAboveCapFacet[returnAboveCapFacetIndex] = new SPolytope(returnAboveCapFacet[returnAboveCapFacetIndex].initialDensity,
                                                                  returnAboveCapFacet[returnAboveCapFacetIndex].sign,
                                                                  returnAboveCapFacet[returnAboveCapFacetIndex].p);

                if (returnAbove != null && returnAbove[returnAboveIndex] != null)
                    returnAbove[returnAboveIndex] = new SPolytope(returnAbove[returnAboveIndex].initialDensity,
                                                                  returnAbove[returnAboveIndex].sign,
                                                                  returnAbove[returnAboveIndex].p);
            }


            if (verboseLevel >= 1)
            {
                {System.out.print("        "); System.out.println("slicee" + " = " + (slicee));};
                if (returnBelow != null) System.out.println("        " + "returnBelow" + "["+(returnBelowIndex)+"] = " + (returnBelow)[returnBelowIndex]);
                if (returnBelowCapFacet != null) System.out.println("        " + "returnBelowCapFacet" + "["+(returnBelowCapFacetIndex)+"] = " + (returnBelowCapFacet)[returnBelowCapFacetIndex]);
                if (returnAboveCapFacet != null) System.out.println("        " + "returnAboveCapFacet" + "["+(returnAboveCapFacetIndex)+"] = " + (returnAboveCapFacet)[returnAboveCapFacetIndex]);
                if (returnAbove != null) System.out.println("        " + "returnAbove" + "["+(returnAboveIndex)+"] = " + (returnAbove)[returnAboveIndex]);
                System.out.println(indentString+"out CSG._slice (slicee = "+signToString(slicee.sign)+dimToPrefix(slicee.p.dim)+slicee.p.id+")");
            }
        } // _slice


        // recursive work function used by intersect()
        private static SPolytope _intersect(SPolytope A,
                                            SPolytope B,
                                            java.util.HashMap<HashableSortedArray<Hyperplane>,Object> ocean, // hashtable of intersection polytopes created, keyed by contributing hyperplanes.  value type is Object: Polytope for something, new Object() to represent null
                                            String indentString) // for debugging
        {
            String subIndentString = null;
            if (verboseLevel >= 1)
            {
                System.out.println(indentString+"in CSG._intersect");
                subIndentString = indentString + "        ";
            }
            if (verboseLevel >= 2)
                System.out.println(indentString+"    A = "+A.toString(indentString+"        ", false, false, null));
            if (verboseLevel >= 2)
                System.out.println(indentString+"    B = "+B.toString(indentString+"        ", false, false, null));
            if (verboseLevel >= 2
             && (A.p.facets.length > 0
              || B.p.facets.length > 0))
                System.out.println();

            int fullDim = A.p.fullDim;
            do { if (!((fullDim)==(B.p.fullDim))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+6966 +"): (" + "fullDim" + ")" + "==" + "(" + "B.p.fullDim" + ") ("+(fullDim)+" vs. "+(B.p.fullDim)+")"); } while (false);

            if (true)
            {
                //
                // Bounding box test for quick rejection.
                // Intersect bounding boxes of vertices...
                //
                double bboxA[][] = A.p.getBBox();
                double bboxB[][] = B.p.getBBox();
                if (verboseLevel >= 2) System.out.println(indentString+"    bboxA = "+Arrays.toStringCompact(bboxA));
                if (verboseLevel >= 2) System.out.println(indentString+"    bboxB = "+Arrays.toStringCompact(bboxB));
                double bbox[][] = new double[2][fullDim];
                VecMath.bboxIntersect(bbox, bboxA, bboxB);
                if (verboseLevel >= 2) System.out.println(indentString+"    bbox = "+Arrays.toStringCompact(bbox));
                boolean bboxIsEmpty = false; // and counting
                for (int iDim = 0; (iDim) < (fullDim); ++iDim)
                    if (bbox[0][iDim] > bbox[1][iDim]) // XXX should be fuzzy I think
                        bboxIsEmpty = true;
                if (bboxIsEmpty)
                {
                    if (A.initialDensity == 0
                     && B.initialDensity == 0)
                    {
                        if (verboseLevel >= 1)
                        {
                            System.out.println(indentString+"    empty bbox with both initial densities 0, returning null");
                            System.out.println(indentString+"out CSG.intersect");
                        }
                        return null;
                    }
                    else if (A.initialDensity == 0)
                    {
                        if (verboseLevel >= 1)
                        {
                            System.out.println(indentString+"    empty bbox, A's initial density is 0, B's is not, returning A");
                            System.out.println(indentString+"out CSG.intersect");
                        }
                        return A;
                    }
                    else if (B.initialDensity == 0)
                    {
                        if (verboseLevel >= 1)
                        {
                            System.out.println(indentString+"    empty bbox, B's initial density is 0, A's is not, returning B");
                            System.out.println(indentString+"out CSG.intersect");
                        }
                        return B;
                    }
                    else
                    {
                        // Both A and B have nonzero initial density.
                        // XXX Could optimize by simply concatenating
                        // XXX the arrays together, so to speak,
                        // XXX but I don't think this happens enough in
                        // XXX the current application to be worth worrying about.
                        if (verboseLevel >= 1)
                        {
                            System.out.println(indentString+"    empty bbox, both initial densities nonzero, but not smart enough to do anything about it yet :-(");
                        }
                    }
                }
            }


            Hyperplane contributingHyperplanes[] = unionOfHyperplanesAndSort(A.p.contributingHyperplanes, B.p.contributingHyperplanes);
            HashableSortedArray<Hyperplane> key = new HashableSortedArray<Hyperplane>(contributingHyperplanes);

            int resultDim = fullDim - contributingHyperplanes.length;

            if (resultDim < 0)
            {
                if (verboseLevel >= 1)
                {
                    System.out.println(indentString+"    too many hyperplanes! returning null");
                    System.out.println(indentString+"out CSG.intersect");
                }
                return null;
            }

            // Look in the ocean for already computed...
            {
                if (ocean.containsKey(key)) // use this rather than checking for get()==null, since we insert null sometimes
                {
                    Object flotsam = ocean.get(key);
                    // Found it in the ocean, so it was previously computed.
                    if (verboseLevel >= 1)
                        System.out.println(indentString+"        found it in the ocean");
                    if (flotsam instanceof Polytope)
                    {
                        if (verboseLevel >= 2)
                        {
                            System.out.println(indentString+"        and it was good");
                            System.out.println(indentString+"out CSG.intersect");
                        }
                        return new SPolytope(0, // XXX initial density always 0 in this case?
                                             1, // XXX probably not right, fix later
                                             (Polytope)flotsam);
                    }
                    else
                    {
                        do { if (!(flotsam == null)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+7067 +"): " + "flotsam == null" + ""); } while (false);
                        // It was previously computed and came out null.
                        if (verboseLevel >= 1)
                        {
                            System.out.println(indentString+"        and it was null");
                            System.out.println(indentString+"out CSG.intersect");
                        }
                        return null;
                    }
                }
            } // looked in the ocean

            SPolytope result;
            if (resultDim == 0)
            {
                double coords[];
                if (A.p.dim == 0)
                    coords = A.p.getCoords();
                else if (B.p.dim == 0)
                    coords = B.p.getCoords();
                else
                    coords = intersectHyperplanes(contributingHyperplanes);

                {
                    // XXX could use something smaller than union
                    // XXX in various cases of initialDensity? think about it
                    double unionBBox[][] = VecMath.bboxUnion(A.p.getBBox(),
                                                             B.p.getBBox());
                    double bigTol = 1e-3; // need not be very exact; the bigger the safer 
                    if (coords != null
                     && !VecMath.closedBBoxContains(unionBBox, coords, bigTol))
                    {
                        if (verboseLevel >= 2)
                        {
                            System.out.println(indentString + "        HA! No way! coords were out of there!");
                        }
                        coords = null;
                    }

                    // XXX research question: can something like this
                    // XXX be done even if resultDim > 0?
                }

                if (coords != null)
                {
                    boolean inA;
                    {
                        double tol = 1e-12; // XXX ad-hoc, need to make a coherent scheme
                        int densityMinMax[] = new int[2];
                        calcDensity(A,
                                    coords,
                                    tol,
                                    densityMinMax);
                        int density = densityMinMax[0];
                        if (density != densityMinMax[1])
                        {
                            if (verboseLevel >= 0)
                            {
                                System.out.println("WARNING:");
                                {System.out.print("        "); System.out.println("A" + " = " + (A));};
                                System.out.println("        " + "coords" + " = " + VecMath.toString(coords));
                                {System.out.print("        "); System.out.println("densityMinMax[0]" + " = " + (densityMinMax[0]));};
                                {System.out.print("        "); System.out.println("densityMinMax[1]" + " = " + (densityMinMax[1]));};
                            }
                            //CHECK(false);
                        }
                        inA = ((density&1) == 1); // XXX even-odd rule for now
                    }
                    boolean inB = false; // shut up compiler
                    if (inA) // otherwise inB doesn't matter
                    {
                        double tol = 1e-12; // XXX ad-hoc, need to make a coherent scheme
                        int densityMinMax[] = new int[2];
                        calcDensity(B,
                                    coords,
                                    tol,
                                    densityMinMax);
                        int density = densityMinMax[0];
                        if (density != densityMinMax[1])
                        {
                            if (verboseLevel >= 0)
                            {
                                System.out.println("WARNING:");
                                {System.out.print("        "); System.out.println("B" + " = " + (B));};
                                System.out.println("        " + "coords" + " = " + VecMath.toString(coords));
                                {System.out.print("        "); System.out.println("densityMinMax[0]" + " = " + (densityMinMax[0]));};
                                {System.out.print("        "); System.out.println("densityMinMax[1]" + " = " + (densityMinMax[1]));};
                            }
                            //CHECK(false);
                        }
                        inB = ((density&1) == 1); // XXX even-odd rule for now
                    }
                    if (inA && inB)
                    {
                        if (A.p.dim == 0)
                            result = A;
                        else if (B.p.dim == 0)
                            result = B;
                        else
                        {
                            result = new SPolytope(
                                            0, 1, // XXX nonsense, will straighten out later
                                            new Polytope(0,
                                                         fullDim,
                                                         new SPolytope[0],
                                                         contributingHyperplanes,
                                                         null)); // no aux, since it's not a full-dimensional subset of any existing polytope
                            result.p.setCoords(coords); // so they won't need to be recalculated
                        }
                    }
                    else
                        result = null;
                }
                else
                    result = null;
            }
            else // resultDim > 0
            {
                //
                // Trying to maybe get it right
                // in the case of flush stuff
                // (e.g. A&A of dim 1 or 2 in test program).
                // I don't know if this will work,
                // and it's certainly WAY more compute intensive...
                // I think maybe the union-of-hyperplanes logic
                // isn't right though :-(
                // Also, need to do this first
                // so that we won't get a "found it in the ocean and it was
                // null".
                // NOTE, we really only need to do this
                // when a's subspace contains b's subspace (i.e.
                // one set of hyperplanes contains the other).
                // XXX need to think about whether there's an efficient
                // XXX way of enumerating all pairs for which this is true
                //
                int nMoreFacets = 0;
                SPolytope moreFacets[] = null;
                if (false) // maybe pursue this some other time
                {
                    if (verboseLevel >= 1)
                        System.out.println(indentString+"    Trying more expensive boundary stuff...");
                    moreFacets = new SPolytope[A.p.facets.length
                                             * B.p.facets.length];
                    for (int i = 0; (i) < (A.p.facets.length); ++i)
                    for (int j = 0; (j) < (B.p.facets.length); ++j)
                    {
                        SPolytope a = A.p.facets[i];
                        SPolytope b = B.p.facets[j];
                        // Only proceed if a's subspace contains b's subspace
                        // or vice-versa.
                        {
                            Hyperplane unionOfHyperplanes[] = unionOfHyperplanesAndSort(a.p.contributingHyperplanes, b.p.contributingHyperplanes);
                            if (unionOfHyperplanes.length
                             != ((a.p.contributingHyperplanes.length)<=(b.p.contributingHyperplanes.length)?(a.p.contributingHyperplanes.length):(b.p.contributingHyperplanes.length))
                                                                       )
                                continue;
                        }
                        if (verboseLevel >= 2)
                        {
                            System.out.println(indentString+"            a = "+a.toString(indentString+"            ", false, false));
                            System.out.println(indentString+"            b = "+b.toString(indentString+"            ", false, false));
                        }
                        SPolytope a_intersect_b = _intersect(a, b, ocean, subIndentString);
                        if (a_intersect_b != null)
                            moreFacets[nMoreFacets++] = a_intersect_b;
                    }
                    if (verboseLevel >= 1)
                        System.out.println(indentString+"    Found "+nMoreFacets+"/"+moreFacets.length+" more facets");
                }


                int nFacets = 0;
                SPolytope facets[] = new SPolytope[A.p.facets.length
                                                 + B.p.facets.length]; // max possible

                for (int i = 0; (i) < (A.p.facets.length); ++i)
                {
                    SPolytope a = A.p.facets[i];
                    if (verboseLevel >= 2)
                        System.out.println(indentString+"        a = "+a.toString(indentString+"            ", false, false));
                    SPolytope a_intersect_B = _intersect(a, B, ocean, subIndentString);
                    if (a_intersect_B != null)
                        facets[nFacets++] = a_intersect_B;
                }
                for (int i = 0; (i) < (B.p.facets.length); ++i)
                {
                    SPolytope b = B.p.facets[i];
                    if (verboseLevel >= 2)
                        System.out.println(indentString+"        b = "+b.toString(indentString+"            ", false, false));
                    SPolytope A_intersect_b = _intersect(A, b, ocean, subIndentString);
                    if (A_intersect_b != null)
                        facets[nFacets++] = A_intersect_b;
                }

                facets = (SPolytope[])Arrays.subarray(facets, 0, nFacets); // resize

                if (nMoreFacets > 0)
                {
                    moreFacets = (SPolytope[])Arrays.subarray(moreFacets, 0, nMoreFacets); // resize
                    facets = (SPolytope[])Arrays.concat(facets, moreFacets);
                }

                result = new SPolytope(
                                       ((A.initialDensity)<=(B.initialDensity)?(A.initialDensity):(B.initialDensity)), // XXX is this right? have to think about it
                                       A.sign, // XXX probably completely irrelevant
                                       new Polytope(resultDim,
                                                    fullDim,
                                                    facets,
                                                    contributingHyperplanes,
                                                    resultDim==A.p.dim ? A.p.aux : resultDim==B.p.dim ? B.p.aux : null)); // XXX prefers A's aux. probably not much better we can do, unless we want to combine the auxes somehow, but that's probably too much trouble and the current application doesn't need it
                //
                // Hack after the fact:
                // if it's equal to A or B, return A or B instead
                // (XXX should detect that earlier and save lots of work
                // and unnecessary allocations, maybe)
                // XXX this may be defunct,
                // XXX have to think about it
                //
                {
                    if (result.p.dim == A.p.dim
                     && VecMath.equalsUsingEqualsSymbol(result.p.facets, A.p.facets))
                    {
                        result = new SPolytope(result.initialDensity,
                                               result.sign,
                                               A.p);
                    }
                    else if (result.p.dim == B.p.dim
                     && VecMath.equalsUsingEqualsSymbol(result.p.facets, B.p.facets))
                    {
                        result = new SPolytope(result.initialDensity,
                                               result.sign,
                                               B.p);
                    }
                }
            }

            if (result != null
             && result.p.dim >= 1
             && result.initialDensity == 0
             && result.p.facets.length == 0)
                result = null;

            if (result != null)
                ocean.put(key, result.p);
            else
            {
                ocean.put(key, null); // not legal for Hashtable, but legal for HashMap.  retriever must distinguish, though!
            }

            if (verboseLevel >= 2)
                System.out.println(indentString+"    result = "+(result==null?"(null)":result.toString(indentString+"             ", false, false, null)));

            if (verboseLevel >= 1)
                System.out.println(indentString+"out CSG._intersect");
            return result;
        } // _intersect

        /** Computes the intersection of two signed polytopes. */
        public static SPolytope intersect(SPolytope A,
                                          SPolytope B)
        {
            SPolytope result = _intersect(A, B,
                                          /*ocean=*/new java.util.HashMap<HashableSortedArray<Hyperplane>,Object>(),
                                          "");

            // _intersect returns an empty polytope
            // as null for efficiency, but the rest of the world
            // can't be expected to handle it.
            if (result == null)
            {
                int fullDim = A.p.fullDim;
                do { if (!((fullDim)==(B.p.fullDim))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+7338 +"): (" + "fullDim" + ")" + "==" + "(" + "B.p.fullDim" + ") ("+(fullDim)+" vs. "+(B.p.fullDim)+")"); } while (false);
                int dim = fullDim - ((fullDim-A.p.dim)
                                   + (fullDim-B.p.dim));
                result = new SPolytope(0,1,
                                       new Polytope(dim,
                                                    fullDim,
                                                    new SPolytope[0],
                                                    new Hyperplane[0], // XXX uh oh, zero hyperplanes isn't really right, maybe should do the hyperplane union thing in case someone actually looks at this
                                                    null));
            }

            orientDeepFunctional(result); // XXX get rid of this when I get intersect to not fuck up the orientations to begin with
            orientDeepCosmetic(result); // XXX get rid of this when I get intersect to not fuck up the orientations to begin with
            return result;
        } // intersect

        /** Computes the complement of a signed polytope. */
        public static SPolytope complement(SPolytope sp)
        {
            return new SPolytope(1-sp.initialDensity,
                                 -sp.sign,
                                 sp.p);
        } // complement

        /** Computes the union of two signed polytopes. */
        public static SPolytope union(SPolytope A, SPolytope B)
        {
            return complement(intersect(complement(A), complement(B)));
        } // union

        /** Computes the difference of two signed polytopes. */
        private static SPolytope diff(SPolytope A, SPolytope B)
        {
            return intersect(A, complement(B));
        } // diff


        //
        // Assign signs to a (not-yet-finished)
        // n-dimensional polytope P,
        // its facets, and the facets of the facets, etc., recursively
        // in such a way that, for every flag:
        //      P, facet F, ridge R, ..., face f, edge e, vertex v,
        // the product of the signs of P, F, R, ..., f, e, v
        // should be the same as the sign of the volume of the simplex
        // whose vertices are the respective centers of those n+1 elements,
        // in order.
        // I.e. it should be equal to the sign of the determinant of the matrix
        // whose rows are the n vectors
        // i(F)-i(P), i(R)-i(P), ..., i(f)-i(P), i(e)-i(P), i(v)-i(P)
        // where i() denotes any interior point of the respective polytope.
        //
        // So, in particular,
        //    If n==1:  From left to right,
        //              segment starts are -, segment ends are +
        //    If n==2:  Walking CCW around a contour
        //              (i.e. with inside on the left and outside on the right),
        //              e.sign * initialVertex.sign is -
        //              and e.sign * finalVertex.sign is +
        //    If n==3: Walking on the surface
        //              along an edge e CCW around a face f,
        //              f.sign * e.sign * initialVertex.sign is -
        //              f.sign * e.sign * finalVertex.sign is +
        // etc.
        //
        // XXX should split this up into functional stuff
        // XXX and cosmetic stuff,
        // XXX and cosmetic stuff should be applied even to hypercubes
        // XXX and stuff.
        // XXX Actually I've done that, but haven't analyzed when it's appropriate to calll which, so callers generally still do both
        //
        public static void orientDeepFunctional(SPolytope sp)
        {
            boolean heavySanityChecksThroughout = false; // can turn this on for debugging

            if (verboseLevel >= 1)
                System.out.println("    in orientDeepFunctional");
            if (verboseLevel >= 2)
            {
                System.out.println("        Before anything:");
                System.out.println("        "+sp.toString("        "));
            }

            int dim = sp.p.dim;

            Polytope allElements[][] = sp.p.getAllElements();

            if (true)
            {
                for (int iDim = 0; (iDim) < (dim+1); ++iDim)
                {
                    Polytope ofDim[] = allElements[iDim];
                    int nOfDim = ofDim.length;
                    for (int iOfDim = 0; (iOfDim) < (nOfDim); ++iOfDim)
                        orientFacetsConsistently(ofDim[iOfDim]);
                }

                if (verboseLevel >= 1)
                    System.out.println("        After recursively orienting everyone consistently:");
                if (verboseLevel >= 2)
                    System.out.println("        "+sp.toString("        "));
            }

            if (false)
            {
                //
                // If total sign is wrong
                // (along some arbitrary flag),
                // then reverse the sign of sp so it becomes right.
                //
                System.out.println("WARNING: orientDeepFunctional global orientation not implemented yet"); // XXX
                if (verboseLevel >= 1)
                    System.out.println("    After fixing global sign if it was wrong:");
                if (verboseLevel >= 2)
                    System.out.println("        "+sp.toString("        "));
            }
            if (verboseLevel >= 1)
                System.out.println("out orientDeepFunctional");
        } // orientDeepFunctional
        public static void orientDeepCosmetic(SPolytope sp)
        {
            if (verboseLevel >= 1)
                System.out.println("    in orientDeepCosmetic");
            int dim = sp.p.dim;
            if (true)
            {
                if (dim >= 1)
                {
                    //
                    // Push sign of sp down into facets,
                    // making sign of sp +1.
                    //
                    int mySign = sp.sign;
                    SPolytope facets[] = sp.p.facets;
                    int nFacets = facets.length;
                    for (int iFacet = 0; (iFacet) < (nFacets); ++iFacet)
                        facets[iFacet].sign *= mySign;
                    sp.sign = 1;

                    if (verboseLevel >=1)
                        System.out.println("        After pushing sign down into facets:");
                    if (verboseLevel >=2)
                        System.out.println("        "+sp.toString("        "));

                    //
                    // Push sign of facet down into ridges,
                    // making the signs of all facets +1.
                    // Note this only makes sense when dim > 1.
                    // Also, it's pointless to do this any further:
                    // we can't make all ridge signs +,
                    // since they occur on multiple facets,
                    // in opposite-signed pairs.
                    //
                    if (dim >= 2)
                    {
                        for (int iFacet = 0; (iFacet) < (nFacets); ++iFacet)
                        {
                            SPolytope facet = facets[iFacet];
                            int facetSign = facet.sign;
                            if (facetSign != 1)
                            {
                                SPolytope ridgesThisFacet[] = facet.p.facets;
                                int nRidgesThisFacet = ridgesThisFacet.length;
                                for (int iRidgeThisFacet = 0; (iRidgeThisFacet) < (nRidgesThisFacet); ++iRidgeThisFacet)
                                    ridgesThisFacet[iRidgeThisFacet].sign *= facetSign;
                                facet.sign = 1;
                            }
                        }

                        if (verboseLevel >= 1)
                            System.out.println("        After pushing facet signs down into ridges:");
                        if (verboseLevel >= 2)
                            System.out.println("        "+sp.toString("        "));
                    }
                }
            }


            //
            // Edge cosmetic tweak:
            // for each edge, put the - vertex first and the + one second.
            // (If there are more than two vertices on the edge,
            // then don't worry about it.)
            //
            if (true)
            {
                if (dim >= 1)
                {
                    Polytope edges[] = sp.p.getAllElements()[1];
                    int nEdges = edges.length;
                    for (int iEdge = 0; (iEdge) < (nEdges); ++iEdge)
                    {
                        Polytope edge = edges[iEdge];
                        SPolytope vertsThisEdge[] = edge.facets;
                        if (vertsThisEdge.length == 2
                         && vertsThisEdge[0].sign == 1
                         && vertsThisEdge[1].sign == -1)
                        {
                            SPolytope temp;
                            {temp=(vertsThisEdge[0]);vertsThisEdge[0]=(vertsThisEdge[1]);vertsThisEdge[1]=(temp);};
                        }
                    }
                }

                if (verboseLevel >= 1)
                    System.out.println("        After edge cosmetic tweak:");
                if (verboseLevel >= 2)
                    System.out.println("        "+sp.toString("        "));
            }

            //
            // Face cosmetic tweak:
            // for each 2-d face, put the edges on each contour in order.
            // This requires that the edge cosmetic tweak (above)
            // was done first.
            // XXX this is O(n^2) where n is face size,
            // XXX so can be time-consuming
            // XXX for huge faces.
            //
            if (true)
            {
                if (dim >= 2)
                {
                    Polytope faces[] = sp.p.getAllElements()[2];
                    int nFaces = faces.length;
                    for (int iFace = 0; (iFace) < (nFaces); ++iFace)
                    {
                        Polytope p = faces[iFace];
                        if (verboseLevel >= 2)
                        {
                            System.out.println("    Doing face tweak on "+dimToPrefix(p.dim)+p.id);
                            {System.out.print("        "); System.out.println("p" + " = " + (p));};
                        }
                        SPolytope edges[] = p.facets;
                        int nEdges = edges.length;

                        int contourStart = 0;


                        Polytope initialVertexOnContour = null; // initialization not necessary, but to shut up compiler
                        if (contourStart < nEdges)
                        {
                            do { if (!(edges[contourStart].p.facets.length >= 2)) throw new Error("Assumption failed at "+"com/donhatchsw/util/CSG.prejava"+"("+7580 +"): " + "edges[contourStart].p.facets.length >= 2" + ""); } while (false); // XXX can't we have an edge that's all of the line!? think about this (also same below)
                            initialVertexOnContour = edges[contourStart].p.facets[((edges[contourStart].sign)==1?0:1)].p;
                        }


                        //
                        // See whether this face has any multi-edges.
                        // If it does, it's no use trying to cosmeticize
                        // this face.
                        //
                        {
                            int iEdge;
                            for (iEdge = 0; (iEdge) < (nEdges); ++iEdge)
                            {
                                SPolytope sedgeI = edges[iEdge];
                                Polytope edgeI = sedgeI.p;
                                if (edgeI.facets.length != 2
                                 || edgeI.facets[0].sign != -1
                                 || edgeI.facets[1].sign != 1)
                                    break;
                            }
                            if (iEdge < nEdges)
                                continue; // this face has a multi-edge or something, so it's hopeless
                        }

                        for (int iEdge = 0; (iEdge) < (nEdges); ++iEdge)
                        {
                            SPolytope sedgeI = edges[iEdge];
                            Polytope edgeI = sedgeI.p;
                            do { if (!((edgeI.facets.length)==(2))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+7609 +"): (" + "edgeI.facets.length" + ")" + "==" + "(" + "2" + ") ("+(edgeI.facets.length)+" vs. "+(2)+")"); } while (false);
                            do { if (!((edgeI.facets[0].sign)==(-1))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+7610 +"): (" + "edgeI.facets[0].sign" + ")" + "==" + "(" + "-1" + ") ("+(edgeI.facets[0].sign)+" vs. "+(-1)+")"); } while (false);
                            do { if (!((edgeI.facets[1].sign)==(1))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+7611 +"): (" + "edgeI.facets[1].sign" + ")" + "==" + "(" + "1" + ") ("+(edgeI.facets[1].sign)+" vs. "+(1)+")"); } while (false);
                            Polytope finalVertexOnEdgeI = edgeI.facets[((sedgeI.sign)==1?1:0)].p;
                            if (finalVertexOnEdgeI
                             == initialVertexOnContour)
                            {
                                // iEdge is the last edge on this contour.
                                contourStart = iEdge+1;
                                if (contourStart < nEdges)
                                {
                                    do { if (!(edges[contourStart].p.facets.length >= 2)) throw new Error("Assumption failed at "+"com/donhatchsw/util/CSG.prejava"+"("+7620 +"): " + "edges[contourStart].p.facets.length >= 2" + ""); } while (false); // XXX can't we have an edge that's all of the line!? think about this. (also same above)
                                    initialVertexOnContour = edges[contourStart].p.facets[((edges[contourStart].sign)==1?0:1)].p;
                                }
                            }
                            else
                            {
                                // iEdge is not the last edge on this contour;
                                // find the next one.
                                int jEdge;
                                for (jEdge = iEdge+1; jEdge < nEdges; jEdge++)
                                {
                                    SPolytope sedgeJ = edges[jEdge];
                                    Polytope edgeJ = sedgeJ.p;
                                    Polytope initialVertexOnEdgeJ = edgeJ.facets[((sedgeJ.sign)==1?0:1)].p;
                                    if (initialVertexOnEdgeJ == finalVertexOnEdgeI)
                                        break; // found next
                                }
                                do { if (!(jEdge < nEdges)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+7637 +"): " + "jEdge < nEdges" + ""); } while (false); // found next
                                if (jEdge > iEdge+1)
                                {
                                    SPolytope temp;
                                    {temp=(edges[iEdge+1]);edges[iEdge+1]=(edges[jEdge]);edges[jEdge]=(temp);};
                                }
                            }
                        }
                    }
                }
                if (verboseLevel >= 1)
                    System.out.println("        After face cosmetic tweak:");
                if (verboseLevel >= 2)
                    System.out.println("        "+sp.toString("        "));
            } // face cosmetic tweak

            //
            // XXX One more potential nice cosmetic tweak:
            // XXX prefer nice orderings for earlier facets.
            //
            {
            }

            if (verboseLevel >= 1)
                System.out.println("    out orientDeepCosmetic");
        } // orientDeepCosmetic



        //
        // p is an unfinished polytope (meaning we can and do
        // change it in place).
        // Assumes all facets' facets, etc. are already consistently oriented;
        // i.e. this must be called in a bottom-up order.
        //
        private static void orientFacetsConsistently(Polytope p)
        {
            if (verboseLevel >= 2)
            {
                System.out.println("in orientFacetsConsistently("+dimToPrefix(p.dim)+p.id+")");
                if (verboseLevel >= 3)
                    {System.out.print("        "); System.out.println("p" + " = " + (p));};
            }
            SPolytope facets[] = p.facets;
            int nFacets = facets.length;

            if (nFacets == 0)
            {
                if (verboseLevel >= 2)
                    System.out.println("out orientFacetsConsistently, boy that was hard :-)");
                return;
            }

            if (p.dim == 1)
            {
                if (nFacets > 2) // XXX maybe should do this anyway, for testing?
                {
                    //
                    // Take the farthest vertex from v0,
                    // and call it b.  Take the farthest vertex from b,
                    // and call it a.
                    // 
                    double a[], b[];
                    {
                        double from[] = facets[0].p.getCoords();
                        double farthest[] = null;
                        {
                            double farthestDistSqrd = Double.NEGATIVE_INFINITY;
                            for (int iFacet = 0; (iFacet) < (nFacets); ++iFacet)
                            {
                                double thisCoords[] = facets[iFacet].p.getCoords();
                                double thisDistSqrd = VecMath.distsqrd(from, thisCoords);
                                if (thisDistSqrd > farthestDistSqrd)
                                {
                                    farthest = thisCoords;
                                    farthestDistSqrd = thisDistSqrd;
                                }
                            }
                            do { if (!(farthest != null)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+7715 +"): " + "farthest != null" + ""); } while (false);
                        }
                        b = farthest;
                        from = b;
                        {
                            double farthestDistSqrd = Double.NEGATIVE_INFINITY;
                            for (int iFacet = 0; (iFacet) < (nFacets); ++iFacet)
                            {
                                double thisCoords[] = facets[iFacet].p.getCoords();
                                double thisDistSqrd = VecMath.distsqrd(from, thisCoords);
                                if (thisDistSqrd > farthestDistSqrd)
                                {
                                    farthest = thisCoords;
                                    farthestDistSqrd = thisDistSqrd;
                                }
                            }
                            do { if (!(farthest != null)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+7731 +"): " + "farthest != null" + ""); } while (false);
                        }
                        a = farthest;
                    }

                    final double dir[] = VecMath.vmv(b, a);

                    //
                    // Sort along dir...
                    //
                    SortStuff.sort(facets,
                                   new SortStuff.Comparator() {
                                       @Override public int compare(Object _a, Object _b)
                                       {
                                           SPolytope A = (SPolytope)_a;
                                           SPolytope B = (SPolytope)_b;
                                           double aDot = VecMath.dot(A.p.getCoords(), dir);
                                           double bDot = VecMath.dot(B.p.getCoords(), dir);
                                           return aDot < bDot ? -1 :
                                                  aDot > bDot ? 1 : 0;
                                       }
                                   });
                } // if (nFacets > 2)

                int sign = -1;
                for (int iFacet = 0; (iFacet) < (nFacets); ++iFacet)
                {
                    facets[iFacet].sign = sign;
                    sign = -sign;
                }
                if (verboseLevel >= 2)
                    System.out.println("out orientFacetsConsistently, edges are easy");
                return;
            }

            //
            // facetNeighbors[iFacet][iRidgeOnFacet][0] is the index
            // of the other facet sharing that ridge, and
            // facetNeighbors[iFacet][iRidgeOnFacet][1]
            // is the index of the ridge in the neighbor facet's facet list.
            // XXX perhaps finished polytopes should always have these tables
            // XXX so we don't have to recalculate them?
            // XXX YES, I think I'm on the road to that with getAllIncidences
            //
            int facetNeighbors[][][] = new int[nFacets][][/*2*/];
            {
                for (int iFacet = 0; (iFacet) < (nFacets); ++iFacet)
                    facetNeighbors[iFacet] = new int[facets[iFacet].p.facets.length][/*2*/];
                java.util.HashMap<Polytope,int[]> firstFacetContainingRidge = new java.util.HashMap<Polytope,int[]>();
                for (int iFacet = 0; (iFacet) < (nFacets); ++iFacet)
                {
                    Polytope facet = facets[iFacet].p;
                    SPolytope ridgesThisFacet[] = facet.facets;
                    int nRidgesThisFacet = ridgesThisFacet.length;
                    for (int iRidgeThisFacet = 0; (iRidgeThisFacet) < (nRidgesThisFacet); ++iRidgeThisFacet)
                    {
                        Polytope ridge = ridgesThisFacet[iRidgeThisFacet].p;
                        int myInfo[] = {iFacet, iRidgeThisFacet};
                        int neighborInfo[] = firstFacetContainingRidge.remove(ridge);
                        if (neighborInfo == null)
                        {
                            firstFacetContainingRidge.put(ridge, myInfo);
                        }
                        else
                        {
                            facetNeighbors[iFacet][iRidgeThisFacet] = neighborInfo;
                            facetNeighbors[neighborInfo[0]][neighborInfo[1]] = myInfo;
                        }
                    }
                }
                do { if (!((firstFacetContainingRidge.size())==(0))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+7801 +"): (" + "firstFacetContainingRidge.size()" + ")" + "==" + "(" + "0" + ") ("+(firstFacetContainingRidge.size())+" vs. "+(0)+")"); } while (false); // everything matched XXX change this assert to failure I think
            } // facetNeighbors

            int signOfFirstFacet = 1; // arbitrarily XXX is there a better choice?
            boolean isSigned[] = new boolean[nFacets];
            for (int iFacet = 0; (iFacet) < (nFacets); ++iFacet)
                isSigned[iFacet] = false;

            SPolytope contours[][] = new SPolytope[nFacets][]; // worst case
            int nContours = 0; // and counting
            SPolytope currentContour[] = new SPolytope[nFacets];

            int stackHeight = 0;
            int stack[] = new int[nFacets];
            for (int contourStart = 0; (contourStart) < (nFacets); ++contourStart)
            {
                if (!isSigned[contourStart])
                {
                    int currentContourSize = 0;
                    {
                        int iFacet = contourStart;
                        SPolytope facet = facets[iFacet];
                        facet.sign = signOfFirstFacet;
                        isSigned[iFacet] = true;
                        stack[stackHeight++] = iFacet; // push iFacet on to stack
                        currentContour[currentContourSize++] = facets[iFacet];
                    }
                    while (stackHeight != 0)
                    {
                        int iFacet = stack[--stackHeight]; // pop iFacet off of stack
                        SPolytope facet = facets[iFacet];
                        SPolytope ridgesThisFacet[] = facet.p.facets;
                        int nRidgesThisFacet = ridgesThisFacet.length;
                        for (int iRidgeThisFacet = 0; (iRidgeThisFacet) < (nRidgesThisFacet); ++iRidgeThisFacet)
                        {
                            int neighborInfo[/*2*/] = facetNeighbors[iFacet][iRidgeThisFacet];
                            int iNeighbor = neighborInfo[0];
                            int iRidgeNeighborFacet = neighborInfo[1];

                            if (!isSigned[iNeighbor])
                            {
                                //System.out.println(""+iFacet+" -> "+iNeighbor+"");
                                SPolytope neighborFacet = facets[iNeighbor];
                                SPolytope ridgesNeighborFacet[] = neighborFacet.p.facets;

                                // Want facets[iFacet].sign
                                //          * ridgesThisFacet[iRidgeThisFacet].sign
                                //  = - facets[iNeighbor].sign
                                //          * ridgesNeighborFacet[iRidgeNeighborFacet].sign.
                                int signOfRidgeOnNeighbor = ridgesNeighborFacet[iRidgeNeighborFacet].sign;
                                do { if (!(signOfRidgeOnNeighbor == 1 || signOfRidgeOnNeighbor == -1)) throw new Error("Assumption failed at "+"com/donhatchsw/util/CSG.prejava"+"("+7851 +"): " + "signOfRidgeOnNeighbor == 1 || signOfRidgeOnNeighbor == -1" + ""); } while (false)
                                                                    ; // otherwise should be / instead of * below, and I'm not sure what it means if it doesn't divide evenly, have to think about it some day

                                neighborFacet.sign = -facet.sign
                                                   * ridgesThisFacet[iRidgeThisFacet].sign
                                                   * signOfRidgeOnNeighbor;
                                isSigned[iNeighbor] = true;
                                stack[stackHeight++] = iNeighbor; // push iNeighbor on to stack
                                currentContour[currentContourSize++] = facets[iNeighbor];
                            }
                            else
                            {
                                //System.out.println("("+iFacet+" -> "+iNeighbor+")");
                            }
                        }
                    } // while (stackHeight != 0)
                    contours[nContours++] = (SPolytope[])Arrays.subarray(currentContour, 0, currentContourSize);
                }
            } // for contourStart
            for (int iFacet = 0; (iFacet) < (nFacets); ++iFacet)
                do { if (!(isSigned[iFacet])) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+7871 +"): " + "isSigned[iFacet]" + ""); } while (false);

            //
            // Make temporary SPolytopes out of the contours...
            // XXX should avoid this if only one contour, maybe
            //
            SPolytope contourSPolytopes[] = new SPolytope[nContours];
            {
                for (int iContour = 0; (iContour) < (nContours); ++iContour)
                    contourSPolytopes[iContour] = new SPolytope(0,1,
                                        new Polytope(p.dim,
                                                     p.fullDim,
                                                     contours[iContour],
                                                     p.contributingHyperplanes,
                                                     p.aux));
            }

            contours = null; // make sure we don't use it by accident after this

            //
            // Find the coordinate axis in which the bbox is the largest,
            // and sort the contour list according to
            // minimum coordinate along this coordinate axis.
            // Then an item in the sorted list
            // cannot contain any earlier item.
            //
            double bbox[][] = p.getBBox();
            double bboxSize[] = VecMath.vmv(bbox[1], bbox[0]);
            final int ax = VecMath.maxi(bboxSize);
            SortStuff.sort(contourSPolytopes,
                   new SortStuff.Comparator() {
                       @Override public int compare(Object _a, Object _b)
                       {
                           SPolytope a = (SPolytope)_a;
                           SPolytope b = (SPolytope)_b;
                           double aDot = a.p.getBBox()[0][ax];
                           double bDot = b.p.getBBox()[0][ax];
                           return aDot < bDot ? -1 :
                                  aDot > bDot ? 1 : 0;
                       }
                   });


            if (verboseLevel >= 2
             && nContours > 1)
            {
                System.out.println("The contours:\n");
                for (int iContour = 0; (iContour) < (nContours); ++iContour)
                {
                    System.out.println("    "+iContour+":");
                    System.out.println(contourSPolytopes[iContour]);
                }
            }


            //
            // Make a tree whose nodes are the contours,
            // ordered by contour inclusion.
            //
            int root = 0;
            int firstChild[] = VecMath.fillvec(nContours, -1);
            int nextSibling[] = VecMath.fillvec(nContours, -1);
            {
                double tol = 1e-12; // XXX ad-hoc, need to make a coherent scheme
                // scratch for loop...
                    int densityMinMax[] = new int[2];

                for (int iContour = 1; iContour < nContours; ++iContour) // skip 0, it's already on the tree as the root
                {
                    double anyCoordsOnContour[];
                    {
                        // v = any vertex on contour iContour
                        Polytope v = contourSPolytopes[iContour].p;
                        while (v.dim > 0)
                            v = v.facets[0].p;
                        anyCoordsOnContour = v.getCoords();
                    }

                    // Hang iContour on the tree.
                    // Walk down the tree starting with root...
                    for (int iNode = root; ;)
                    {
                        SPolytope nodeSPolytope = contourSPolytopes[iNode];
                        calcDensity(nodeSPolytope,
                                    anyCoordsOnContour,
                                    tol,
                                    densityMinMax);
                        int density = densityMinMax[0];
                        do { if (!(density == densityMinMax[1])) throw new Error("Assumption failed at "+"com/donhatchsw/util/CSG.prejava"+"("+7959 +"): " + "density == densityMinMax[1]" + ""); } while (false); // must be unambiguous
                        boolean isContainedInNode = (density&1) == 1;
                        if (isContainedInNode)
                        {
                            // proceed on to children
                            if (firstChild[iNode] == -1)
                            {
                                firstChild[iNode] = iContour;
                                break;
                            }
                            iNode = firstChild[iNode];
                        }
                        else
                        {
                            // proceed on to next sibling
                            if (nextSibling[iNode] == -1)
                            {
                                nextSibling[iNode] = iContour;
                                break;
                            }
                            iNode = nextSibling[iNode];
                        }
                    }
                }
            }
            if (verboseLevel >= 2
             && nContours > 1)
            {
                System.out.println("        " + "firstChild" + " =\n" + VecMath.toString(firstChild));
                System.out.println("        " + "nextSibling" + " =\n" + VecMath.toString(nextSibling));
            }

            double normals[][] = new double[p.contributingHyperplanes.length][];
            {
                for (int iHyperplane = 0; (iHyperplane) < (normals.length); ++iHyperplane)
                    normals[iHyperplane] = p.contributingHyperplanes[iHyperplane].normal;
            }

            //
            // Start by orienting all the contours in the same direction
            // (e.g. all counterclockwise).
            //
            {
                for (int iContour = 0; (iContour) < (nContours); ++iContour)
                {
                    SPolytope contourSPolytope = contourSPolytopes[iContour];
                    double volume = volume(contourSPolytope);
                    if (volume < 0)
                    {
                        SPolytope facetsThisContour[] = contourSPolytope.p.facets;
                        int nFacetsThisContour = facetsThisContour.length;
                        for (int iFacetThisContour = 0; (iFacetThisContour) < (nFacetsThisContour); ++iFacetThisContour)
                        {
                            SPolytope facet = facetsThisContour[iFacetThisContour];
                            facet.sign = -facet.sign;
                        }
                    }
                }
            }

            //
            // Reverse the signs of alternate levels of contours.
            // We use each contourSPolytope's sign to store +-1
            // depending on whether we are reversing it or not.
            // (the final value of its sign doesn't matter
            // since it is getting thrown away).
            //
            {
                for (int iContour = 0; (iContour) < (nContours); ++iContour)
                {
                    SPolytope contourSPolytope = contourSPolytopes[iContour];
                    int sign = contourSPolytope.sign;
                    if (sign < 0)
                    {
                        SPolytope facetsThisContour[] = contourSPolytope.p.facets;
                        int nFacetsThisContour = facetsThisContour.length;
                        for (int iFacetThisContour = 0; (iFacetThisContour) < (nFacetsThisContour); ++iFacetThisContour)
                        {
                            SPolytope facet = facetsThisContour[iFacetThisContour];
                            facet.sign = -facet.sign;
                        }
                    }
                    if (firstChild[iContour] != -1)
                        contourSPolytopes[firstChild[iContour]].sign = -sign;
                    if (nextSibling[iContour] != -1)
                        contourSPolytopes[nextSibling[iContour]].sign = sign;
                }
            }

            if (verboseLevel >= 2)
                System.out.println("out orientFacetsConsistently("+dimToPrefix(p.dim)+p.id+")");
        } // orientFacetsConsistently


// XXX I think PolyCSG should deal with SPolytopes, not Polytopes...
// XXX then this won't be necessary.  At least I think that's what I think.


        /** Computes the union of two unsigned polytopes. */
        public static Polytope union(Polytope A, Polytope B)
        {
            return union(new SPolytope(0,1,A),
                         new SPolytope(0,1,B)).p;
        } // union of unsigned Polytopes
        /** Computes the intersection of two unsigned polytopes. */
        public static Polytope intersect(Polytope A, Polytope B)
        {
            return intersect(new SPolytope(0,1,A),
                             new SPolytope(0,1,B)).p;
        } // intersect of unsigned Polytopes
        /** Computes the difference of two unsigned polytopes. */
        public static Polytope diff(Polytope A, Polytope B)
        {
            return diff(new SPolytope(0,1,A),
                        new SPolytope(0,1,B)).p;
        } // diff of unsigned Polytopes


        private static String signToString(int sign)
        {
            return sign == 1 ? "+" :
                   sign == -1 ? "-" :
                   sign == 0 ? "!" :
                   "(sign="+sign+")";
        } // signToString

        private static String dimToPrefix(int dim)
        {
            if (dim <= 4)
                return "vefch".substring(dim,dim+1);
            else
                return "(" + dim + "d)"; // sort of lame but it's the best I can think of at the moment, and it doesn't seem to look too bad
        } // dimToPrefix

        // XXX this is really lame, should maybe restructure so we don't need it
        private static Object itemOfAThatsNotInB(Object A[], Object B[])
        {
            int iA, nA = A.length;
            int iB, nB = B.length;
            for (iA = 0; (iA) < (nA); ++iA)
            {
                for (iB = 0; (iB) < (nB); ++iB)
                    if (A[iA] == B[iB])
                        break;
                if (iB == nB) // A[iA] was not in B
                    return A[iA];
            }
            do { if (!(false)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+8106 +"): " + "false" + ""); } while (false);
            return null;
        } // itemOfAThatsNotInB

        // XXX used by slice, remove if I get rid of slice
        private static Hyperplane[] addOneHyperplaneAndSort(Hyperplane[] list, Hyperplane last)
        {
            list = (Hyperplane[])Arrays.append(list, last);
            SortStuff.sort(list,
                           new SortStuff.Comparator() {
                               @Override public int compare(Object _a, Object _b)
                               {
                                   Hyperplane a = (Hyperplane)_a;
                                   Hyperplane b = (Hyperplane)_b;
                                   return a.id < b.id ? -1 :
                                          a.id > b.id ? 1 : 0;
                               }
                           });
            return list;
        } // addOneHyperplaneAndSort

        private static Hyperplane[] unionOfHyperplanesAndSort(Hyperplane[] these, Hyperplane[] those)
        {
            Hyperplane list[] = (Hyperplane[])Arrays.concat(these, those);
            SortStuff.Comparator comparator =
               new SortStuff.Comparator() {
                   @Override public int compare(Object _a, Object _b)
                   {
                       Hyperplane a = (Hyperplane)_a;
                       Hyperplane b = (Hyperplane)_b;
                       return a.id < b.id ? -1 :
                              a.id > b.id ? 1 : 0;
                   }
               };

            SortStuff.sort(list, comparator);
            int n = SortStuff.nodup(list, list.length, comparator);
            list = (Hyperplane[])Arrays.subarray(list, 0, n);
            return list;
        } // unionOfHyperplanesAndSort

        // return the point that is the intersection of n hyperplanes in n dimensions.
        private static double[] intersectHyperplanes(Hyperplane hyperplanes[])
        {
            int nHyperplanes = hyperplanes.length;
            if (nHyperplanes == 0)
                return new double[0];
            for (int i = 0; i < hyperplanes.length; ++i)
            {
                // Note, it is *not* necessarily true that the number of hyperplanes
                // is equal to the dimension of the space.
                // E.g. for octahedron {3,4}, we store 4 hyperplanes (not 3) at each vertex;
                // and a vertex coord can be found by intersecting the 4 hyperplanes,
                // (which is an overconstrained system, for which we return the least-squares solution).
                do { if (!((hyperplanes[i].normal.length)==(hyperplanes[0].normal.length))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+8160 +"): (" + "hyperplanes[i].normal.length" + ")" + "==" + "(" + "hyperplanes[0].normal.length" + ") ("+(hyperplanes[i].normal.length)+" vs. "+(hyperplanes[0].normal.length)+")"); } while (false);
                do { if (!((nHyperplanes)>=(hyperplanes[i].normal.length))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+8161 +"): (" + "nHyperplanes" + ")" + ">=" + "(" + "hyperplanes[i].normal.length" + ") ("+(nHyperplanes)+" vs. "+(hyperplanes[i].normal.length)+")"); } while (false);
            }
            int iHyperplane;
            for (iHyperplane = 0; (iHyperplane) < (nHyperplanes); ++iHyperplane)
            {
                if (hyperplanes[iHyperplane].spanningPoints == null)
                    break; // this hyperplane is not defined by spanning points
            }
            if (iHyperplane == nHyperplanes)
            {
                //
                // All hyperplanes
                // are from spanning points.
                // We just need to find the one point
                // that is in the spanning set of all of them.
                //
                do { if (!(nHyperplanes > 0)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+8177 +"): " + "nHyperplanes > 0" + ""); } while (false); // we would have returned early above
                int iSpanningPoint, nSpanningPoints = hyperplanes[0].spanningPoints.length;
                for (iSpanningPoint = 0; (iSpanningPoint) < (nSpanningPoints); ++iSpanningPoint)
                {
                    double point[] = hyperplanes[0].spanningPoints[iSpanningPoint];
                    for (iHyperplane = 1; iHyperplane < nHyperplanes; ++iHyperplane)
                        if (Arrays.indexOfUsingEqualsSymbol(hyperplanes[iHyperplane].spanningPoints, point) == -1)
                            break; // it's not in this one
                    if (iHyperplane == nHyperplanes)
                    {
                        // It's in all of them!
                        return point;
                    }
                }
                do { if (!(false)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+8191 +"): " + "false" + ""); } while (false); // XXX not sure if this can happen or not, so flag it for now and think about it if it goes off
            }

            //
            // Calculate explicit coords of the vertex.
            // We want column vector c
            // such that
            //    normal0 dot c == offset0
            //    normal1 dot c == offset1
            //    normal2 dot c == offset2
            //    ...
            // so c = inv(normalsMatrix) * offsetsColumnVector.
            // It's okay if there are more equations (planes)
            // than unknowns (dimensions);
            // in that case the solver will find the least-squares solution.
            // This is a nice thing to do, e.g. in the case of an octahedron.
            //
            int nRows = hyperplanes.length;
            int nCols = hyperplanes[0].normal.length;
            double normalsMatrix[][] = new double[nRows][nCols];
            double offsetsColumnVector[] = new double[nRows];
            for (int iRow = 0; (iRow) < (nRows); ++iRow)
            {
                VecMath.copyvec(normalsMatrix[iRow], hyperplanes[iRow].normal);
                offsetsColumnVector[iRow] = hyperplanes[iRow].offset;
            }
            double c[] = VecMath.invmxv(normalsMatrix, offsetsColumnVector);

            // XXX not an adequate test, I don't think
            if (c.length > 0
             && (Double.isInfinite(c[0])
              || Double.isNaN(c[0])))
                return null;

            return c;
        } // intersectHyperplanes



        //
        // Wrapper for a sorted array,
        // allowing it to be used as a hash key and value.
        // Equality is based on equality of the component items.
        // The hash code is the xor of all the component items' hash codes.
        // XXX should use sum, like some java structures do? think about it
        //
        private static class HashableSortedArray<E>
        {
            private E array[];
            public HashableSortedArray(E array[])
            {
                this.array = array;
            }
            public int hashCode()
            {
                int hashCode = 0;
                int n = array.length;
                for (int i = 0; (i) < (n); ++i)
                    hashCode ^= array[i].hashCode();
                return hashCode;
            } // equals
            @SuppressWarnings("unchecked") // TODO: get rid of this if possible
            public boolean equals(Object _that)
            {
                HashableSortedArray<E> that = (HashableSortedArray<E>)_that;
                Object[] these = this.array;
                Object[] those = that.array;
                int nThese = these.length, nThose = those.length;
                if (nThese != nThose)
                    return false;
                for (int i = 0; (i) < (nThese); ++i)
                    if (!these[i].equals(those[i]))
                        return false;
                return true;
            } // equals
        } // class HashableSortedArray

        private static class HashablePair
        {
            private Object first, second;
            public HashablePair(Object first, Object second)
            {
                this.first = first;
                this.second = second;
            }
            public int hashCode()
            {
                return 3*(this.first==null ? 41 : this.first.hashCode())
                       + (this.second==null ? 103 : this.second.hashCode());
            }
            public boolean equals(Object _that)
            {
                HashablePair that = (HashablePair)_that;
                return (this.first==null ? that.first==null : this.first.equals(that.first))
                    && (this.second==null ? that.second==null : this.second.equals(that.second));
            }
        } // class HashablePair


        private static int factorial(int n)
        {
            return n==0 ? 1 : n*factorial(n-1);
        }
        private static int intpow(int a, int b)
        {
            return b==0 ? 1 : intpow(a, b-1) * a;
        }
        private static int digit(int x, int i, int base)
        {
            return x / intpow(base,i) % base;
        }
        private static String intToString(int x, int base)
        {
            return (x>base ? intToString(x/base,base) : "") + x%base;
        }

        private static int numOccurancesOf(String str, String substr)
        {
            int numOccurances = 0;
            int i = -1;
            while ((i = str.indexOf(substr, i+1)) != -1)
                numOccurances++;
            return numOccurances;
        } // numOccurancesOf


    private static final boolean evalVerbose = false;
    /**
    *  Evaluate an expression such as "<code>(-((A-B) i (A i D))) u C</code>"
    *  from the beginning of a string,
    *  leaving the unparsed remainder of the string in the "rest" parameter.
    */
    public static SPolytope eval(
                String expr, // XXX term, really... sorry for the confusion
                int dim,
                int fullDim,
                String varNames[/*1*/][], // array is passed by ref so can be resized
                SPolytope varValues[/*1*/][], // array is passed by ref so can be resized
                String rest[/*1*/]) // unparsed remainder of string is returned here
        throws java.text.ParseException
    {
        SPolytope result = null;
        String orig_expr = expr; // for error messages

        expr = expr.trim();
        if (expr.length() == 0)
            throw new java.text.ParseException("Empty expression \""+expr+"\"", orig_expr.length()-expr.length());
        char firstChar = expr.charAt(0);
        expr = expr.substring(1);

        if (firstChar == '0')
        {
            if (evalVerbose) System.out.println("\""+orig_expr+"\": expr -> 0");
            result = new SPolytope(0,1,
                                   new Polytope(dim,
                                                fullDim,
                                                new SPolytope[0], // no facets
                                                new Hyperplane[0], // no hyperplanes
                                                null)); // no aux // XXX use substring?
        }
        else if (firstChar == '1')
        {
            if (evalVerbose) System.out.println("\""+orig_expr+"\": expr -> 1");
            result = new SPolytope(1,1,
                                   new Polytope(dim,
                                                fullDim,
                                                new SPolytope[0], // no facets
                                                new Hyperplane[0], // no hyperplanes
                                                null)); // no aux // XXX use substring?
        }
        else if ("-~".indexOf(firstChar) != -1)
        {
            if (evalVerbose) System.out.println("\""+orig_expr+"\": expr -> -expr");
            SPolytope operand = eval(expr,
                                     dim,
                                     fullDim,
                                     varNames,
                                     varValues,
                                     rest);
            expr = rest[0];
            result = complement(operand);
        }
        else if (firstChar == 's'
              && expr.startsWith("can(\""))
        {
            if (evalVerbose) System.out.println("\""+orig_expr+"\": expr -> scan(\"quoted_string\")");
            int endQuoteIndex = expr.indexOf("\"", 5);
            if (endQuoteIndex < 0)
                throw new java.text.ParseException("bad bad bad expression \""+orig_expr+"\"", orig_expr.length()-expr.length());
            String fileName = expr.substring(5, endQuoteIndex);

            expr = expr.substring(endQuoteIndex+1);
            if (!expr.startsWith(")"))
                throw new java.text.ParseException("bad bad bad expression \""+orig_expr+"\"", orig_expr.length()-expr.length());
            expr = expr.substring(1);

            try {
                java.io.BufferedReader reader = new java.io.BufferedReader(new java.io.FileReader(fileName));
                StringBuffer sb = new StringBuffer();
                char buf[] = new char[1024];
                int numRead = 0;
                while ((numRead = reader.read(buf)) > -1)
                    sb.append(String.valueOf(buf, 0, numRead));
                reader.close();
                String fileContents = sb.toString();
                result = SPolytope.fromStringInPcalcFormat(fileContents);
                // XXX LAME!  should be a method that reads from a Reader instead of having to slurp the whole file!
            }
            catch (java.io.IOException e)
            {
                throw new java.text.ParseException("Fooey, something went wrong reading file \""+fileName+"\": "+e, orig_expr.length()-expr.length());
            }
        }
        else if (firstChar == '(')
        {
            if (evalVerbose) System.out.println("\""+orig_expr+"\": expr -> (something)  (not sure))");
            SPolytope LHS = eval(expr,
                                 dim,
                                 fullDim,
                                 varNames,
                                 varValues,
                                 rest);
            expr = rest[0];
            expr = expr.trim(); // XXX actually only need to trim at beginning
            if (expr.length() == 0)
                throw new java.text.ParseException("Premature end of expression \""+orig_expr+"\"",orig_expr.length()-expr.length());
            char operatorChar = expr.charAt(0);
            expr = expr.substring(1);

            if (operatorChar == ')')
            {
                if (evalVerbose) System.out.println("\""+orig_expr+"\": expr -> (expr)  (now I'm sure)");
                result = LHS;
            }
            else
            {
                SPolytope RHS = eval(expr,
                                     dim,
                                     fullDim,
                                     varNames,
                                     varValues,
                                     rest);
                expr = rest[0];
                if (expr.length() == 0)
                    throw new java.text.ParseException("Unmatched left paren in expression \""+orig_expr+"\"",orig_expr.length()-expr.length());
                char shouldBeCloseParen = expr.charAt(0);
                expr = expr.substring(1);
                if (shouldBeCloseParen != ')')
                    throw new java.text.ParseException("Expected ')', got '"+shouldBeCloseParen+"' in expression \""+orig_expr+"\"",orig_expr.length()-expr.length());

                if (evalVerbose) System.out.println("\""+orig_expr+"\": expr -> (expr binop expr)  (now I'm sure)");

                if ("i&".indexOf(operatorChar) != -1)
                    result = intersect(LHS, RHS);
                else if ("u|".indexOf(operatorChar) != -1)
                    result = union(LHS, RHS);
                else if ("dm-\\".indexOf(operatorChar) != -1)
                    result = diff(LHS, RHS);
                else if ("*x".indexOf(operatorChar) != -1)
                    result = cross(LHS, RHS);
                else
                    throw new java.text.ParseException("Unknown binary operation '"+operatorChar+"' in expression \""+orig_expr+"\"",orig_expr.length()-expr.length());
                if (evalVerbose) System.out.println("\""+orig_expr+"\": expr -> (expr "+operatorChar+" expr)");
            }
        }
        else if (Character.isJavaIdentifierStart(firstChar))
        {
            if (evalVerbose) System.out.println("\""+orig_expr+"\": expr -> varName and maybe assignment, not sure");
            String varName = ""+firstChar;
            while (expr.length() > 0
                && Character.isJavaIdentifierPart(firstChar = expr.charAt(0)))
            {
                varName += firstChar;
                expr = expr.substring(1);
            }

            int iVar, nVars = varNames[0].length;
            for (iVar = 0; (iVar) < (nVars); ++iVar)
                if (varName.equals(varNames[0][iVar]))
                    break;

            // XXX grammar is violated here... we are making varName=value
            // XXX into a term when it should be an expression;
            // XXX e.g.  A - B = C  is legal
            // XXX and is equivalent to A - (B = C),
            // XXX when it shouldn't be legal :-(
            // XXX also A=B-C gets evaluated as (A=B)-C :-( :-(
            // XXX really need to fix this
            expr = expr.trim();
            if (expr.length() >= 1
             && expr.charAt(0) == '=')
            {
                expr = expr.substring(1);

                expr = expr.trim(); // XXX should be only at beginning
                if (expr.length() == 0
                 || expr.startsWith(")"))
                {
                    // unset the variable-- that is, crunch it out
                    // of both arrays, keeping the arrays in order.
                    if (iVar < nVars)
                    {
                        varNames[0] = (String[])Arrays.concat(
                            Arrays.subarray(varNames[0],0,iVar),
                            Arrays.subarray(varNames[0],iVar+1,nVars-(iVar+1)));
                        varValues[0] = (SPolytope[])Arrays.concat(
                            Arrays.subarray(varValues[0],0,iVar),
                            Arrays.subarray(varValues[0],iVar+1,nVars-(iVar+1)));
                    }

                    result = null;
                }
                else
                {
                    SPolytope RHS = eval(expr,
                                         dim,
                                         fullDim,
                                         varNames,
                                         varValues,
                                         rest);
                    expr = rest[0];

                    if (iVar == nVars)
                    {
                        // append the new name,value pair
                        varNames[0] = (String[])Arrays.append(varNames[0], varName);
                        varValues[0] = (SPolytope[])Arrays.append(varValues[0], RHS);
                    }
                    else
                    {
                        // replace old value
                        varValues[0][iVar] = RHS;
                    }

                    result = RHS;
                }
            }
            else
            {
                if (iVar == nVars)
                    throw new java.text.ParseException("Undefined variable \""+varName+"\" in expression \""+orig_expr+"\"",orig_expr.length()-expr.length());
                result = varValues[0][iVar];
            }
        }
        else
        {
            throw new java.text.ParseException("Unexpected first char '"+firstChar+"' in expression \""+orig_expr+"\"",orig_expr.length()-expr.length());
        }

        rest[0] = expr;
        return result;
    } // eval

    /**
    *  Evaluate an expression such as "<code>(-((A-B) i (A i D))) u C</code>".
    *  The grammar is:
    *  <pre>
    * 
    *           expr -&gt; term
    *           expr -&gt; term [i&amp;^*] term // intersect(LHS,RHS)
    *           expr -&gt; term [u|+] term  // union(LHS,RHS)
    *           expr -&gt; term [-\dm] term // diff(LHS,RHS)
    *           expr -&gt; varName = expr   // sets varName's value to value of expr
    *           term -&gt; "0"              // empty set
    *           term -&gt; "1"              // all of space
    *           term -&gt; varName          // corresponding varValue
    *           term -&gt; [~-] term        // complement(RHS)
    *           term -&gt; "(" expr ")"
    *           term -&gt; scan "(" quoted_string ")"
    *  </pre>
    * 
    *  Note all the alternative operator chars; I'm wishy washy.
    *  The ones that are letters must be separated from adjacent variable names
    *  by spaces.
    * 
    *  XXX need a way to unset a variable
    */
    public static SPolytope eval(
                String expr,
                int dim,
                int fullDim,
                String varNames[/*1*/][], // array is passed by ref so can be resized
                SPolytope varValues[/*1*/][]) // array is passed by ref so can be resized
        throws java.text.ParseException
    {
        String rest[] = new String[1];
        String term = "("+expr+")";


        // XXX hack that my little brain seems to want...
        // XXX add as many parens at beginning as necessary
        while (numOccurancesOf(term, "(")
             < numOccurancesOf(term, ")"))
        {
            term = "(" + term;
        }


        SPolytope result = eval(term,
                                dim,
                                fullDim,
                                varNames,
                                varValues,
                                rest);
        if (rest[0].length() != 0)
        {
            int errorOffsetInTerm = term.length() - rest[0].length();
            throw new java.text.ParseException("Trailing garbage \""+rest[0]+"\" in expression \""+term+"\"",errorOffsetInTerm);
        }

        if (!isOrientedDeep(result.p))
        {
            System.out.println("WARNING: top-level eval returning a badly oriented polytope!");
        }
        return result;
    } // eval



    /**
    *  A little test program...
    *  Take two hypercubes, and do union, intersection, and difference.
    */
    public static void main(String args[])
        throws java.io.IOException
    {
        System.out.println("in main");

        if (false)
        {
            // just test make regular polytope
            if (args.length < 1)
            {
                System.err.println("Usage: CSG [regularStarPolytopeProductString]");
                System.exit(1);
            }
            SPolytope sp = makeRegularStarPolytopeProductFromString(args[0]);

            System.out.println("        " + "counts(sp.p)" + " = " + VecMath.toString(counts(sp.p)));
            {System.out.print("        "); System.out.println("sp" + " = " + (sp));};
            return;
        }

        if (args.length < 1)
        {
            System.err.println("Usage: CSG <dim> [<expr>]");
            System.err.println("(omitting expr gives an interactive shell)");
            System.exit(1);
        }

        int fullDim = Integer.parseInt(args[0]);
        int dim = fullDim;

        if (false)
        {
            // just test simplex
            {System.out.print("        "); System.out.println("makeSimplex(dim)" + " = " + (makeSimplex(dim)));};
            return;
        }

        if (false) // XXX need different modes!
        {
            Object testCases[][] = new Object[0][];
            if (true)
            {
                // Make a cross polytope {3,3,...,3,4}
                // and slice it on the equator.
                // This is a minimal test of when vertices lie on the cutting plane.
                do { if (!(dim >= 2)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+8659 +"): " + "dim >= 2" + ""); } while (false);
                String schlafli = "{";
                for (int i = 0; (i) < (dim-2); ++i)
                    schlafli += "3,";
                schlafli += "4}";
                SPolytope sp = makeRegularStarPolytopeProductFromString(schlafli);
                {System.out.print("        "); System.out.println("schlafli" + " = " + (schlafli));};

                // Cutting plane passes through origin,
                // with normal pointing in direction of first vertex.
                Polytope v0 = sp.p.getAllElements()[0][0];
                double v0coords[] = v0.getCoords();
                System.out.println("        " + "v0coords" + " = " + VecMath.toString(v0coords));
                Hyperplane hyperplane = new Hyperplane(v0coords, 0.);
                String description = "cross polytope sliced on its equator";

                testCases = (Object[][])Arrays.append(testCases, new Object[]{sp,hyperplane,description});
            }
            if (true)
            {
                // Make a hypercube {4,3,3,...,3}
                do { if (!(dim >= 2)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+8680 +"): " + "dim >= 2" + ""); } while (false);
                SPolytope sp = makeHypercube(dim);
                if (true)
                {
                    // and slice it by a plane with normal pointing at a facet
                    // (i.e. side of square, or face of cube, or cell of hypercube, etc.)
                    Polytope firstFacet = sp.p.facets[0].p;
                    double firstFacetCenter[] = cgOfVerts(firstFacet);
                    System.out.println("        " + "firstFacetCenter" + " = " + VecMath.toString(firstFacetCenter));
                    Hyperplane hyperplane = new Hyperplane(firstFacetCenter, 0.);
                    String description = "hypercube sliced by plane through origin with normal pointing at a facet";

                    testCases = (Object[][])Arrays.append(testCases, new Object[]{sp,hyperplane,description});
                }
                if (true)
                {
                    // and slice it by a plane with normal pointing at a ridge
                    // (i.e. vertex of square, or edge of cube, or face of hypercube, etc.)
                    Polytope firstRidge = sp.p.facets[0].p.facets[0].p;
                    double firstRidgeCenter[] = cgOfVerts(firstRidge);
                    System.out.println("        " + "firstRidgeCenter" + " = " + VecMath.toString(firstRidgeCenter));
                    Hyperplane hyperplane = new Hyperplane(firstRidgeCenter, 0.);
                    String description = "hypercube sliced by plane through origin with normal pointing at a ridge";

                    testCases = (Object[][])Arrays.append(testCases, new Object[]{sp,hyperplane,description});
                }
                if (true)
                {
                    // slice it by a plane with normal pointing at a vertex,
                    // passing through that vertex's adjacent vertices
                    Polytope e0 = sp.p.getAllElements()[1][0];
                    Polytope v0 = e0.facets[0].p;
                    Polytope v1 = e0.facets[1].p;
                    double v0coords[] = v0.getCoords();
                    double v1coords[] = v1.getCoords();
                    double offset = VecMath.dot(v0coords, v1coords);
                    Hyperplane hyperplane = new Hyperplane(v0coords, offset);
                    String description = "hypercube sliced by plane with normal pointing at a vertex, through that vertex's adjacent vertices";

                    testCases = (Object[][])Arrays.append(testCases, new Object[]{sp,hyperplane,description});
                }
            }

            for (int iTestCase = 0; (iTestCase) < (testCases.length); ++iTestCase)
            {
                SPolytope sp = (SPolytope)testCases[iTestCase][0];
                Hyperplane hyperplane = (Hyperplane)testCases[iTestCase][1];
                String description = (String)testCases[iTestCase][2];

                System.out.println("=============================================");
                System.out.println("starting: "+description);
                System.out.println("=============================================");

                {System.out.print("        "); System.out.println("sp" + " = " + (sp));};
                {System.out.print("        "); System.out.println("hyperplane" + " = " + (hyperplane));};

                verboseLevel = 3; // gory details
                if (true)
                {
                    SPolytope below[] = new SPolytope[1];
                    SPolytope belowCapFacet[] = new SPolytope[1];
                    SPolytope aboveCapFacet[] = new SPolytope[1];
                    SPolytope above[] = new SPolytope[1];
                    slice(sp, hyperplane, null, below,0, belowCapFacet,0, aboveCapFacet,0, above,0);
                    {System.out.print("        "); System.out.println("below[0]" + " = " + (below[0]));};
                    {System.out.print("        "); System.out.println("belowCapFacet[0]" + " = " + (belowCapFacet[0]));};
                    {System.out.print("        "); System.out.println("aboveCapFacet[0]" + " = " + (aboveCapFacet[0]));};
                    {System.out.print("        "); System.out.println("above[0]" + " = " + (above[0]));};

                    {System.out.print("        "); System.out.println("below[0].p.getAllElements().length" + " = " + (below[0].p.getAllElements().length));};
                    for (int i = 0; (i) < (below[0].p.getAllElements().length); ++i)
                        System.out.println("    below[0].p.getAllElements()["+i+"] = "+below[0].p.getAllElements()[i].length);

                    {System.out.print("        "); System.out.println("belowCapFacet[0].p.getAllElements().length" + " = " + (belowCapFacet[0].p.getAllElements().length));};
                    for (int i = 0; (i) < (belowCapFacet[0].p.getAllElements().length); ++i)
                        System.out.println("    belowCapFacet[0].p.getAllElements()["+i+"] = "+belowCapFacet[0].p.getAllElements()[i].length);

                    {System.out.print("        "); System.out.println("aboveCapFacet[0].p.getAllElements().length" + " = " + (aboveCapFacet[0].p.getAllElements().length));};
                    for (int i = 0; (i) < (aboveCapFacet[0].p.getAllElements().length); ++i)
                        System.out.println("    aboveCapFacet[0].p.getAllElements()["+i+"] = "+aboveCapFacet[0].p.getAllElements()[i].length);

                    {System.out.print("        "); System.out.println("above[0].p.getAllElements().length" + " = " + (above[0].p.getAllElements().length));};
                    for (int i = 0; (i) < (above[0].p.getAllElements().length); ++i)
                        System.out.println("    above[0].p.getAllElements()["+i+"] = "+above[0].p.getAllElements()[i].length);
                }

                if (true)
                {
                    SPolytope sliced = sliceElements(sp, dim-1, hyperplane, null, null);
                    {System.out.print("        "); System.out.println("sliced" + " = " + (sliced));};
                    {System.out.print("        "); System.out.println("sliced.p.getAllElements().length" + " = " + (sliced.p.getAllElements().length));};
                    for (int i = 0; (i) < (sliced.p.getAllElements().length); ++i)
                        System.out.println("    sliced.p.getAllElements()["+i+"] = "+sliced.p.getAllElements()[i].length);
                    do { if (!(isOrientedDeep(sliced.p))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+8773 +"): " + "isOrientedDeep(sliced.p)" + ""); } while (false);
                    if (true) // XXX probably no longer needed
                    {
                        System.out.println("calling orientDeep...");
                        orientDeepFunctional(sliced);
                        orientDeepCosmetic(sliced);
                        {System.out.print("        "); System.out.println("sliced" + " = " + (sliced));};
                    }
                    do { if (!(isOrientedDeep(sliced.p))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+8781 +"): " + "isOrientedDeep(sliced.p)" + ""); } while (false);
                    do { if (!(isBinaryDensityDeep(sliced))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CSG.prejava"+"("+8782 +"): " + "isBinaryDensityDeep(sliced)" + ""); } while (false);
                }
                System.out.println("=============================================");
                System.out.println("finished: "+description);
                System.out.println("=============================================");

            } // for iTestCase
            System.out.println("Did "+testCases.length+" test case"+(testCases.length==1?"":"s")+"; exiting");
            return;
        }


        System.out.println("Making A,B,C");
        SPolytope A = makeHypercube(VecMath.fillvec(dim, -1.), 2.);
        SPolytope B = makeHypercube(VecMath.fillvec(dim, 1.), 2.);
        SPolytope C = makeHypercube(VecMath.fillvec(dim, 0.), 2.);
        //SPolytope simplex = makeSimplex(dim);
        SPolytope simplex = A; // XXX not ready yet
// 8963 # 8845 "com/donhatchsw/util/CSG.prejava"
        if (args.length >= 2)
        {
            //
            // Evaluate given input expression
            //
            String expr = args[1];
            String varNames[][] = {{"A","B","C","simplex"}};
            SPolytope varValues[][] = {{ A, B, C, simplex }};
            SPolytope result = null;
            try
            {
                result = eval(expr,
                              dim,
                              fullDim,
                              varNames,
                              varValues);
            }
            catch (java.text.ParseException e)
            {
                System.err.println("Exception parsing expression \""+expr+"\": "+e);
            }
            {System.out.print("        "); System.out.println("expr" + " = " + (expr));};
            {System.out.print("        "); System.out.println("result" + " = " + (result));};
        }
        else
        {
            //
            // Do a command shell.  Woohoo!
            //
            java.io.BufferedReader reader =
                new java.io.BufferedReader(
                    new java.io.InputStreamReader(System.in));

            // XXX hellacious hack for one-time-only pushback.
            // XXX it doesn't work anyway; the newline doesn't seem to make it.
            // XXX why not???
            if (false)
            {
                String nl = System.getProperty("line.separator");
                java.io.PushbackReader pushbackReader = new java.io.PushbackReader(new java.io.InputStreamReader(System.in), 100);
                pushbackReader.unread(("help"+nl).toCharArray());
                reader = new java.io.BufferedReader(pushbackReader);
            }

            String prompt = "yeah? ";

            String varNames[][] = {{"A","B","C","simplex"}};
            SPolytope varValues[][] = {{ A, B, C, simplex }};

            {
                System.out.println("Current variables:");
                for (int iVar = 0; (iVar) < (varNames[0].length); ++iVar)
                {
                    System.out.print("    " + varNames[0][iVar] + " = ");
                    System.out.println(varValues[0][iVar].toString("        "));
                }
            }

            while (true)
            {
                System.out.print(prompt);
                String line = reader.readLine();
                if (line == null)
                    break;
                line = line.trim();
                if (line.equals(""))
                    continue;

                //
                // Special variables...
                //
                if (line.startsWith("v=")
                 || line.startsWith("v ="))
                {
                    verboseLevel = Integer.parseInt(line.substring(line.indexOf('=')+1));
                    {System.out.print("        "); System.out.println("verboseLevel" + " = " + (verboseLevel));};
                    continue;
                }
                if (line.startsWith("d=")
                 || line.startsWith("d =")
                 || line.startsWith("dim=")
                 || line.startsWith("dim ="))
                {
                    fullDim = Integer.parseInt(line.substring(line.indexOf('=')+1));
                    dim = fullDim;
                    {System.out.print("        "); System.out.println("dim" + " = " + (dim));};
                    System.out.println("WARNING: polytopes of different dimensions will act strangely when mixed");
                    continue;
                }
                if (line.equals("q")
                 || line.equals("quit")
                 || line.equals("exit"))
                {
                    break;
                }
                if (line.equals("help"))
                {
                    {
                        System.out.println("Current variables:");
                        for (int iVar = 0; (iVar) < (varNames[0].length); ++iVar)
                        {
                            System.out.print("    " + varNames[0][iVar] + " = ");
                            System.out.println(varValues[0][iVar].toString("        "));
                        }
                    }
                    continue;
                }

                SPolytope result = null;
                try
                {
                    result = eval(
                                 line,
                                 dim,
                                 fullDim,
                                 varNames,
                                 varValues);
                }
                catch (java.text.ParseException pe)
                {
                    System.err.println("Parse error in expression \""+line+"\": ");
                    System.err.println("    "+pe.getLocalizedMessage()+", position "+pe.getErrorOffset());
                }
                if (result != null)
                {
                    System.out.println(result);
                    System.out.println("        " + "counts(result.p)" + " = " + VecMath.toString(counts(result.p)));
                    {System.out.print("        "); System.out.println("volume(result)" + " = " + (volume(result)));};

                    for (int iFacet = 0; (iFacet) < (result.p.facets.length); ++iFacet)
                    {
                        double areaNormalOfFacet[] = new double[dim];
                        areaNormal(areaNormalOfFacet, result.p.facets[iFacet]);
                        System.out.println("areaNormal(facets["+iFacet+"]) = "+ VecMath.toString(areaNormalOfFacet));
                        System.out.println("volume(facets["+iFacet+"]) = "+ volume(result.p.facets[iFacet]));
                    }

                    if (!isOrientedDeep(result.p))
                        System.out.println("WARNING: that was badly oriented!");
                    if (!isBinaryDensityDeep(result))
                        System.out.println("WARNING: that didn't have binary density!  Or something!");
                }
            }
        }

        System.out.println("out main");
    } // main


    //
    // Not used anywhere, but this is an example
    // of pcalc format...
    // Generated using the command:
    //    pcalc "{3,3}"
    //    pcalc "{5,3}"
    //    pcalc "{3,3,3}"
    //    pcalc "{5,3,3}"
    //    pcalc grand_antiprism
    private static String pcalcString33 = ""
        +"4 0-cells:\n"
        +" 0:     0.5 0.28867513459481287 0.20412414523193151\n"
        +" 1:     0 0 -0.61237243569579447\n"
        +" 2:     0 -0.57735026918962573 0.20412414523193151\n"
        +" 3:     -0.5 0.28867513459481287 0.20412414523193151\n"
        +"6 1-cells:\n"
        +" 0:    -0 +1\n"
        +" 1:    -2 +1\n"
        +" 2:    -0 +2\n"
        +" 3:    -3 +1\n"
        +" 4:    -3 +2\n"
        +" 5:    -0 +3\n"
        +"4 2-cells:\n"
        +" 0:    +0 -1 -2\n"
        +" 1:    +1 -3 +4\n"
        +" 2:    -0 +5 +3\n"
        +" 3:    +2 -4 -5\n"
        +"1 3-cell:\n"
        +" 0:    +0 +1 +2 +3\n"
        ;

} // CSG
